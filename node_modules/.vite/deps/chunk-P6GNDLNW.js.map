{
  "version": 3,
  "sources": ["../../@threlte/core/dist/context/fragments/cache.js", "../../@threlte/core/dist/context/fragments/camera.js", "../../@threlte/core/dist/utilities/observe.svelte.js", "../../@threlte/core/dist/utilities/isInstanceOf.js", "../../@threlte/core/dist/utilities/asyncWritable.js", "../../@threlte/core/dist/utilities/browser.js", "../../@threlte/core/dist/utilities/revision.js", "../../@threlte/core/dist/utilities/watch.js", "../../@threlte/core/dist/utilities/currentWritable.js", "../../@threlte/core/dist/utilities/resolvePropertyPath.js", "../../@threlte/core/dist/context/fragments/dom.js", "../../mitt/src/index.ts", "../../@threlte/core/dist/frame-scheduling/DAG.js", "../../@threlte/core/dist/frame-scheduling/Task.js", "../../@threlte/core/dist/frame-scheduling/Stage.js", "../../@threlte/core/dist/frame-scheduling/Scheduler.js", "../../@threlte/core/dist/context/fragments/scheduler.svelte.js", "../../@threlte/core/dist/context/fragments/disposal.js", "../../@threlte/core/dist/context/fragments/parent.js", "../../@threlte/core/dist/context/fragments/parentObject3D.js", "../../@threlte/core/dist/context/fragments/renderer.svelte.js", "../../@threlte/core/dist/hooks/useTask.js", "../../@threlte/core/dist/context/fragments/scene.js", "../../@threlte/core/dist/context/fragments/user.js", "../../@threlte/core/dist/context/createThrelteContext.svelte.js", "../../@threlte/core/dist/components/Context/Context.svelte", "../../@threlte/core/dist/Canvas.svelte", "../../@threlte/core/dist/components/T/T.js", "../../@threlte/core/dist/context/compounds/useThrelte.js", "../../@threlte/core/dist/components/T/utils/useAttach.svelte.js", "../../@threlte/core/dist/components/T/utils/useCamera.svelte.js", "../../@threlte/core/dist/components/T/utils/useDispose.svelte.js", "../../@threlte/core/dist/components/T/utils/useEvents.svelte.js", "../../@threlte/core/dist/components/T/utils/useIs.js", "../../@threlte/core/dist/plugins/types.js", "../../@threlte/core/dist/components/T/utils/usePlugins.js", "../../@threlte/core/dist/components/T/utils/useProps.js", "../../@threlte/core/dist/components/T/utils/utils.js", "../../@threlte/core/dist/components/T/T.svelte", "../../@threlte/core/dist/plugins/injectPlugin.js", "../../@threlte/core/dist/hooks/useStage.js", "../../@threlte/core/dist/hooks/useThrelteUserContext.js", "../../@threlte/core/dist/hooks/useLoader.js", "../../@threlte/core/dist/index.js"],
  "sourcesContent": ["import { getContext, setContext } from 'svelte';\nexport const shallowEqualArrays = (arrA, arrB) => {\n    if (arrA === arrB)\n        return true;\n    if (!arrA || !arrB)\n        return false;\n    const len = arrA.length;\n    if (arrB.length !== len)\n        return false;\n    for (let i = 0; i < len; i++)\n        if (arrA[i] !== arrB[i])\n            return false;\n    return true;\n};\n/**\n * ### `createCacheContext`\n *\n * Every Threlte application has its own cache. This prevents models from being\n * shared between applications because e.g. THREE.Mesh objects cannot be mounted\n * in multiple scenes.\n */\nexport const createCacheContext = () => {\n    const items = [];\n    const remember = (callback, keys) => {\n        for (let i = 0; i < items.length; i++) {\n            const entry = items[i];\n            if (shallowEqualArrays(keys, entry.keys)) {\n                if (entry.promise)\n                    return entry.promise;\n            }\n        }\n        // If no match was found, create a new entry\n        const entry = {\n            promise: callback(),\n            keys\n        };\n        // Add the entry to the cache\n        items.push(entry);\n        // Return the promise\n        return entry.promise;\n    };\n    const clear = (keys) => {\n        for (let i = 0; i < items.length; i++) {\n            const entry = items[i];\n            if (shallowEqualArrays(keys, entry.keys)) {\n                items.splice(i, 1);\n                return;\n            }\n        }\n    };\n    const context = { items, remember, clear };\n    setContext('threlte-cache', context);\n    return context;\n};\n/**\n * ### `useCache`\n *\n * This hook is used to access the cache. It returns a `remember` function that\n * can be used to cache a promise based on the provided keys. The `remember`\n * function will return the cached value if the promise has already been\n * resolved and the keys match.\n *\n * @example\n * ```ts\n * const { remember } = useCache()\n *\n * const asyncWritable = remember(async () => {\n *  const loader = new GLTFLoader()\n *  const { scene } = await loader.loadAsync('/path/to/model.glb')\n *  return scene\n * })\n * ```\n *\n * The model will only be loaded once, even if `remember` is invoked multiple\n * times with the same keys.\n *\n * The `clear` function can be used to clear the cache for a specific set of keys.\n */\nexport const useCache = () => {\n    const cache = getContext('threlte-cache');\n    if (!cache) {\n        throw new Error('No cache found. The cache can only be used in a child component to <Canvas>.');\n    }\n    return cache;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { PerspectiveCamera } from 'three';\nimport { currentWritable, watch } from '../../utilities/index.js';\nimport { useDOM } from './dom.js';\nimport { useScheduler } from './scheduler.svelte.js';\nexport const createCameraContext = () => {\n    const { size } = useDOM();\n    const { invalidate } = useScheduler();\n    // Create a default camera to use when no camera is defined by the user\n    const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1000);\n    defaultCamera.position.z = 5;\n    defaultCamera.lookAt(0, 0, 0);\n    const camera = currentWritable(defaultCamera);\n    watch(size, (size) => {\n        if (camera.current === defaultCamera) {\n            const cam = camera.current;\n            cam.aspect = size.width / size.height;\n            cam.updateProjectionMatrix();\n            invalidate();\n        }\n    });\n    watch(camera, ($camera) => {\n        if ($camera === undefined) {\n            camera.set(defaultCamera);\n        }\n    });\n    const context = { camera };\n    setContext('threlte-camera-context', context);\n    return context;\n};\nexport const useCamera = () => {\n    const context = getContext('threlte-camera-context');\n    if (!context) {\n        throw new Error('useCamera can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { untrack } from 'svelte';\nimport { fromStore } from 'svelte/store';\nconst signal = Symbol();\nconst isStore = (dep) => {\n    return typeof dep?.subscribe === 'function';\n};\nconst runObserve = (dependencies, callback, pre) => {\n    const stores = dependencies().map((d) => {\n        if (isStore(d)) {\n            return fromStore(d);\n        }\n        return signal;\n    });\n    const deps = $derived(dependencies().map((d, i) => {\n        if (stores[i] === signal)\n            return d;\n        return stores[i].current;\n    }));\n    const effect = () => {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        deps;\n        let cleanup = undefined;\n        untrack(() => {\n            cleanup = callback(deps);\n        });\n        return cleanup;\n    };\n    if (pre) {\n        $effect.pre(effect);\n    }\n    else {\n        $effect(effect);\n    }\n};\n/**\n * ### `observe`\n *\n * Observe multiple stores and reactive values and call a callback when they\n * change to trigger side effects. The callback can return a cleanup function\n * that will be called when the dependencies change again or when the effect\n * root (most likely a component) is destroyed. Under the hood, `observe` uses\n * Svelte's `$effect` to track dependencies and trigger the callback. For a\n * version that uses `$effect.pre`, use `observe.pre`.\n *\n * ```ts\n * const count = writable(0)\n * let name = $state('John')\n *\n * observe(() => [count, name], ([count, name]) => {\n *  console.log(count, name) // 0 John\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the\n * dependencies change again or when the component is destroyed.\n *\n * ```ts\n * const count = writable(0)\n *\n * observe(() => [count], ([count]) => {\n *  console.log(count) // 0\n *  return () => {\n *    console.log('cleanup')\n *  }\n * })\n * ```\n *\n * @param dependencies - A function that returns an array of dependencies.\n * @param callback - A function that will be called with the current values of\n * the dependencies. The callback can return a cleanup function that will be\n * called when the dependencies change again or when the component is destroyed.\n */\nconst observePost = (dependencies, callback) => {\n    return runObserve(dependencies, callback, false);\n};\n/**\n * ### `observe.pre`\n *\n * Observe multiple stores and reactive values and call a callback when they\n * change to trigger side effects. The callback can return a cleanup function\n * that will be called when the dependencies change again or when the effect\n * root (most likely a component) is destroyed. Under the hood, `observe.pre` uses\n * Svelte's `$effect` to track dependencies and trigger the callback. For a\n * version that uses `$effect`, use `observe`.\n *\n * ```ts\n * const count = writable(0)\n * let name = $state('John')\n *\n * observe.pre(() => [count, name], ([count, name]) => {\n *  console.log(count, name) // 0 John\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the\n * dependencies change again or when the component is destroyed.\n *\n * ```ts\n * const count = writable(0)\n *\n * observe.pre(() => [count], ([count]) => {\n *  console.log(count) // 0\n *  return () => {\n *    console.log('cleanup')\n *  }\n * })\n * ```\n *\n * @param dependencies - A function that returns an array of dependencies.\n * @param callback - A function that will be called with the current values of\n * the dependencies. The callback can return a cleanup function that will be\n * called when the dependencies change again or when the component is destroyed.\n */\nconst observePre = (dependencies, callback) => {\n    return runObserve(dependencies, callback, true);\n};\nexport const observe = Object.assign(observePost, { pre: observePre });\n", "/**\n * Check if an object is an instance of a given THREE class. Can be used as a\n * type guard and as an alternative to `instanceof` which is prone to error and\n * slower. It uses the `isFoo` property that THREE classes have to determine if\n * an object is of a particular class.\n *\n * @example\n * ```ts\n * const obj = new THREE.Object3D()\n * isInstanceOf(obj, 'Object3D') // true\n * ```\n *\n * @param obj - The object to check.\n * @param type - The class name to check against.\n * @returns `true` if the object is an instance of the class, `false` otherwise.\n */\nexport const isInstanceOf = (obj, type) => {\n    return obj?.[`is${type}`] === true;\n};\n", "import { writable } from 'svelte/store';\n/**\n * ### `asyncWritable`\n *\n * Creates a writable store that is initialized with a promise. The store also\n * implements the `then` and `catch` methods of the promise so that it can be\n * used in `await` expressions and `{#await}` blocks of Svelte.\n *\n * ```svelte\n * <script>\n *  import { asyncWritable } from '@threlte/core'\n *\n *  const asyncOp = async () => {\n *    // Do something async\n *  }\n *\n *  const store = asyncWritable(asyncOp())\n *  $: console.log($store) // asyncOp result\n * </script>\n *\n * <h1>\n *  {#await store then data}\n *    // Do something with the data\n *  {/await}\n * </h1>\n * ```\n *\n * If an error occurs in the promise, the error will be logged to the console\n * and the error can be accessed via the `error` property of the store with in\n * turn is a store.\n *\n * ```svelte\n * <script>\n *  import { asyncWritable } from '@threlte/core'\n *\n *  const asyncOp = async () => {\n *    throw new Error('Something went wrong')\n *  }\n *\n *  const store = asyncWritable(asyncOp())\n *  const error = store.error\n *\n *  $: console.log($store) // undefined\n *  $: console.log($error) // Error: Something went wrong\n * </script>\n * ```\n */\nexport const asyncWritable = (promise) => {\n    const store = writable(undefined);\n    const error = writable(undefined);\n    promise\n        .then((result) => {\n        store.set(result);\n    })\n        .catch((e) => {\n        console.error('Error in asyncWritable:', e.message);\n        error.set(e);\n    });\n    return Object.assign(Object.assign(promise, store), { error, promise });\n};\n", "export const browser = typeof window !== 'undefined';\n", "import { REVISION } from 'three';\n// REVISION can be '{number}' or '{number}dev'\nconst normalizedRevision = REVISION.replace('dev', '');\n/**\n * The current Three.js revision.\n */\nexport const revision = Number.parseInt(normalizedRevision);\n", "import { onDestroy } from 'svelte';\nimport { derived } from 'svelte/store';\n/**\n * ### `watch`\n *\n * Watch a single store or multiple stores and call a callback when they change to trigger side effects.\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\n *\n * ```ts\n * const store = writable(0)\n *\n * watch(store, (value) => {\n * \tconsole.log(value) // 0\n * })\n * ```\n *\n * You can also watch multiple stores:\n *\n * ```ts\n * const store1 = writable(0)\n * const store2 = writable(1)\n *\n * watch([store1, store2], ([value1, value2]) => {\n * \tconsole.log(value1, value2) // 0 1\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\n *\n * ```ts\n * const store = writable(0)\n *\n * watch(store, (value) => {\n * \tconsole.log(value) // 0\n * \treturn () => {\n * \t\tconsole.log('cleanup')\n * \t}\n * })\n * ```\n *\n * @param stores\n * @param callback\n */\nexport const watch = (stores, callback) => {\n    const d = derived(stores, (values) => {\n        return values;\n    });\n    let cleanupFn;\n    const unsubscribe = d.subscribe(async (values) => {\n        if (cleanupFn)\n            cleanupFn();\n        const fn = await callback(values);\n        if (fn)\n            cleanupFn = fn;\n    });\n    onDestroy(() => {\n        unsubscribe();\n        if (cleanupFn)\n            cleanupFn();\n    });\n};\n", "import { writable } from 'svelte/store';\n/**\n * ### `currentWritable`\n *\n * A writable store that also has a `current` property that is updated synchronously.\n * For use in non-reactive contexts e.g. loops where unwrapping a store every frame is expensive.\n *\n * ```ts\n * const store = currentWritable(0)\n *\n * useTask(() => {\n * \tconsole.log(store.current) // 0\n * })\n *\n * @param value\n * @returns\n */\nexport const currentWritable = (value) => {\n    const store = writable(value);\n    const extendedWritable = {\n        set: (value) => {\n            extendedWritable.current = value;\n            store.set(value);\n        },\n        subscribe: store.subscribe,\n        update: (fn) => {\n            const newValue = fn(extendedWritable.current);\n            extendedWritable.current = newValue;\n            store.set(newValue);\n        },\n        current: value\n    };\n    return extendedWritable;\n};\nexport const toCurrentReadable = (store) => {\n    return {\n        subscribe: store.subscribe,\n        get current() {\n            return store.current;\n        }\n    };\n};\n", "/**\n * ### `resolvePropertyPath`\n *\n * This function resolves a property path to a target object and the property\n * key. The property path can include dots to indicate nested objects.\n *\n *  ```ts\n * const object = { position: { x: 0 } }\n * const { target, key } = resolvePropertyPath(object, 'position.x')\n *\n * // target is { x: 0 }\n * // key is 'x'\n * ```\n */\nexport const resolvePropertyPath = (target, propertyPath) => {\n    if (propertyPath.includes('.')) {\n        const path = propertyPath.split('.');\n        const key = path.pop();\n        for (let i = 0; i < path.length; i += 1) {\n            target = target[path[i]];\n        }\n        return {\n            target,\n            key\n        };\n    }\n    else {\n        return {\n            target,\n            key: propertyPath\n        };\n    }\n};\n", "import { getContext, onMount, setContext } from 'svelte';\nimport { currentWritable, toCurrentReadable } from '../../utilities/index.js';\nexport const createDOMContext = (options) => {\n    const { dom, canvas } = options;\n    const size = currentWritable({ width: dom.offsetWidth, height: dom.offsetHeight });\n    onMount(() => {\n        const resizeObserver = new ResizeObserver(() => {\n            const { offsetWidth, offsetHeight } = dom;\n            if (size.current.width !== offsetWidth || size.current.height !== offsetHeight) {\n                size.set({ width: offsetWidth, height: offsetHeight });\n            }\n        });\n        resizeObserver.observe(dom);\n        return () => {\n            resizeObserver.disconnect();\n        };\n    });\n    const context = {\n        dom,\n        canvas,\n        size: toCurrentReadable(size)\n    };\n    setContext('threlte-dom-context', context);\n    return context;\n};\nexport const useDOM = () => {\n    const context = getContext('threlte-dom-context');\n    if (!context) {\n        throw new Error('useDOM can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n", "import mitt, {} from 'mitt';\nexport class DAG {\n    allVertices = {};\n    /** Nodes that are fully unlinked */\n    isolatedVertices = {};\n    connectedVertices = {};\n    sortedConnectedValues = [];\n    needsSort = false;\n    emitter = mitt();\n    emit = this.emitter.emit.bind(this.emitter);\n    on = this.emitter.on.bind(this.emitter);\n    off = this.emitter.off.bind(this.emitter);\n    get sortedVertices() {\n        return this.mapNodes((value) => value);\n    }\n    moveToIsolated(key) {\n        const vertex = this.connectedVertices[key];\n        if (!vertex)\n            return;\n        this.isolatedVertices[key] = vertex;\n        delete this.connectedVertices[key];\n    }\n    moveToConnected(key) {\n        const vertex = this.isolatedVertices[key];\n        if (!vertex)\n            return;\n        this.connectedVertices[key] = vertex;\n        delete this.isolatedVertices[key];\n    }\n    getKey = (v) => {\n        if (typeof v === 'object') {\n            return v.key;\n        }\n        return v;\n    };\n    add(key, value, options) {\n        if (this.allVertices[key] && this.allVertices[key].value !== undefined) {\n            throw new Error(`A node with the key ${key.toString()} already exists`);\n        }\n        let vertex = this.allVertices[key];\n        if (!vertex) {\n            vertex = {\n                value: value,\n                previous: new Set(),\n                next: new Set()\n            };\n            // add the vertex to the list of all vertices\n            this.allVertices[key] = vertex;\n        }\n        else if (vertex.value === undefined) {\n            vertex.value = value;\n        }\n        // if another node referenced this node before, we have inverse links\n        const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;\n        if (!options?.after && !options?.before && !hasEdges) {\n            // the node we're about to add is fully unlinked\n            this.isolatedVertices[key] = vertex;\n            this.emit('node:added', {\n                key,\n                type: 'isolated',\n                value\n            });\n            return;\n        }\n        else {\n            this.connectedVertices[key] = vertex;\n        }\n        if (options?.after) {\n            const afterArr = Array.isArray(options.after) ? options.after : [options.after];\n            // we need to update the vertex to include the new \"after\" nodes\n            afterArr.forEach((after) => {\n                vertex.previous.add(this.getKey(after));\n            });\n            afterArr.forEach((after) => {\n                const afterKey = this.getKey(after);\n                // we get the vertex from the list of all vertices\n                const linkedAfter = this.allVertices[afterKey];\n                if (!linkedAfter) {\n                    // if it doesn't exist, we create it\n                    this.allVertices[afterKey] = {\n                        value: undefined, // uninitialized\n                        previous: new Set(),\n                        next: new Set([key])\n                    };\n                    this.connectedVertices[afterKey] = this.allVertices[afterKey];\n                }\n                else {\n                    // if it does exist, we update it\n                    linkedAfter.next.add(key);\n                    // we might need to move the vertex from isolated to connected\n                    this.moveToConnected(afterKey);\n                }\n            });\n        }\n        if (options?.before) {\n            const beforeArr = Array.isArray(options.before) ? options.before : [options.before];\n            // we need to update the vertex to include the new \"before\" nodes\n            beforeArr.forEach((before) => {\n                vertex.next.add(this.getKey(before));\n            });\n            beforeArr.forEach((before) => {\n                const beforeKey = this.getKey(before);\n                // we get the vertex from the list of all vertices\n                const linkedBefore = this.allVertices[beforeKey];\n                if (!linkedBefore) {\n                    // if it doesn't exist, we create it\n                    this.allVertices[beforeKey] = {\n                        value: undefined, // uninitialized\n                        previous: new Set([key]),\n                        next: new Set()\n                    };\n                    this.connectedVertices[beforeKey] = this.allVertices[beforeKey];\n                }\n                else {\n                    // if it does exist, we update it\n                    linkedBefore.previous.add(key);\n                    // we might need to move the vertex from isolated to connected\n                    this.moveToConnected(beforeKey);\n                }\n            });\n        }\n        this.emit('node:added', {\n            key,\n            type: 'connected',\n            value\n        });\n        // Mark the graph as needing a re-sort\n        this.needsSort = true;\n    }\n    remove(key) {\n        const removeKey = this.getKey(key);\n        // check if it's an unlinked vertex\n        const unlinkedVertex = this.isolatedVertices[removeKey];\n        if (unlinkedVertex) {\n            delete this.isolatedVertices[removeKey];\n            delete this.allVertices[removeKey];\n            this.emit('node:removed', {\n                key: removeKey,\n                type: 'isolated'\n            });\n            return;\n        }\n        // if it's not, it's a bit more complicated\n        const linkedVertex = this.connectedVertices[removeKey];\n        if (!linkedVertex) {\n            // The node does not exist in the graph.\n            return;\n        }\n        // Update the 'next' nodes that this node points to\n        linkedVertex.next.forEach((nextKey) => {\n            const nextVertex = this.connectedVertices[nextKey];\n            if (nextVertex) {\n                nextVertex.previous.delete(removeKey);\n                if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {\n                    this.moveToIsolated(nextKey);\n                }\n            }\n        });\n        // Update the 'previous' nodes that point to this node\n        linkedVertex.previous.forEach((prevKey) => {\n            const prevVertex = this.connectedVertices[prevKey];\n            if (prevVertex) {\n                prevVertex.next.delete(removeKey);\n                if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {\n                    this.moveToIsolated(prevKey);\n                }\n            }\n        });\n        // Finally, remove the node from the graph\n        delete this.connectedVertices[removeKey];\n        delete this.allVertices[removeKey];\n        this.emit('node:removed', {\n            key: removeKey,\n            type: 'connected'\n        });\n        // Mark the graph as needing a re-sort\n        this.needsSort = true;\n    }\n    mapNodes(callback) {\n        if (this.needsSort) {\n            this.sort();\n        }\n        const result = [];\n        this.forEachNode((value, index) => {\n            result.push(callback(value, index));\n        });\n        return result;\n    }\n    forEachNode(callback) {\n        if (this.needsSort) {\n            this.sort();\n        }\n        let index = 0;\n        for (; index < this.sortedConnectedValues.length; index++) {\n            callback(this.sortedConnectedValues[index], index);\n        }\n        Reflect.ownKeys(this.isolatedVertices).forEach((key) => {\n            const vertex = this.isolatedVertices[key];\n            if (vertex.value !== undefined)\n                callback(vertex.value, index++);\n        });\n    }\n    getValueByKey(key) {\n        return this.allVertices[key]?.value;\n    }\n    getKeyByValue(value) {\n        return (Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ??\n            Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value));\n    }\n    sort() {\n        const inDegree = new Map();\n        const zeroInDegreeQueue = [];\n        const result = [];\n        // we're only interested in vertices that have a value\n        const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {\n            const vertex = this.connectedVertices[key];\n            return vertex.value !== undefined;\n        });\n        // Initialize inDegree (count of incoming edges) for each vertex\n        connectedVertexKeysWithValues.forEach((vertex) => {\n            inDegree.set(vertex, 0);\n        });\n        // Calculate inDegree for each vertex\n        connectedVertexKeysWithValues.forEach((vertexKey) => {\n            const vertex = this.connectedVertices[vertexKey];\n            vertex.next.forEach((next) => {\n                // check if \"next\" vertex has a value\n                const nextVertex = this.connectedVertices[next];\n                if (!nextVertex)\n                    return;\n                inDegree.set(next, (inDegree.get(next) || 0) + 1);\n            });\n        });\n        // Enqueue vertices with inDegree 0\n        inDegree.forEach((degree, value) => {\n            if (degree === 0) {\n                zeroInDegreeQueue.push(value);\n            }\n        });\n        // Process vertices with inDegree 0 and decrease inDegree of adjacent vertices\n        while (zeroInDegreeQueue.length > 0) {\n            const vertexKey = zeroInDegreeQueue.shift();\n            result.push(vertexKey);\n            const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);\n            if (v) {\n                this.connectedVertices[v]?.next.forEach((adjVertex) => {\n                    const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;\n                    inDegree.set(adjVertex, adjVertexInDegree);\n                    if (adjVertexInDegree === 0) {\n                        zeroInDegreeQueue.push(adjVertex);\n                    }\n                });\n            }\n        }\n        // Check for cycles in the graph\n        if (result.length !== connectedVertexKeysWithValues.length) {\n            throw new Error('The graph contains a cycle, and thus can not be sorted topologically.');\n        }\n        const filterUndefined = (value) => value !== undefined;\n        this.sortedConnectedValues = result\n            .map((key) => this.connectedVertices[key].value)\n            .filter(filterUndefined);\n        this.needsSort = false;\n    }\n    clear() {\n        this.allVertices = {};\n        this.isolatedVertices = {};\n        this.connectedVertices = {};\n        this.sortedConnectedValues = [];\n        this.needsSort = false;\n    }\n    static isKey(value) {\n        return typeof value === 'string' || typeof value === 'symbol';\n    }\n    static isValue(value) {\n        return typeof value === 'object' && 'key' in value;\n    }\n}\n", "export class Task {\n    key;\n    stage;\n    callback;\n    runTask = true;\n    stop() {\n        this.runTask = false;\n    }\n    start() {\n        this.runTask = true;\n    }\n    constructor(stage, key, callback) {\n        this.stage = stage;\n        this.key = key;\n        this.callback = callback;\n    }\n    run(delta) {\n        if (!this.runTask)\n            return;\n        this.callback(delta);\n    }\n}\n", "import { DAG } from './DAG.js';\nimport { Task } from './Task.js';\n/**\n * A Stage is a collection of steps. The steps are run in a topological sort\n * order.\n */\nexport class Stage extends DAG {\n    key;\n    scheduler;\n    runTask = true;\n    stop() {\n        this.runTask = false;\n    }\n    start() {\n        this.runTask = true;\n    }\n    get tasks() {\n        return this.sortedVertices;\n    }\n    callback = (_, r) => r();\n    constructor(scheduler, key, callback) {\n        super();\n        this.scheduler = scheduler;\n        this.key = key;\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        if (callback)\n            this.callback = callback.bind(this);\n    }\n    createTask(key, callback, options) {\n        const task = new Task(this, key, callback);\n        this.add(key, task, options);\n        return task;\n    }\n    getTask(key) {\n        return this.getValueByKey(key);\n    }\n    removeTask = this.remove.bind(this);\n    run(delta) {\n        if (!this.runTask)\n            return;\n        this.callback(delta, (deltaOverride) => {\n            this.forEachNode((task) => {\n                task.run(deltaOverride ?? delta);\n            });\n        });\n    }\n    runWithTiming(delta) {\n        if (!this.runTask)\n            return {};\n        const taskTimings = {};\n        this.callback(delta, (deltaOverride) => {\n            this.forEachNode((task) => {\n                const start = performance.now();\n                task.run(deltaOverride ?? delta);\n                const duration = performance.now() - start;\n                taskTimings[task.key] = duration;\n            });\n        });\n        return taskTimings;\n    }\n    getSchedule() {\n        return this.mapNodes((l) => l.key.toString());\n    }\n}\n", "import { DAG } from './DAG.js';\nimport { Stage } from './Stage.js';\n/**\n * A Scheduler is responsible for running stages. It runs the stages in a\n * requestAnimationFrame stage.\n */\nexport class Scheduler extends DAG {\n    lastTime = performance.now();\n    clampDeltaTo = 0.1;\n    get stages() {\n        return this.sortedVertices;\n    }\n    constructor(options) {\n        super();\n        if (options?.clampDeltaTo)\n            this.clampDeltaTo = options.clampDeltaTo;\n        this.run = this.run.bind(this);\n    }\n    createStage(key, options) {\n        const stage = new Stage(this, key, options?.callback);\n        this.add(key, stage, {\n            after: options?.after,\n            before: options?.before\n        });\n        return stage;\n    }\n    getStage(key) {\n        return this.getValueByKey(key);\n    }\n    removeStage = this.remove.bind(this);\n    /**\n     * Runs all the stages in the scheduler.\n     *\n     * @param time The time in milliseconds since the start of the program.\n     */\n    run(time) {\n        const delta = time - this.lastTime;\n        this.forEachNode((stage) => {\n            // we pass the delta as seconds, not milliseconds,\n            // this is in line with how Three.js, Unity and\n            // other game engines do it. On top of that, it\n            // needs to be clamped to prevent large delta\n            // values from causing large jumps in the game\n            // state.\n            stage.run(Math.min(delta / 1000, this.clampDeltaTo));\n        });\n        this.lastTime = time;\n    }\n    runWithTiming(time) {\n        const delta = time - this.lastTime;\n        const stageTimings = {};\n        const start = performance.now();\n        this.forEachNode((stage) => {\n            const start = performance.now();\n            const taskTimings = stage.runWithTiming(Math.min(delta / 1000, this.clampDeltaTo));\n            const duration = performance.now() - start;\n            stageTimings[stage.key.toString()] = {\n                duration,\n                tasks: taskTimings\n            };\n        });\n        return {\n            total: performance.now() - start,\n            stages: stageTimings\n        };\n    }\n    getSchedule(include = {\n        tasks: true\n    }) {\n        return {\n            stages: this.mapNodes((stage) => {\n                if (stage === undefined)\n                    throw new Error('Stage not found');\n                return {\n                    key: stage.key.toString(),\n                    ...{ tasks: include.tasks ? stage.getSchedule() : undefined }\n                };\n            })\n        };\n    }\n    dispose() {\n        this.clear();\n    }\n}\n", "import { getContext, onDestroy, setContext } from 'svelte';\nimport { currentWritable } from '../../utilities/index.js';\nimport { Scheduler } from '../../frame-scheduling/index.js';\nexport const createSchedulerContext = (options) => {\n    const scheduler = new Scheduler();\n    const mainStage = scheduler.createStage(Symbol('threlte-main-stage'));\n    const context = {\n        scheduler,\n        frameInvalidated: true,\n        autoInvalidations: new Set(),\n        shouldAdvance: false,\n        advance: () => {\n            context.shouldAdvance = true;\n        },\n        autoRender: currentWritable(options.autoRender ?? true),\n        renderMode: currentWritable(options.renderMode ?? 'on-demand'),\n        invalidate() {\n            context.frameInvalidated = true;\n        },\n        mainStage,\n        shouldRender: () => {\n            return (context.renderMode.current === 'always' ||\n                (context.renderMode.current === 'on-demand' &&\n                    (context.frameInvalidated || context.autoInvalidations.size > 0)) ||\n                (context.renderMode.current === 'manual' && context.shouldAdvance));\n        },\n        renderStage: scheduler.createStage(Symbol('threlte-render-stage'), {\n            after: mainStage,\n            callback(_, runTasks) {\n                if (context.shouldRender())\n                    runTasks();\n            }\n        }),\n        resetFrameInvalidation() {\n            context.frameInvalidated = false;\n            context.shouldAdvance = false;\n        }\n    };\n    $effect(() => {\n        context.autoRender.set(options.autoRender ?? true);\n    });\n    $effect(() => {\n        context.renderMode.set(options.renderMode ?? 'on-demand');\n    });\n    onDestroy(() => {\n        context.scheduler.dispose();\n    });\n    setContext('threlte-scheduler-context', context);\n    return context;\n};\nexport const useScheduler = () => {\n    const context = getContext('threlte-scheduler-context');\n    if (!context) {\n        throw new Error('useScheduler can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, onDestroy, setContext, tick } from 'svelte';\nexport const createDisposalContext = () => {\n    const context = {\n        removeObjectFromDisposal: (object) => {\n            context.disposableObjects.delete(object);\n        },\n        disposableObjectMounted: (object) => {\n            const currentValue = context.disposableObjects.get(object);\n            if (currentValue) {\n                context.disposableObjects.set(object, currentValue + 1);\n            }\n            else {\n                context.disposableObjects.set(object, 1);\n            }\n        },\n        disposableObjectUnmounted: (object) => {\n            const currentValue = context.disposableObjects.get(object);\n            if (currentValue && currentValue > 0) {\n                context.disposableObjects.set(object, currentValue - 1);\n                if (currentValue - 1 <= 0) {\n                    context.shouldDispose = true;\n                }\n            }\n        },\n        disposableObjects: new Map(),\n        shouldDispose: false,\n        dispose: async (force = false) => {\n            await tick();\n            if (!context.shouldDispose && !force)\n                return;\n            context.disposableObjects.forEach((mounted, object) => {\n                if (mounted === 0 || force) {\n                    object?.dispose?.();\n                    context.disposableObjects.delete(object);\n                }\n            });\n            context.shouldDispose = false;\n        }\n    };\n    onDestroy(() => {\n        context.dispose(true);\n    });\n    setContext('threlte-disposal-context', context);\n    return context;\n};\nexport const useDisposal = () => {\n    const context = getContext('threlte-disposal-context');\n    if (!context) {\n        throw new Error('useDisposal can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { currentWritable } from '../../utilities/index.js';\nconst parentContextKey = Symbol('threlte-parent-context');\n/**\n * The parent context is used to access the parent object created by a `<T>`\n * component.\n */\nexport const createParentContext = (parent) => {\n    const ctx = currentWritable(parent);\n    setContext(parentContextKey, ctx);\n    return ctx;\n};\n/**\n * The parent context is used to access the parent object created by a `<T>`\n * component.\n *\n * @example\n * ```svelte\n * <T.Mesh>\n *   <CustomComponent />\n * </T.Mesh>\n * ```\n *\n * The parent as retrieved inside the component `<CustomComponent>`\n * will be the mesh created by the `<T.Mesh>` component.\n */\nexport const useParent = () => {\n    const parent = getContext(parentContextKey);\n    return parent;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { derived, readable, writable } from 'svelte/store';\nconst parentObject3DContextKey = Symbol('threlte-parent-object3d-context');\nexport const createRootParentObject3DContext = (object) => {\n    const ctx = readable(object);\n    setContext(parentObject3DContextKey, ctx);\n    return ctx;\n};\n/**\n * The parentObject3D context is used to access the parent `THREE.Object3D`\n * created by a `<T>` component. The context is automatically merged with the\n * parentObject3D context of the parent component when the local context store\n * is `undefined`.\n */\nexport const createParentObject3DContext = (object) => {\n    const parentObject3D = getContext(parentObject3DContextKey);\n    const object3D = writable(object);\n    const ctx = derived([object3D, parentObject3D], ([object3D, parentObject3D]) => {\n        return object3D ?? parentObject3D;\n    });\n    setContext(parentObject3DContextKey, ctx);\n    return object3D;\n};\n/**\n * The parentObject3D context is used to access the parent `THREE.Object3D`\n * created by a `<T>` component.\n *\n * @example\n * ```svelte\n * <T.Mesh>\n *   <T.MeshStandardMaterial>\n *     <CustomComponent />\n *   </T.MeshStandardMaterial>\n * </T.Mesh>\n * ```\n *\n * The parentObject3D as retrieved inside the component `<CustomComponent>`\n * will be the mesh created by the `<T.Mesh>` component.\n */\nexport const useParentObject3D = () => {\n    return getContext(parentObject3DContextKey);\n};\n", "import { getContext, onDestroy, setContext } from 'svelte';\nimport { AgXToneMapping, ColorManagement, PCFSoftShadowMap, WebGLRenderer } from 'three';\nimport { useTask } from '../../hooks/useTask.js';\nimport { currentWritable, watch } from '../../utilities/index.js';\nimport { useCamera } from './camera.js';\nimport { useDisposal } from './disposal.js';\nimport { useDOM } from './dom.js';\nimport { useScene } from './scene.js';\nimport { useScheduler } from './scheduler.svelte.js';\nexport const createRendererContext = (options) => {\n    const { dispose } = useDisposal();\n    const { camera } = useCamera();\n    const { scene } = useScene();\n    const { invalidate, renderStage, autoRender, scheduler, resetFrameInvalidation } = useScheduler();\n    const { size, canvas } = useDOM();\n    const renderer = options.createRenderer\n        ? options.createRenderer(canvas)\n        : new WebGLRenderer({\n            canvas,\n            powerPreference: 'high-performance',\n            antialias: true,\n            alpha: true\n        });\n    const autoRenderTask = renderStage.createTask(Symbol('threlte-auto-render-task'), () => {\n        renderer.render(scene, camera.current);\n    });\n    const context = {\n        renderer: renderer,\n        colorManagementEnabled: currentWritable(options.colorManagementEnabled ?? true),\n        colorSpace: currentWritable(options.colorSpace ?? 'srgb'),\n        dpr: currentWritable(options.dpr ?? window.devicePixelRatio),\n        shadows: currentWritable(options.shadows ?? PCFSoftShadowMap),\n        toneMapping: currentWritable(options.toneMapping ?? AgXToneMapping),\n        autoRenderTask\n    };\n    setContext('threlte-renderer-context', context);\n    watch([context.colorManagementEnabled], ([colorManagementEnabled]) => {\n        ColorManagement.enabled = colorManagementEnabled;\n    });\n    watch([context.colorSpace], ([colorSpace]) => {\n        if ('outputColorSpace' in renderer) {\n            renderer.outputColorSpace = colorSpace;\n        }\n    });\n    watch([context.dpr], ([dpr]) => {\n        if ('setPixelRatio' in renderer) {\n            renderer.setPixelRatio(dpr);\n        }\n    });\n    // Resize the renderer when the size changes\n    const { start, stop } = useTask(() => {\n        if (!('xr' in renderer) || renderer.xr?.isPresenting)\n            return;\n        renderer.setSize(size.current.width, size.current.height);\n        invalidate();\n        stop();\n    }, {\n        before: autoRenderTask,\n        autoStart: false,\n        autoInvalidate: false\n    });\n    watch([size], () => {\n        start();\n    });\n    watch([context.shadows], ([shadows]) => {\n        if (!('shadowMap' in renderer))\n            return;\n        renderer.shadowMap.enabled = !!shadows;\n        if (shadows && shadows !== true) {\n            renderer.shadowMap.type = shadows;\n        }\n        else if (shadows === true) {\n            renderer.shadowMap.type = PCFSoftShadowMap;\n        }\n    });\n    watch([context.toneMapping], ([toneMapping]) => {\n        if (!('toneMapping' in renderer))\n            return;\n        renderer.toneMapping = toneMapping;\n    });\n    watch([autoRender], ([autoRender]) => {\n        if (autoRender) {\n            context.autoRenderTask.start();\n        }\n        else {\n            context.autoRenderTask.stop();\n        }\n        return () => {\n            context.autoRenderTask.stop();\n        };\n    });\n    if ('setAnimationLoop' in context.renderer) {\n        const renderer = context.renderer;\n        renderer.setAnimationLoop((time) => {\n            dispose();\n            scheduler.run(time);\n            resetFrameInvalidation();\n        });\n    }\n    onDestroy(() => {\n        if ('dispose' in context.renderer) {\n            const dispose = context.renderer.dispose;\n            dispose();\n        }\n    });\n    $effect.pre(() => {\n        context.colorManagementEnabled.set(options.colorManagementEnabled ?? true);\n    });\n    $effect.pre(() => {\n        context.colorSpace.set(options.colorSpace ?? 'srgb');\n    });\n    $effect.pre(() => {\n        context.toneMapping.set(options.toneMapping ?? AgXToneMapping);\n    });\n    $effect.pre(() => {\n        context.shadows.set(options.shadows ?? PCFSoftShadowMap);\n    });\n    $effect.pre(() => {\n        context.dpr.set(options.dpr ?? window.devicePixelRatio);\n    });\n    return context;\n};\nexport const useRenderer = () => {\n    const context = getContext('threlte-renderer-context');\n    if (!context) {\n        throw new Error('useRenderer can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { onDestroy } from 'svelte';\nimport { readable, writable } from 'svelte/store';\nimport { useScheduler } from '../context/fragments/scheduler.svelte.js';\nimport { DAG } from '../frame-scheduling/index.js';\nimport { browser } from '../utilities/index.js';\nexport function useTask(keyOrFn, fnOrOptions, options) {\n    if (!browser) {\n        return {\n            task: undefined,\n            start: () => undefined,\n            stop: () => undefined,\n            started: readable(false)\n        };\n    }\n    let key;\n    let fn;\n    let opts;\n    if (DAG.isKey(keyOrFn)) {\n        key = keyOrFn;\n        fn = fnOrOptions;\n        opts = options;\n    }\n    else {\n        key = Symbol('useTask');\n        fn = keyOrFn;\n        opts = fnOrOptions;\n    }\n    const schedulerCtx = useScheduler();\n    let stage = schedulerCtx.mainStage;\n    if (opts) {\n        if (opts.stage) {\n            if (DAG.isValue(opts.stage)) {\n                stage = opts.stage;\n            }\n            else {\n                const maybeStage = schedulerCtx.scheduler.getStage(opts.stage);\n                if (!maybeStage) {\n                    throw new Error(`No stage found with key ${opts.stage.toString()}`);\n                }\n                stage = maybeStage;\n            }\n        }\n        else if (opts.after) {\n            if (Array.isArray(opts.after)) {\n                for (let index = 0; index < opts.after.length; index++) {\n                    const element = opts.after[index];\n                    if (DAG.isValue(element)) {\n                        stage = element.stage;\n                        break;\n                    }\n                }\n            }\n            else if (DAG.isValue(opts.after)) {\n                stage = opts.after.stage;\n            }\n        }\n        else if (opts.before) {\n            if (Array.isArray(opts.before)) {\n                for (let index = 0; index < opts.before.length; index++) {\n                    const element = opts.before[index];\n                    if (DAG.isValue(element)) {\n                        stage = element.stage;\n                        break;\n                    }\n                }\n            }\n            else if (DAG.isValue(opts.before)) {\n                stage = opts.before.stage;\n            }\n        }\n    }\n    const started = writable(false);\n    const task = stage.createTask(key, fn, opts);\n    const start = () => {\n        started.set(true);\n        if (opts?.autoInvalidate ?? true) {\n            schedulerCtx.autoInvalidations.add(fn);\n        }\n        task.start();\n    };\n    const stop = () => {\n        started.set(false);\n        if (opts?.autoInvalidate ?? true) {\n            schedulerCtx.autoInvalidations.delete(fn);\n        }\n        task.stop();\n    };\n    if (opts?.autoStart ?? true) {\n        start();\n    }\n    else {\n        stop();\n    }\n    onDestroy(() => {\n        stop();\n        stage.removeTask(key);\n    });\n    return {\n        task,\n        start,\n        stop,\n        started: {\n            subscribe: started.subscribe\n        }\n    };\n}\n", "import { getContext, setContext } from 'svelte';\nimport { Scene } from 'three';\nexport const createSceneContext = (scene) => {\n    const context = { scene: scene || new Scene() };\n    setContext('threlte-scene-context', context);\n    return context;\n};\nexport const useScene = () => {\n    const context = getContext('threlte-scene-context');\n    if (!context) {\n        throw new Error('useScene can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { currentWritable } from '../../utilities/index.js';\nexport const createUserContext = () => {\n    const userCtx = currentWritable({});\n    setContext('threlte-user-context', userCtx);\n    return userCtx;\n};\n/**\n * ### `useUserContext`\n *\n * @returns The user context store. The context is to be used with\n * `useThrelteUserContext` to set and get the user context.\n */\nexport const useUserContext = () => {\n    const context = getContext('threlte-user-context');\n    if (!context) {\n        throw new Error('useUserContext can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { createCacheContext } from './fragments/cache.js';\nimport { createCameraContext } from './fragments/camera.js';\nimport { createDisposalContext } from './fragments/disposal.js';\nimport { createDOMContext } from './fragments/dom.js';\nimport { createParentContext } from './fragments/parent.js';\nimport { createRootParentObject3DContext } from './fragments/parentObject3D.js';\nimport { createRendererContext } from './fragments/renderer.svelte.js';\nimport { createSceneContext } from './fragments/scene.js';\nimport { createSchedulerContext } from './fragments/scheduler.svelte.js';\nimport { createUserContext } from './fragments/user.js';\nexport const createThrelteContext = (options) => {\n    const { scene } = createSceneContext();\n    return {\n        scene,\n        ...createDOMContext(options),\n        ...createCacheContext(),\n        ...createParentContext(scene),\n        ...createRootParentObject3DContext(scene),\n        ...createDisposalContext(),\n        ...createSchedulerContext(options),\n        ...createCameraContext(),\n        ...createRendererContext(options),\n        ...createUserContext()\n    };\n};\n", "<script lang=\"ts\">\n  import type { Snippet } from 'svelte'\n  import {\n    createThrelteContext,\n    type CreateThrelteContextOptions\n  } from '../../context/createThrelteContext.svelte.js'\n  import type { Renderer } from '../../context/fragments/renderer.svelte.js'\n\n  let { children, ...rest }: CreateThrelteContextOptions<Renderer> & { children: Snippet } =\n    $props()\n\n  createThrelteContext(rest)\n</script>\n\n{@render children()}\n", "<script lang=\"ts\">\n  import type { Snippet } from 'svelte'\n  import Context from './components/Context/Context.svelte'\n  import type { CreateThrelteContextOptions } from './context/createThrelteContext.svelte.js'\n  import type { Renderer } from './context/fragments/renderer.svelte.js'\n\n  type Props = Omit<CreateThrelteContextOptions<Renderer>, 'canvas' | 'dom'> & {\n    children?: Snippet\n  }\n\n  let { children, ...rest }: Props = $props()\n\n  let canvas = $state<HTMLCanvasElement>()\n  let dom = $state<HTMLDivElement>()\n</script>\n\n<div bind:this={dom}>\n  <canvas bind:this={canvas}>\n    {#if canvas && dom}\n      <Context\n        {dom}\n        {canvas}\n        {...rest}\n      >\n        {@render children?.()}\n      </Context>\n    {/if}\n  </canvas>\n</div>\n\n<style>\n  div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n  canvas {\n    display: block;\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n</style>\n", "/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport * as THREE from 'three';\nimport TComp from './T.svelte';\nimport { setIs } from './utils/useIs.js';\nconst catalogue = {};\n/**\n * Extends the default THREE namespace and allows using custom Three.js objects with `<T>`.\n *\n * @example\n * ```svelte\n * <script>\n * \timport { extend, T } from 'threlte'\n * \timport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n *\n * \textend({ OrbitControls })\n * </script>\n *\n * <T.OrbitControls />\n * ```\n */\nexport const extend = (extensions) => {\n    Object.assign(catalogue, extensions);\n};\n/**\n * ## `<T>`\n *\n * Threlte's `<T>` component is a wrapper around Three.js objects. It is a generic component that can be used to create any Three.js object.\n *\n * @example\n *\n * ```svelte\n * <script>\n * \timport { T } from 'threlte'\n * </script>\n *\n * <T.PerspectiveCamera makeDefault />\n *\n * <T.Mesh>\n * \t<T.BoxGeometry />\n * \t<T.MeshBasicMaterial color=\"red\" />\n * </T.Mesh>\n * ```\n */\nexport const T = new Proxy(TComp, {\n    get(_target, is) {\n        // Handle snippets\n        if (typeof is !== 'string') {\n            return TComp;\n        }\n        const module = catalogue[is] || THREE[is];\n        if (module === undefined) {\n            throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);\n        }\n        setIs(module);\n        return TComp;\n    }\n});\n", "import { Scene } from 'three';\nimport { useCamera } from '../fragments/camera.js';\nimport { useDOM } from '../fragments/dom.js';\nimport { useRenderer } from '../fragments/renderer.svelte.js';\nimport { useScene } from '../fragments/scene.js';\nimport { useScheduler } from '../fragments/scheduler.svelte.js';\n/**\n * ### `useThrelte`\n *\n * This hook provides access to the main context of a Threlte application.\n *\n * ```svelte\n * <script>\n *   import { useThrelte } from 'threlte'\n *   const { camera } = useThrelte()\n *\n *   // Access the camera\n *   console.log(camera.current) // => PerspectiveCamera {  }\n * </script>\n * ```\n */\nexport const useThrelte = () => {\n    const schedulerCtx = useScheduler();\n    const rendererCtx = useRenderer();\n    const cameraCtx = useCamera();\n    const sceneCtx = useScene();\n    const domCtx = useDOM();\n    const context = {\n        advance: schedulerCtx.advance,\n        autoRender: schedulerCtx.autoRender,\n        autoRenderTask: rendererCtx.autoRenderTask,\n        camera: cameraCtx.camera,\n        colorManagementEnabled: rendererCtx.colorManagementEnabled,\n        colorSpace: rendererCtx.colorSpace,\n        dpr: rendererCtx.dpr,\n        invalidate: schedulerCtx.invalidate,\n        mainStage: schedulerCtx.mainStage,\n        renderer: rendererCtx.renderer,\n        renderMode: schedulerCtx.renderMode,\n        renderStage: schedulerCtx.renderStage,\n        scheduler: schedulerCtx.scheduler,\n        shadows: rendererCtx.shadows,\n        shouldRender: schedulerCtx.shouldRender,\n        dom: domCtx.dom,\n        canvas: domCtx.canvas,\n        size: domCtx.size,\n        toneMapping: rendererCtx.toneMapping,\n        get scene() {\n            return sceneCtx.scene;\n        },\n        set scene(scene) {\n            sceneCtx.scene = scene;\n        }\n    };\n    return context;\n};\n", "import { fromStore } from 'svelte/store';\nimport { useThrelte } from '../../../context/compounds/useThrelte.js';\nimport { createParentContext, useParent } from '../../../context/fragments/parent.js';\nimport { createParentObject3DContext, useParentObject3D } from '../../../context/fragments/parentObject3D.js';\nimport { isInstanceOf, resolvePropertyPath } from '../../../utilities/index.js';\nconst isObject = (ref) => {\n    return typeof ref === 'object' && ref !== null;\n};\nexport const useAttach = (getRef, getAttach) => {\n    const { invalidate } = useThrelte();\n    const ref = $derived(getRef());\n    const attach = $derived(getAttach());\n    const parent = fromStore(useParent());\n    const parentObject3D = fromStore(useParentObject3D());\n    const currentRef = createParentContext();\n    const object3D = createParentObject3DContext();\n    $effect.pre(() => {\n        currentRef.set(ref);\n        if (isInstanceOf(ref, 'Object3D')) {\n            object3D.set(ref);\n        }\n        invalidate();\n    });\n    $effect.pre(() => {\n        invalidate();\n        // Save the current ref in case it is destroyed / changed\n        const current = ref;\n        // Most common: auto-attach to parent Object3D\n        if (attach === undefined && isInstanceOf(current, 'Object3D')) {\n            parentObject3D.current?.add(current);\n            return () => {\n                invalidate();\n                parentObject3D.current?.remove(current);\n            };\n        }\n        // Auto-attach to parent material or geometry\n        if (attach === undefined && isObject(parent.current)) {\n            const p = parent.current;\n            if (isInstanceOf(current, 'Material')) {\n                const originalMaterial = p.material;\n                p.material = current;\n                return () => {\n                    invalidate();\n                    p.material = originalMaterial;\n                };\n            }\n            else if (isInstanceOf(current, 'BufferGeometry')) {\n                const originalGeometry = p.geometry;\n                p.geometry = current;\n                return () => {\n                    invalidate();\n                    p.geometry = originalGeometry;\n                };\n            }\n        }\n        // Explicitly do not attach\n        if (attach === false) {\n            return () => {\n                invalidate();\n            };\n        }\n        // Custom attach function\n        if (typeof attach === 'function') {\n            const cleanup = attach({\n                ref: current,\n                parent: parent.current,\n                parentObject3D: parentObject3D.current\n            });\n            return () => {\n                invalidate();\n                cleanup?.();\n            };\n        }\n        // Attach to parent prop\n        if (typeof attach === 'string') {\n            const { target, key } = resolvePropertyPath(parent.current, attach);\n            if (key in target) {\n                // If the key is already in the target, we need to save\n                // the value before attaching \n                const valueBeforeAttach = target[key];\n                target[key] = current;\n                return () => {\n                    invalidate();\n                    //  and restore it when the component unmounts\n                    target[key] = valueBeforeAttach;\n                };\n            }\n            else {\n                // If the key is not in the target, we need to add it \n                target[key] = current;\n                return () => {\n                    invalidate();\n                    //  and delete it when the component unmounts\n                    delete target[key];\n                };\n            }\n        }\n        // Attach to parent Object3D\n        if (isInstanceOf(attach, 'Object3D') && isInstanceOf(current, 'Object3D')) {\n            attach.add(current);\n            return () => {\n                invalidate();\n                attach.remove(current);\n            };\n        }\n        return;\n    });\n};\n", "import { fromStore } from 'svelte/store';\nimport { useThrelte } from '../../../context/compounds/useThrelte.js';\nimport { isInstanceOf } from '../../../utilities/index.js';\nconst defaultCameras = new Set();\nexport const useCamera = (getCamera, getManual, getMakeDefault) => {\n    const { invalidate, size: sizeStore, camera: defaultCamera } = useThrelte();\n    const camera = $derived(getCamera());\n    const size = fromStore(sizeStore);\n    $effect.pre(() => {\n        if (!getMakeDefault()) {\n            return;\n        }\n        const current = camera;\n        defaultCameras.add(current);\n        defaultCamera.set(current);\n        invalidate();\n        return () => {\n            defaultCameras.delete(current);\n            if (defaultCameras.size === 0) {\n                defaultCamera.set(undefined);\n                invalidate();\n            }\n        };\n    });\n    $effect.pre(() => {\n        if (getManual()) {\n            return;\n        }\n        const { width, height } = size.current;\n        if (isInstanceOf(camera, 'PerspectiveCamera')) {\n            camera.aspect = width / height;\n        }\n        else if (isInstanceOf(camera, 'OrthographicCamera')) {\n            camera.left = width / -2;\n            camera.right = width / 2;\n            camera.top = height / 2;\n            camera.bottom = height / -2;\n        }\n        camera.updateProjectionMatrix();\n        camera.updateMatrixWorld();\n        invalidate();\n    });\n};\n", "import { getContext, setContext } from 'svelte';\nimport { useDisposal } from '../../../context/fragments/disposal.js';\nconst contextName = Symbol('threlte-disposable-object-context');\n/**\n * Checks if the given object is a disposable object. Scenes are not disposable.\n * @param object - The object to check.\n * @returns True if the object is a disposable object, false otherwise.\n */\nexport const isDisposableObject = (object) => {\n    return typeof object?.dispose === 'function';\n};\nexport const useSetDispose = (getDispose) => {\n    const parentDispose = getContext(contextName);\n    // We merge the local dispose with the parent dispose. If the parent dispose\n    // is not set, we use true as default.\n    const mergedDispose = $derived(getDispose() ?? parentDispose?.() ?? true);\n    setContext(contextName, () => mergedDispose);\n};\nexport const useDispose = (getDisposable) => {\n    const disposable = $derived(getDisposable());\n    const { disposableObjectMounted, disposableObjectUnmounted, removeObjectFromDisposal } = useDisposal();\n    const parentDispose = getContext(contextName);\n    // We merge the local dispose with the parent dispose. If the parent dispose\n    // is not set, we use true as default.\n    const dispose = $derived(parentDispose?.() ?? true);\n    $effect(() => {\n        if (dispose) {\n            disposableObjectMounted(disposable);\n            return () => disposableObjectUnmounted(disposable);\n        }\n        removeObjectFromDisposal(disposable);\n        return;\n    });\n};\n", "/**\n * Typeguard to check if a value is extending THREE.EventDispatcher\n * @param value\n * @returns\n */\nconst isEventDispatcher = (value) => {\n    return (value !== null &&\n        typeof value === 'object' &&\n        'addEventListener' in value &&\n        'removeEventListener' in value);\n};\nexport const useEvents = (getRef, propKeys, props) => {\n    const ref = $derived(getRef());\n    for (const key of propKeys) {\n        const prop = $derived(props[key]);\n        // Don't create the effect unless the prop begins with \"on\"\n        if (key.startsWith('on')) {\n            $effect.pre(() => {\n                if (typeof prop !== 'function' || !isEventDispatcher(ref)) {\n                    return;\n                }\n                const name = key.slice(2);\n                ref.addEventListener(name, prop);\n                return () => ref.removeEventListener(name, prop);\n            });\n        }\n    }\n};\n", "let currentIs;\nexport const setIs = (is) => {\n    currentIs = is;\n};\nexport const useIs = () => {\n    const is = currentIs;\n    currentIs = undefined;\n    return is;\n};\n", "export const pluginContextKey = 'threlte-plugin-context';\n", "import { getContext } from 'svelte';\nimport { pluginContextKey } from '../../../plugins/types.js';\nexport const usePlugins = (args) => {\n    const plugins = getContext(pluginContextKey);\n    if (!plugins)\n        return;\n    const pluginsProps = [];\n    const pluginsArray = Object.values(plugins);\n    if (pluginsArray.length > 0) {\n        const pluginArgs = args();\n        // initalize plugins\n        for (let i = 0; i < pluginsArray.length; i++) {\n            const plugin = pluginsArray[i];\n            // initialize plugin\n            const p = plugin(pluginArgs);\n            if (p && p.pluginProps) {\n                pluginsProps.push(...p.pluginProps);\n            }\n        }\n    }\n    return {\n        pluginsProps\n    };\n};\n", "import { useThrelte } from '../../../context/compounds/useThrelte.js';\nimport { resolvePropertyPath } from '../../../utilities/index.js';\nconst ignoredProps = new Set(['$$scope', '$$slots', 'type', 'args', 'attach', 'instance']);\nconst updateProjectionMatrixKeys = new Set([\n    'fov',\n    'aspect',\n    'near',\n    'far',\n    'left',\n    'right',\n    'top',\n    'bottom',\n    'zoom'\n]);\n/**\n * Only scalar values are memoized, objects and arrays are considered\n * non-equa by default, to ensure reactivity works as you would\n * expect in svelte.\n * @param value\n * @returns\n */\nexport const memoizeProp = (value) => {\n    // scalar values are memoized\n    if (typeof value === 'string')\n        return true;\n    if (typeof value === 'number')\n        return true;\n    if (typeof value === 'boolean')\n        return true;\n    if (typeof value === 'undefined')\n        return true;\n    if (value === null)\n        return true;\n    // objects and arrays cannot be reliably memoized\n    return false;\n};\nconst createSetter = (target, key, value) => {\n    if (!Array.isArray(value) &&\n        typeof value === 'number' &&\n        typeof target[key] === 'object' &&\n        target[key] !== null &&\n        typeof target[key]?.setScalar === 'function' &&\n        // colors do have a setScalar function, but we don't want to use it, because\n        // the hex notation (i.e. 0xff0000) is very popular and matches the number\n        // type. So we exclude colors here.\n        !target[key]?.isColor) {\n        // edge case of setScalar setters\n        return (target, key, value) => {\n            target[key].setScalar(value);\n        };\n    }\n    else {\n        if (typeof target[key]?.set === 'function' &&\n            typeof target[key] === 'object' &&\n            target[key] !== null) {\n            // if the property has a \"set\" function, we can use it\n            if (Array.isArray(value)) {\n                return (target, key, value) => {\n                    target[key].set(...value);\n                };\n            }\n            else {\n                return (target, key, value) => {\n                    target[key].set(value);\n                };\n            }\n        }\n        else {\n            // otherwise, we just set the value\n            return (target, key, value) => {\n                target[key] = value;\n            };\n        }\n    }\n};\nexport const useProps = () => {\n    const { invalidate } = useThrelte();\n    const memoizedProps = new Map();\n    const memoizedSetters = new Map();\n    const setProp = (instance, propertyPath, value, manualCamera) => {\n        if (memoizeProp(value)) {\n            const memoizedProp = memoizedProps.get(propertyPath);\n            if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {\n                return;\n            }\n            memoizedProps.set(propertyPath, {\n                instance,\n                value\n            });\n        }\n        const { key, target } = resolvePropertyPath(instance, propertyPath);\n        if (value !== undefined && value !== null) {\n            const memoizedSetter = memoizedSetters.get(propertyPath);\n            if (memoizedSetter) {\n                memoizedSetter(target, key, value);\n            }\n            else {\n                const setter = createSetter(target, key, value);\n                memoizedSetters.set(propertyPath, setter);\n                setter(target, key, value);\n            }\n        }\n        else {\n            createSetter(target, key, value)(target, key, value);\n        }\n        if (manualCamera)\n            return;\n        if (updateProjectionMatrixKeys.has(key) &&\n            (target.isPerspectiveCamera || target.isOrthographicCamera)) {\n            target.updateProjectionMatrix();\n        }\n    };\n    const updateProp = (instance, key, value, pluginsProps, manualCamera) => {\n        if (!ignoredProps.has(key) && !pluginsProps?.includes(key)) {\n            setProp(instance, key, value, manualCamera);\n        }\n        invalidate();\n    };\n    return {\n        updateProp\n    };\n};\n", "/**\n * Short cicruits if the input is not a function, then calls toString on Function with guaranteed safe behavior\n */\nconst isClass = (input) => {\n    return typeof input === 'function' && Function.prototype.toString.call(input).startsWith('class ');\n};\nexport const determineRef = (is, args) => {\n    if (isClass(is)) {\n        if (Array.isArray(args)) {\n            return new is(...args);\n        }\n        else {\n            return new is();\n        }\n    }\n    return is;\n};\n", "<script\n  lang=\"ts\"\n  generics=\"Type\"\n>\n  import type { TProps } from './types.js'\n  import { useAttach } from './utils/useAttach.svelte.js'\n  import { useCamera } from './utils/useCamera.svelte.js'\n  import { isDisposableObject, useDispose, useSetDispose } from './utils/useDispose.svelte.js'\n  import { useEvents } from './utils/useEvents.svelte.js'\n  import { useIs } from './utils/useIs.js'\n  import { usePlugins } from './utils/usePlugins.js'\n  import { useProps } from './utils/useProps.js'\n  import { determineRef } from './utils/utils.js'\n  import { isInstanceOf } from '../../utilities/index.js'\n  import { untrack } from 'svelte'\n\n  let {\n    is = useIs<Type>(),\n    args,\n    attach,\n    manual = false,\n    makeDefault = false,\n    dispose,\n    ref = $bindable(),\n    oncreate,\n    children,\n    ...props\n  }: TProps<Type> = $props()\n\n  /**\n   * When \"is\" or \"args\" change, we need to create a new ref.\n   */\n  const internalRef = $derived(determineRef<Type>(is, args))\n  $effect.pre(() => {\n    if (ref === internalRef) return\n    ref = internalRef\n  })\n\n  // Plugins are initialized here so that pluginsProps\n  // is available in the props update\n  const plugins = usePlugins(() => ({\n    get ref() {\n      return internalRef\n    },\n    get args() {\n      return args\n    },\n    get attach() {\n      return attach\n    },\n    get manual() {\n      return manual\n    },\n    get makeDefault() {\n      return makeDefault\n    },\n    get dispose() {\n      return dispose\n    },\n    get props() {\n      return props\n    }\n  }))\n\n  // Props\n  const propKeys = Object.keys(props)\n  const { updateProp } = useProps()\n  propKeys.forEach((key) => {\n    const prop = $derived(props[key])\n    $effect.pre(() => {\n      updateProp(internalRef, key, prop, plugins?.pluginsProps, manual)\n    })\n  })\n\n  // Attachment\n  useAttach<Type>(\n    () => internalRef,\n    () => attach\n  )\n\n  // Camera management\n  $effect.pre(() => {\n    if (\n      isInstanceOf(internalRef, 'PerspectiveCamera') ||\n      isInstanceOf(internalRef, 'OrthographicCamera')\n    ) {\n      useCamera(\n        () => internalRef,\n        () => manual,\n        () => makeDefault\n      )\n    }\n  })\n\n  // Disposal\n  useSetDispose(() => dispose)\n\n  $effect.pre(() => {\n    if (isDisposableObject(internalRef)) {\n      useDispose(() => internalRef)\n    }\n  })\n\n  // Events\n  useEvents(() => internalRef, propKeys, props)\n\n  /**\n   * oncreate needs to be called after all other hooks\n   * so that props will have been set once ref is passed\n   * to this callback\n   */\n  $effect(() => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    internalRef\n    let cleanup: void | (() => void) = undefined\n    untrack(() => {\n      cleanup = oncreate?.(internalRef)\n    })\n    return cleanup\n  })\n</script>\n\n{@render children?.({ ref: internalRef })}\n", "import { getContext, setContext } from 'svelte';\nimport { pluginContextKey } from './types.js';\nexport function injectPlugin(name, plugin) {\n    if (!plugin)\n        return;\n    setContext(pluginContextKey, {\n        ...getContext(pluginContextKey),\n        [name]: plugin\n    });\n}\n", "import { useThrelte } from '../context/compounds/useThrelte.js';\n/**\n * Creates a stage and returns it. If the stage already exists, it is returned.\n *\n * @param key The key of the stage.\n * @param options Options for creating the stage.\n */\nexport function useStage(key, options) {\n    const { scheduler } = useThrelte();\n    return scheduler.getStage(key) ?? scheduler.createStage(key, options);\n}\n", "import { derived } from 'svelte/store';\nimport { useUserContext } from '../context/fragments/user.js';\nexport function useThrelteUserContext(namespace, value, options) {\n    const userCtxStore = useUserContext();\n    if (!userCtxStore) {\n        throw new Error('No user context store found, did you invoke this function outside of your main <Canvas> component?');\n    }\n    // return the plain user context store\n    if (!namespace) {\n        return {\n            subscribe: userCtxStore.subscribe\n        };\n    }\n    // return a specific user context entry\n    if (namespace && !value) {\n        return derived(userCtxStore, (ctx) => ctx[namespace]);\n    }\n    // we are possibly setting a new user context entry here\n    userCtxStore.update((ctx) => {\n        if (namespace in ctx) {\n            // skip is the default value\n            if (!options || options.existing === 'skip')\n                return ctx;\n            if (options.existing === 'merge') {\n                const v = typeof value === 'function' ? value() : value;\n                Object.assign(ctx[namespace], v);\n                return ctx;\n            }\n        }\n        // also handles options.existing === 'replace'\n        const v = typeof value === 'function' ? value() : value;\n        ctx[namespace] = v;\n        return ctx;\n    });\n    return userCtxStore.current[namespace];\n}\n", "import { useCache } from '../context/fragments/cache.js';\nimport { asyncWritable } from '../utilities/index.js';\nexport function useLoader(Proto, options) {\n    const { remember, clear: clearCacheItem } = useCache();\n    let loader;\n    const initializeLoader = () => {\n        // Type-wrestling galore\n        const lazyLoader = new Proto(...(options?.args ?? []));\n        // extend the loader if necessary\n        options?.extend?.(lazyLoader);\n        return lazyLoader;\n    };\n    const load = (input, options) => {\n        // Allow Async and Sync loaders\n        const loadResource = async (url) => {\n            if (!loader) {\n                loader = initializeLoader();\n            }\n            if ('loadAsync' in loader) {\n                const result = await loader.loadAsync(url, options?.onProgress);\n                return options?.transform?.(result) ?? result;\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    ;\n                    loader.load(url, (data) => resolve(options?.transform?.(data) ?? data), (event) => options?.onProgress?.(event), reject);\n                });\n            }\n        };\n        if (Array.isArray(input)) {\n            // map over the input array and return an array of promises\n            const promises = input.map((url) => {\n                return remember(() => loadResource(url), [Proto, url]);\n            });\n            // return an AsyncWritable that resolves to the array of promises\n            const store = asyncWritable(Promise.all(promises));\n            return store; // TODO: Dirty escape hatch\n        }\n        else if (typeof input === 'string') {\n            const promise = remember(() => loadResource(input), [Proto, input]);\n            // return an AsyncWritable that resolves to the promise\n            const store = asyncWritable(promise);\n            return store; // TODO: Dirty escape hatch\n        }\n        else {\n            // map over the input object and return an array of promises\n            const promises = Object.values(input).map((url) => {\n                return remember(() => loadResource(url), [Proto, url]);\n            });\n            // return an AsyncWritable that resolves to the object of promises\n            const store = asyncWritable(Promise.all(promises).then((results) => {\n                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));\n            }));\n            return store; // TODO: Dirty escape hatch\n        }\n    };\n    const clear = (input) => {\n        if (Array.isArray(input)) {\n            input.forEach((url) => {\n                clearCacheItem([Proto, url]);\n            });\n        }\n        else if (typeof input === 'string') {\n            clearCacheItem([Proto, input]);\n        }\n        else {\n            Object.entries(input).forEach(([key, url]) => {\n                clearCacheItem([Proto, key, url]);\n            });\n        }\n    };\n    return {\n        load,\n        clear,\n        loader\n    };\n}\n// Type tests\n// class WithConstructorParameters {\n//   constructor(hello: 'abc' | 'def') {\n//     console.log(hello)\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// class WithOptionalConstructorParameters {\n//   constructor(hello?: string) {\n//     console.log(hello)\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// class WithoutConstructorParameters {\n//   constructor() {\n//     console.log('without')\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// const shouldFail = () => {\n//   useLoader(WithConstructorParameters)\n//   useLoader(WithoutConstructorParameters, {\n//     args: ['hello']\n//   })\n// }\n// const shouldSucceed = () => {\n//   useLoader(WithConstructorParameters, {\n//     args: ['abc']\n//   })\n//   useLoader(WithConstructorParameters, {\n//     args: ['abc'],\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters)\n//   useLoader(WithOptionalConstructorParameters, {\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: [],\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: ['hello'],\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: ['hello']\n//   })\n//   useLoader(WithoutConstructorParameters)\n//   useLoader(WithoutConstructorParameters, {\n//     extend(loader) {\n//       // \n//     }\n//   })\n// }\n", "export const VERSION = 8;\n// canvas component\nexport { default as Canvas } from './Canvas.svelte';\n// components (v6)\nexport { T, extend } from './components/T/T.js';\n// plugins\nexport { injectPlugin } from './plugins/injectPlugin.js';\n// hooks\nexport { useThrelte } from './context/compounds/useThrelte.js';\nexport { useStage } from './hooks/useStage.js';\nexport { useTask } from './hooks/useTask.js';\nexport { useThrelteUserContext } from './hooks/useThrelteUserContext.js';\n// useLoader\nexport { useLoader } from './hooks/useLoader.js';\nexport { createThrelteContext } from './context/createThrelteContext.svelte.js';\nexport { createCacheContext, useCache } from './context/fragments/cache.js';\nexport { createCameraContext, useCamera } from './context/fragments/camera.js';\nexport { createDOMContext, useDOM } from './context/fragments/dom.js';\nexport { createDisposalContext, useDisposal } from './context/fragments/disposal.js';\nexport { createParentContext, useParent } from './context/fragments/parent.js';\nexport { createParentObject3DContext, useParentObject3D } from './context/fragments/parentObject3D.js';\nexport { createRendererContext, useRenderer } from './context/fragments/renderer.svelte.js';\nexport { createSceneContext, useScene } from './context/fragments/scene.js';\nexport { createSchedulerContext, useScheduler } from './context/fragments/scheduler.svelte.js';\nexport { createUserContext } from './context/fragments/user.js';\n// utils\nexport * from './utilities/index.js';\n"],
  "mappings": "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",
  "names": ["entry", "value", "all", "Map", "on", "type", "handler", "handlers", "get", "push", "set", "off", "splice", "indexOf", "emit", "evt", "slice", "map", "start", "size", "object3D", "parentObject3D", "autoRender", "renderer", "dispose", "Scene", "useCamera", "prop", "target", "key", "value", "prop", "useCamera", "T", "v", "options"]
}
