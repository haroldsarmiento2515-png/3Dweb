import {
  T,
  asyncWritable,
  createCacheContext,
  createCameraContext,
  createDOMContext,
  createParentContext,
  createParentObject3DContext,
  createSceneContext,
  createUserContext,
  currentWritable,
  injectPlugin,
  isInstanceOf,
  observe,
  useCache,
  useDOM,
  useLoader,
  useParent,
  useParentObject3D,
  useStage,
  useTask,
  useThrelte,
  useThrelteUserContext,
  watch
} from "./chunk-P6GNDLNW.js";
import {
  SvelteMap,
  SvelteSet
} from "./chunk-6GJST76C.js";
import "./chunk-TYRQSTJM.js";
import "./chunk-7RQDXF5S.js";
import {
  fromStore
} from "./chunk-3BOHHH7U.js";
import {
  STYLE,
  action,
  add_locations,
  assign,
  attribute_effect,
  bind_this,
  check_target,
  clsx,
  component,
  create_ownership_validator,
  derived,
  each,
  element,
  get as get2,
  hmr,
  if_block,
  legacy_api,
  log_if_contains_state,
  onDestroy,
  onMount,
  prop,
  readable,
  rest_props,
  set_class,
  set_style,
  setup_stores,
  snippet,
  spread_props,
  store_get,
  transition,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_store,
  validate_void_dynamic_element,
  wrap_snippet,
  writable
} from "./chunk-4FYCS6M2.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html
} from "./chunk-LAD4FKZX.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  equals,
  first_child,
  get,
  getContext,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  tag,
  template_effect,
  tick,
  track_reactivity_loss,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-3MKV6OMX.js";
import "./chunk-VZQZA5WB.js";
import "./chunk-2KNEEQRV.js";
import "./chunk-OHYQYV5R.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/tweakpane/dist/tweakpane.js
var require_tweakpane = __commonJS({
  "node_modules/tweakpane/dist/tweakpane.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Tweakpane = {}));
    })(exports, (function(exports2) {
      "use strict";
      class Semver {
        /**
         * @hidden
         */
        constructor(text) {
          const [core, prerelease] = text.split("-");
          const coreComps = core.split(".");
          this.major = parseInt(coreComps[0], 10);
          this.minor = parseInt(coreComps[1], 10);
          this.patch = parseInt(coreComps[2], 10);
          this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
        }
        toString() {
          const core = [this.major, this.minor, this.patch].join(".");
          return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
        }
      }
      class BladeApi {
        constructor(controller) {
          this.controller_ = controller;
        }
        get element() {
          return this.controller_.view.element;
        }
        get disabled() {
          return this.controller_.viewProps.get("disabled");
        }
        set disabled(disabled) {
          this.controller_.viewProps.set("disabled", disabled);
        }
        get hidden() {
          return this.controller_.viewProps.get("hidden");
        }
        set hidden(hidden) {
          this.controller_.viewProps.set("hidden", hidden);
        }
        dispose() {
          this.controller_.viewProps.set("disposed", true);
        }
      }
      class TpEvent {
        constructor(target) {
          this.target = target;
        }
      }
      class TpChangeEvent extends TpEvent {
        constructor(target, value, presetKey, last) {
          super(target);
          this.value = value;
          this.presetKey = presetKey;
          this.last = last !== null && last !== void 0 ? last : true;
        }
      }
      class TpUpdateEvent extends TpEvent {
        constructor(target, value, presetKey) {
          super(target);
          this.value = value;
          this.presetKey = presetKey;
        }
      }
      class TpFoldEvent extends TpEvent {
        constructor(target, expanded) {
          super(target);
          this.expanded = expanded;
        }
      }
      class TpTabSelectEvent extends TpEvent {
        constructor(target, index) {
          super(target);
          this.index = index;
        }
      }
      function forceCast(v4) {
        return v4;
      }
      function isEmpty(value) {
        return value === null || value === void 0;
      }
      function deepEqualsArray(a1, a2) {
        if (a1.length !== a2.length) {
          return false;
        }
        for (let i = 0; i < a1.length; i++) {
          if (a1[i] !== a2[i]) {
            return false;
          }
        }
        return true;
      }
      function isPropertyWritable(obj, key2) {
        let target = obj;
        do {
          const d = Object.getOwnPropertyDescriptor(target, key2);
          if (d && (d.set !== void 0 || d.writable === true)) {
            return true;
          }
          target = Object.getPrototypeOf(target);
        } while (target !== null);
        return false;
      }
      const CREATE_MESSAGE_MAP = {
        alreadydisposed: () => "View has been already disposed",
        invalidparams: (context) => `Invalid parameters for '${context.name}'`,
        nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
        nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
        notbindable: () => `Value is not bindable`,
        propertynotfound: (context) => `Property '${context.name}' not found`,
        shouldneverhappen: () => "This error should never happen"
      };
      class TpError {
        static alreadyDisposed() {
          return new TpError({ type: "alreadydisposed" });
        }
        static notBindable() {
          return new TpError({
            type: "notbindable"
          });
        }
        static propertyNotFound(name) {
          return new TpError({
            type: "propertynotfound",
            context: {
              name
            }
          });
        }
        static shouldNeverHappen() {
          return new TpError({ type: "shouldneverhappen" });
        }
        constructor(config) {
          var _a;
          this.message = (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a !== void 0 ? _a : "Unexpected error";
          this.name = this.constructor.name;
          this.stack = new Error(this.message).stack;
          this.type = config.type;
        }
      }
      class BindingTarget {
        constructor(obj, key2, opt_id) {
          this.obj_ = obj;
          this.key_ = key2;
          this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key2;
        }
        static isBindable(obj) {
          if (obj === null) {
            return false;
          }
          if (typeof obj !== "object" && typeof obj !== "function") {
            return false;
          }
          return true;
        }
        get key() {
          return this.key_;
        }
        get presetKey() {
          return this.presetKey_;
        }
        read() {
          return this.obj_[this.key_];
        }
        write(value) {
          this.obj_[this.key_] = value;
        }
        writeProperty(name, value) {
          const valueObj = this.read();
          if (!BindingTarget.isBindable(valueObj)) {
            throw TpError.notBindable();
          }
          if (!(name in valueObj)) {
            throw TpError.propertyNotFound(name);
          }
          valueObj[name] = value;
        }
      }
      class ButtonApi extends BladeApi {
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get title() {
          var _a;
          return (_a = this.controller_.valueController.props.get("title")) !== null && _a !== void 0 ? _a : "";
        }
        set title(title) {
          this.controller_.valueController.props.set("title", title);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          const emitter = this.controller_.valueController.emitter;
          emitter.on(eventName, () => {
            bh(new TpEvent(this));
          });
          return this;
        }
      }
      class Emitter {
        constructor() {
          this.observers_ = {};
        }
        on(eventName, handler) {
          let observers = this.observers_[eventName];
          if (!observers) {
            observers = this.observers_[eventName] = [];
          }
          observers.push({
            handler
          });
          return this;
        }
        off(eventName, handler) {
          const observers = this.observers_[eventName];
          if (observers) {
            this.observers_[eventName] = observers.filter((observer) => {
              return observer.handler !== handler;
            });
          }
          return this;
        }
        emit(eventName, event) {
          const observers = this.observers_[eventName];
          if (!observers) {
            return;
          }
          observers.forEach((observer) => {
            observer.handler(event);
          });
        }
      }
      const PREFIX = "tp";
      function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
          return [
            PREFIX,
            "-",
            viewName,
            "v",
            opt_elementName ? `_${opt_elementName}` : "",
            opt_modifier ? `-${opt_modifier}` : ""
          ].join("");
        };
        return fn;
      }
      function compose(h1, h2) {
        return (input) => h2(h1(input));
      }
      function extractValue(ev) {
        return ev.rawValue;
      }
      function bindValue(value, applyValue) {
        value.emitter.on("change", compose(extractValue, applyValue));
        applyValue(value.rawValue);
      }
      function bindValueMap(valueMap, key2, applyValue) {
        bindValue(valueMap.value(key2), applyValue);
      }
      function applyClass(elem, className2, active) {
        if (active) {
          elem.classList.add(className2);
        } else {
          elem.classList.remove(className2);
        }
      }
      function valueToClassName(elem, className2) {
        return (value) => {
          applyClass(elem, className2, value);
        };
      }
      function bindValueToTextContent(value, elem) {
        bindValue(value, (text) => {
          elem.textContent = text !== null && text !== void 0 ? text : "";
        });
      }
      const className$q = ClassName("btn");
      class ButtonView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$q());
          config.viewProps.bindClassModifiers(this.element);
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$q("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$q("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
        }
      }
      class ButtonController {
        constructor(doc, config) {
          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new ButtonView(doc, {
            props: this.props,
            viewProps: this.viewProps
          });
          this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class BoundValue {
        constructor(initialValue, config) {
          var _a;
          this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
          this.equals_ = (_a = config === null || config === void 0 ? void 0 : config.equals) !== null && _a !== void 0 ? _a : ((v12, v22) => v12 === v22);
          this.emitter = new Emitter();
          this.rawValue_ = initialValue;
        }
        get constraint() {
          return this.constraint_;
        }
        get rawValue() {
          return this.rawValue_;
        }
        set rawValue(rawValue) {
          this.setRawValue(rawValue, {
            forceEmit: false,
            last: true
          });
        }
        setRawValue(rawValue, options) {
          const opts = options !== null && options !== void 0 ? options : {
            forceEmit: false,
            last: true
          };
          const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
          const prevValue = this.rawValue_;
          const changed = !this.equals_(prevValue, constrainedValue);
          if (!changed && !opts.forceEmit) {
            return;
          }
          this.emitter.emit("beforechange", {
            sender: this
          });
          this.rawValue_ = constrainedValue;
          this.emitter.emit("change", {
            options: opts,
            previousRawValue: prevValue,
            rawValue: constrainedValue,
            sender: this
          });
        }
      }
      class PrimitiveValue {
        constructor(initialValue) {
          this.emitter = new Emitter();
          this.value_ = initialValue;
        }
        get rawValue() {
          return this.value_;
        }
        set rawValue(value) {
          this.setRawValue(value, {
            forceEmit: false,
            last: true
          });
        }
        setRawValue(value, options) {
          const opts = options !== null && options !== void 0 ? options : {
            forceEmit: false,
            last: true
          };
          const prevValue = this.value_;
          if (prevValue === value && !opts.forceEmit) {
            return;
          }
          this.emitter.emit("beforechange", {
            sender: this
          });
          this.value_ = value;
          this.emitter.emit("change", {
            options: opts,
            previousRawValue: prevValue,
            rawValue: this.value_,
            sender: this
          });
        }
      }
      function createValue(initialValue, config) {
        const constraint = config === null || config === void 0 ? void 0 : config.constraint;
        const equals2 = config === null || config === void 0 ? void 0 : config.equals;
        if (!constraint && !equals2) {
          return new PrimitiveValue(initialValue);
        }
        return new BoundValue(initialValue, config);
      }
      class ValueMap {
        constructor(valueMap) {
          this.emitter = new Emitter();
          this.valMap_ = valueMap;
          for (const key2 in this.valMap_) {
            const v4 = this.valMap_[key2];
            v4.emitter.on("change", () => {
              this.emitter.emit("change", {
                key: key2,
                sender: this
              });
            });
          }
        }
        static createCore(initialValue) {
          const keys = Object.keys(initialValue);
          return keys.reduce((o, key2) => {
            return Object.assign(o, {
              [key2]: createValue(initialValue[key2])
            });
          }, {});
        }
        static fromObject(initialValue) {
          const core = this.createCore(initialValue);
          return new ValueMap(core);
        }
        get(key2) {
          return this.valMap_[key2].rawValue;
        }
        set(key2, value) {
          this.valMap_[key2].rawValue = value;
        }
        value(key2) {
          return this.valMap_[key2];
        }
      }
      function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key2) => {
          if (tmp === void 0) {
            return void 0;
          }
          const parser = keyToParserMap[key2];
          const result2 = parser(value[key2]);
          return result2.succeeded ? Object.assign(Object.assign({}, tmp), { [key2]: result2.value }) : void 0;
        }, {});
        return forceCast(result);
      }
      function parseArray(value, parseItem) {
        return value.reduce((tmp, item) => {
          if (tmp === void 0) {
            return void 0;
          }
          const result = parseItem(item);
          if (!result.succeeded || result.value === void 0) {
            return void 0;
          }
          return [...tmp, result.value];
        }, []);
      }
      function isObject(value) {
        if (value === null) {
          return false;
        }
        return typeof value === "object";
      }
      function createParamsParserBuilder(parse) {
        return (optional) => (v4) => {
          if (!optional && v4 === void 0) {
            return {
              succeeded: false,
              value: void 0
            };
          }
          if (optional && v4 === void 0) {
            return {
              succeeded: true,
              value: void 0
            };
          }
          const result = parse(v4);
          return result !== void 0 ? {
            succeeded: true,
            value: result
          } : {
            succeeded: false,
            value: void 0
          };
        };
      }
      function createParamsParserBuilders(optional) {
        return {
          custom: (parse) => createParamsParserBuilder(parse)(optional),
          boolean: createParamsParserBuilder((v4) => typeof v4 === "boolean" ? v4 : void 0)(optional),
          number: createParamsParserBuilder((v4) => typeof v4 === "number" ? v4 : void 0)(optional),
          string: createParamsParserBuilder((v4) => typeof v4 === "string" ? v4 : void 0)(optional),
          function: createParamsParserBuilder((v4) => typeof v4 === "function" ? v4 : void 0)(optional),
          constant: (value) => createParamsParserBuilder((v4) => v4 === value ? value : void 0)(optional),
          raw: createParamsParserBuilder((v4) => v4)(optional),
          object: (keyToParserMap) => createParamsParserBuilder((v4) => {
            if (!isObject(v4)) {
              return void 0;
            }
            return parseObject(v4, keyToParserMap);
          })(optional),
          array: (itemParser) => createParamsParserBuilder((v4) => {
            if (!Array.isArray(v4)) {
              return void 0;
            }
            return parseArray(v4, itemParser);
          })(optional)
        };
      }
      const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false)
      };
      function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : void 0;
      }
      function warnMissing(info) {
        console.warn([
          `Missing '${info.key}' of ${info.target} in ${info.place}.`,
          "Please rebuild plugins with the latest core package."
        ].join(" "));
      }
      function disposeElement(elem) {
        if (elem && elem.parentElement) {
          elem.parentElement.removeChild(elem);
        }
        return null;
      }
      class ReadonlyValue {
        constructor(value) {
          this.value_ = value;
        }
        static create(value) {
          return [
            new ReadonlyValue(value),
            (rawValue, options) => {
              value.setRawValue(rawValue, options);
            }
          ];
        }
        get emitter() {
          return this.value_.emitter;
        }
        get rawValue() {
          return this.value_.rawValue;
        }
      }
      const className$p = ClassName("");
      function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$p(void 0, modifier));
      }
      class ViewProps extends ValueMap {
        constructor(valueMap) {
          var _a;
          super(valueMap);
          this.onDisabledChange_ = this.onDisabledChange_.bind(this);
          this.onParentChange_ = this.onParentChange_.bind(this);
          this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this);
          [this.globalDisabled_, this.setGlobalDisabled_] = ReadonlyValue.create(createValue(this.getGlobalDisabled_()));
          this.value("disabled").emitter.on("change", this.onDisabledChange_);
          this.value("parent").emitter.on("change", this.onParentChange_);
          (_a = this.get("parent")) === null || _a === void 0 ? void 0 : _a.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
        }
        static create(opt_initialValue) {
          var _a, _b, _c;
          const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
          return new ViewProps(ValueMap.createCore({
            disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
            disposed: false,
            hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
            parent: (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null
          }));
        }
        get globalDisabled() {
          return this.globalDisabled_;
        }
        bindClassModifiers(elem) {
          bindValue(this.globalDisabled_, valueToModifier(elem, "disabled"));
          bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
        }
        bindDisabled(target) {
          bindValue(this.globalDisabled_, (disabled) => {
            target.disabled = disabled;
          });
        }
        bindTabIndex(elem) {
          bindValue(this.globalDisabled_, (disabled) => {
            elem.tabIndex = disabled ? -1 : 0;
          });
        }
        handleDispose(callback) {
          this.value("disposed").emitter.on("change", (disposed) => {
            if (disposed) {
              callback();
            }
          });
        }
        getGlobalDisabled_() {
          const parent = this.get("parent");
          const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
          return parentDisabled || this.get("disabled");
        }
        updateGlobalDisabled_() {
          this.setGlobalDisabled_(this.getGlobalDisabled_());
        }
        onDisabledChange_() {
          this.updateGlobalDisabled_();
        }
        onParentGlobalDisabledChange_() {
          this.updateGlobalDisabled_();
        }
        onParentChange_(ev) {
          var _a;
          const prevParent = ev.previousRawValue;
          prevParent === null || prevParent === void 0 ? void 0 : prevParent.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_);
          (_a = this.get("parent")) === null || _a === void 0 ? void 0 : _a.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
          this.updateGlobalDisabled_();
        }
      }
      function getAllBladePositions() {
        return ["veryfirst", "first", "last", "verylast"];
      }
      const className$o = ClassName("");
      const POS_TO_CLASS_NAME_MAP = {
        veryfirst: "vfst",
        first: "fst",
        last: "lst",
        verylast: "vlst"
      };
      class BladeController {
        constructor(config) {
          this.parent_ = null;
          this.blade = config.blade;
          this.view = config.view;
          this.viewProps = config.viewProps;
          const elem = this.view.element;
          this.blade.value("positions").emitter.on("change", () => {
            getAllBladePositions().forEach((pos) => {
              elem.classList.remove(className$o(void 0, POS_TO_CLASS_NAME_MAP[pos]));
            });
            this.blade.get("positions").forEach((pos) => {
              elem.classList.add(className$o(void 0, POS_TO_CLASS_NAME_MAP[pos]));
            });
          });
          this.viewProps.handleDispose(() => {
            disposeElement(elem);
          });
        }
        get parent() {
          return this.parent_;
        }
        set parent(parent) {
          this.parent_ = parent;
          if (!("parent" in this.viewProps.valMap_)) {
            warnMissing({
              key: "parent",
              target: ViewProps.name,
              place: "BladeController.parent"
            });
            return;
          }
          this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
        }
      }
      const SVG_NS = "http://www.w3.org/2000/svg";
      function forceReflow(element2) {
        element2.offsetHeight;
      }
      function disableTransitionTemporarily(element2, callback) {
        const t = element2.style.transition;
        element2.style.transition = "none";
        callback();
        element2.style.transition = t;
      }
      function supportsTouch(doc) {
        return doc.ontouchstart !== void 0;
      }
      function getGlobalObject() {
        return globalThis;
      }
      function getWindowDocument() {
        const globalObj = forceCast(getGlobalObject());
        return globalObj.document;
      }
      function getCanvasContext(canvasElement) {
        const win = canvasElement.ownerDocument.defaultView;
        if (!win) {
          return null;
        }
        const isBrowser = "document" in win;
        return isBrowser ? canvasElement.getContext("2d", {
          willReadFrequently: true
        }) : null;
      }
      const ICON_ID_TO_INNER_HTML_MAP = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
      };
      function createSvgIconElement(document2, iconId) {
        const elem = document2.createElementNS(SVG_NS, "svg");
        elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
        return elem;
      }
      function insertElementAt(parentElement, element2, index) {
        parentElement.insertBefore(element2, parentElement.children[index]);
      }
      function removeElement(element2) {
        if (element2.parentElement) {
          element2.parentElement.removeChild(element2);
        }
      }
      function removeChildElements(element2) {
        while (element2.children.length > 0) {
          element2.removeChild(element2.children[0]);
        }
      }
      function removeChildNodes(element2) {
        while (element2.childNodes.length > 0) {
          element2.removeChild(element2.childNodes[0]);
        }
      }
      function findNextTarget(ev) {
        if (ev.relatedTarget) {
          return forceCast(ev.relatedTarget);
        }
        if ("explicitOriginalTarget" in ev) {
          return ev.explicitOriginalTarget;
        }
        return null;
      }
      const className$n = ClassName("lbl");
      function createLabelNode(doc, label) {
        const frag = doc.createDocumentFragment();
        const lineNodes = label.split("\n").map((line) => {
          return doc.createTextNode(line);
        });
        lineNodes.forEach((lineNode, index) => {
          if (index > 0) {
            frag.appendChild(doc.createElement("br"));
          }
          frag.appendChild(lineNode);
        });
        return frag;
      }
      class LabelView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$n());
          config.viewProps.bindClassModifiers(this.element);
          const labelElem = doc.createElement("div");
          labelElem.classList.add(className$n("l"));
          bindValueMap(config.props, "label", (value) => {
            if (isEmpty(value)) {
              this.element.classList.add(className$n(void 0, "nol"));
            } else {
              this.element.classList.remove(className$n(void 0, "nol"));
              removeChildNodes(labelElem);
              labelElem.appendChild(createLabelNode(doc, value));
            }
          });
          this.element.appendChild(labelElem);
          this.labelElement = labelElem;
          const valueElem = doc.createElement("div");
          valueElem.classList.add(className$n("v"));
          this.element.appendChild(valueElem);
          this.valueElement = valueElem;
        }
      }
      class LabelController extends BladeController {
        constructor(doc, config) {
          const viewProps = config.valueController.viewProps;
          super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
            props: config.props,
            viewProps
          }), viewProps }));
          this.props = config.props;
          this.valueController = config.valueController;
          this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      const ButtonBladePlugin = {
        id: "button",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            title: p.required.string,
            view: p.required.constant("button"),
            label: p.optional.string
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new LabelController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: new ButtonController(args.document, {
              props: ValueMap.fromObject({
                title: args.params.title
              }),
              viewProps: args.viewProps
            })
          });
        },
        api(args) {
          if (!(args.controller instanceof LabelController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof ButtonController)) {
            return null;
          }
          return new ButtonApi(args.controller);
        }
      };
      class ValueBladeController extends BladeController {
        constructor(config) {
          super(config);
          this.value = config.value;
        }
      }
      function createBlade() {
        return new ValueMap({
          positions: createValue([], {
            equals: deepEqualsArray
          })
        });
      }
      class Foldable extends ValueMap {
        constructor(valueMap) {
          super(valueMap);
        }
        static create(expanded) {
          const coreObj = {
            completed: true,
            expanded,
            expandedHeight: null,
            shouldFixHeight: false,
            temporaryExpanded: null
          };
          const core = ValueMap.createCore(coreObj);
          return new Foldable(core);
        }
        get styleExpanded() {
          var _a;
          return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0 ? _a : this.get("expanded");
        }
        get styleHeight() {
          if (!this.styleExpanded) {
            return "0";
          }
          const exHeight = this.get("expandedHeight");
          if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
            return `${exHeight}px`;
          }
          return "auto";
        }
        bindExpandedClass(elem, expandedClassName) {
          const onExpand = () => {
            const expanded = this.styleExpanded;
            if (expanded) {
              elem.classList.add(expandedClassName);
            } else {
              elem.classList.remove(expandedClassName);
            }
          };
          bindValueMap(this, "expanded", onExpand);
          bindValueMap(this, "temporaryExpanded", onExpand);
        }
        cleanUpTransition() {
          this.set("shouldFixHeight", false);
          this.set("expandedHeight", null);
          this.set("completed", true);
        }
      }
      function computeExpandedFolderHeight(folder, containerElement) {
        let height2 = 0;
        disableTransitionTemporarily(containerElement, () => {
          folder.set("expandedHeight", null);
          folder.set("temporaryExpanded", true);
          forceReflow(containerElement);
          height2 = containerElement.clientHeight;
          folder.set("temporaryExpanded", null);
          forceReflow(containerElement);
        });
        return height2;
      }
      function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
      }
      function bindFoldable(foldable, elem) {
        foldable.value("expanded").emitter.on("beforechange", () => {
          foldable.set("completed", false);
          if (isEmpty(foldable.get("expandedHeight"))) {
            const h = computeExpandedFolderHeight(foldable, elem);
            if (h > 0) {
              foldable.set("expandedHeight", h);
            }
          }
          foldable.set("shouldFixHeight", true);
          forceReflow(elem);
        });
        foldable.emitter.on("change", () => {
          applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener("transitionend", (ev) => {
          if (ev.propertyName !== "height") {
            return;
          }
          foldable.cleanUpTransition();
        });
      }
      class RackLikeApi extends BladeApi {
        constructor(controller, rackApi) {
          super(controller);
          this.rackApi_ = rackApi;
        }
      }
      function addButtonAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
      }
      function addFolderAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
      }
      function addSeparatorAsBlade(api, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "separator" }));
      }
      function addTabAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
      }
      class NestedOrderedSet {
        constructor(extract) {
          this.emitter = new Emitter();
          this.items_ = [];
          this.cache_ = /* @__PURE__ */ new Set();
          this.onSubListAdd_ = this.onSubListAdd_.bind(this);
          this.onSubListRemove_ = this.onSubListRemove_.bind(this);
          this.extract_ = extract;
        }
        get items() {
          return this.items_;
        }
        allItems() {
          return Array.from(this.cache_);
        }
        find(callback) {
          for (const item of this.allItems()) {
            if (callback(item)) {
              return item;
            }
          }
          return null;
        }
        includes(item) {
          return this.cache_.has(item);
        }
        add(item, opt_index) {
          if (this.includes(item)) {
            throw TpError.shouldNeverHappen();
          }
          const index = opt_index !== void 0 ? opt_index : this.items_.length;
          this.items_.splice(index, 0, item);
          this.cache_.add(item);
          const subList = this.extract_(item);
          if (subList) {
            subList.emitter.on("add", this.onSubListAdd_);
            subList.emitter.on("remove", this.onSubListRemove_);
            subList.allItems().forEach((item2) => {
              this.cache_.add(item2);
            });
          }
          this.emitter.emit("add", {
            index,
            item,
            root: this,
            target: this
          });
        }
        remove(item) {
          const index = this.items_.indexOf(item);
          if (index < 0) {
            return;
          }
          this.items_.splice(index, 1);
          this.cache_.delete(item);
          const subList = this.extract_(item);
          if (subList) {
            subList.emitter.off("add", this.onSubListAdd_);
            subList.emitter.off("remove", this.onSubListRemove_);
          }
          this.emitter.emit("remove", {
            index,
            item,
            root: this,
            target: this
          });
        }
        onSubListAdd_(ev) {
          this.cache_.add(ev.item);
          this.emitter.emit("add", {
            index: ev.index,
            item: ev.item,
            root: this,
            target: ev.target
          });
        }
        onSubListRemove_(ev) {
          this.cache_.delete(ev.item);
          this.emitter.emit("remove", {
            index: ev.index,
            item: ev.item,
            root: this,
            target: ev.target
          });
        }
      }
      class InputBindingApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.onBindingChange_ = this.onBindingChange_.bind(this);
          this.emitter_ = new Emitter();
          this.controller_.binding.emitter.on("change", this.onBindingChange_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingChange_(ev) {
          const value = ev.sender.target.read();
          this.emitter_.emit("change", {
            event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
          });
        }
      }
      class InputBindingController extends LabelController {
        constructor(doc, config) {
          super(doc, config);
          this.binding = config.binding;
        }
      }
      class MonitorBindingApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
          this.emitter_ = new Emitter();
          this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        refresh() {
          this.controller_.binding.read();
        }
        onBindingUpdate_(ev) {
          const value = ev.sender.target.read();
          this.emitter_.emit("update", {
            event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
          });
        }
      }
      class MonitorBindingController extends LabelController {
        constructor(doc, config) {
          super(doc, config);
          this.binding = config.binding;
          this.viewProps.bindDisabled(this.binding.ticker);
          this.viewProps.handleDispose(() => {
            this.binding.dispose();
          });
        }
      }
      function findSubBladeApiSet(api) {
        if (api instanceof RackApi) {
          return api["apiSet_"];
        }
        if (api instanceof RackLikeApi) {
          return api["rackApi_"]["apiSet_"];
        }
        return null;
      }
      function getApiByController(apiSet, controller) {
        const api = apiSet.find((api2) => api2.controller_ === controller);
        if (!api) {
          throw TpError.shouldNeverHappen();
        }
        return api;
      }
      function createBindingTarget(obj, key2, opt_id) {
        if (!BindingTarget.isBindable(obj)) {
          throw TpError.notBindable();
        }
        return new BindingTarget(obj, key2, opt_id);
      }
      class RackApi extends BladeApi {
        constructor(controller, pool) {
          super(controller);
          this.onRackAdd_ = this.onRackAdd_.bind(this);
          this.onRackRemove_ = this.onRackRemove_.bind(this);
          this.onRackInputChange_ = this.onRackInputChange_.bind(this);
          this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
          this.emitter_ = new Emitter();
          this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
          this.pool_ = pool;
          const rack = this.controller_.rack;
          rack.emitter.on("add", this.onRackAdd_);
          rack.emitter.on("remove", this.onRackRemove_);
          rack.emitter.on("inputchange", this.onRackInputChange_);
          rack.emitter.on("monitorupdate", this.onRackMonitorUpdate_);
          rack.children.forEach((bc) => {
            this.setUpApi_(bc);
          });
        }
        get children() {
          return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
        }
        addInput(object, key2, opt_params) {
          const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createInput(doc, createBindingTarget(object, key2, params.presetKey), params);
          const api = new InputBindingApi(bc);
          return this.add(api, params.index);
        }
        addMonitor(object, key2, opt_params) {
          const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key2), params);
          const api = new MonitorBindingApi(bc);
          return forceCast(this.add(api, params.index));
        }
        addFolder(params) {
          return addFolderAsBlade(this, params);
        }
        addButton(params) {
          return addButtonAsBlade(this, params);
        }
        addSeparator(opt_params) {
          return addSeparatorAsBlade(this, opt_params);
        }
        addTab(params) {
          return addTabAsBlade(this, params);
        }
        add(api, opt_index) {
          this.controller_.rack.add(api.controller_, opt_index);
          const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
          if (gapi) {
            this.apiSet_.remove(gapi);
          }
          this.apiSet_.add(api);
          return api;
        }
        remove(api) {
          this.controller_.rack.remove(api.controller_);
        }
        addBlade(params) {
          const doc = this.controller_.view.element.ownerDocument;
          const bc = this.pool_.createBlade(doc, params);
          const api = this.pool_.createBladeApi(bc);
          return this.add(api, params.index);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        setUpApi_(bc) {
          const api = this.apiSet_.find((api2) => api2.controller_ === bc);
          if (!api) {
            this.apiSet_.add(this.pool_.createBladeApi(bc));
          }
        }
        onRackAdd_(ev) {
          this.setUpApi_(ev.bladeController);
        }
        onRackRemove_(ev) {
          if (ev.isRoot) {
            const api = getApiByController(this.apiSet_, ev.bladeController);
            this.apiSet_.remove(api);
          }
        }
        onRackInputChange_(ev) {
          const bc = ev.bladeController;
          if (bc instanceof InputBindingController) {
            const api = getApiByController(this.apiSet_, bc);
            const binding = bc.binding;
            this.emitter_.emit("change", {
              event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
            });
          } else if (bc instanceof ValueBladeController) {
            const api = getApiByController(this.apiSet_, bc);
            this.emitter_.emit("change", {
              event: new TpChangeEvent(api, bc.value.rawValue, void 0, ev.options.last)
            });
          }
        }
        onRackMonitorUpdate_(ev) {
          if (!(ev.bladeController instanceof MonitorBindingController)) {
            throw TpError.shouldNeverHappen();
          }
          const api = getApiByController(this.apiSet_, ev.bladeController);
          const binding = ev.bladeController.binding;
          this.emitter_.emit("update", {
            event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
          });
        }
      }
      class FolderApi extends RackLikeApi {
        constructor(controller, pool) {
          super(controller, new RackApi(controller.rackController, pool));
          this.emitter_ = new Emitter();
          this.controller_.foldable.value("expanded").emitter.on("change", (ev) => {
            this.emitter_.emit("fold", {
              event: new TpFoldEvent(this, ev.sender.rawValue)
            });
          });
          this.rackApi_.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: ev
            });
          });
          this.rackApi_.on("update", (ev) => {
            this.emitter_.emit("update", {
              event: ev
            });
          });
        }
        get expanded() {
          return this.controller_.foldable.get("expanded");
        }
        set expanded(expanded) {
          this.controller_.foldable.set("expanded", expanded);
        }
        get title() {
          return this.controller_.props.get("title");
        }
        set title(title) {
          this.controller_.props.set("title", title);
        }
        get children() {
          return this.rackApi_.children;
        }
        addInput(object, key2, opt_params) {
          return this.rackApi_.addInput(object, key2, opt_params);
        }
        addMonitor(object, key2, opt_params) {
          return this.rackApi_.addMonitor(object, key2, opt_params);
        }
        addFolder(params) {
          return this.rackApi_.addFolder(params);
        }
        addButton(params) {
          return this.rackApi_.addButton(params);
        }
        addSeparator(opt_params) {
          return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
          return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
          return this.rackApi_.add(api, opt_index);
        }
        remove(api) {
          this.rackApi_.remove(api);
        }
        addBlade(params) {
          return this.rackApi_.addBlade(params);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class RackLikeController extends BladeController {
        constructor(config) {
          super({
            blade: config.blade,
            view: config.view,
            viewProps: config.rackController.viewProps
          });
          this.rackController = config.rackController;
        }
      }
      class PlainView {
        constructor(doc, config) {
          const className2 = ClassName(config.viewName);
          this.element = doc.createElement("div");
          this.element.classList.add(className2());
          config.viewProps.bindClassModifiers(this.element);
        }
      }
      function findInputBindingController(bcs, b2) {
        for (let i = 0; i < bcs.length; i++) {
          const bc = bcs[i];
          if (bc instanceof InputBindingController && bc.binding === b2) {
            return bc;
          }
        }
        return null;
      }
      function findMonitorBindingController(bcs, b2) {
        for (let i = 0; i < bcs.length; i++) {
          const bc = bcs[i];
          if (bc instanceof MonitorBindingController && bc.binding === b2) {
            return bc;
          }
        }
        return null;
      }
      function findValueBladeController(bcs, v4) {
        for (let i = 0; i < bcs.length; i++) {
          const bc = bcs[i];
          if (bc instanceof ValueBladeController && bc.value === v4) {
            return bc;
          }
        }
        return null;
      }
      function findSubRack(bc) {
        if (bc instanceof RackController) {
          return bc.rack;
        }
        if (bc instanceof RackLikeController) {
          return bc.rackController.rack;
        }
        return null;
      }
      function findSubBladeControllerSet(bc) {
        const rack = findSubRack(bc);
        return rack ? rack["bcSet_"] : null;
      }
      class BladeRack {
        constructor(config) {
          var _a, _b;
          this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
          this.onSetAdd_ = this.onSetAdd_.bind(this);
          this.onSetRemove_ = this.onSetRemove_.bind(this);
          this.onChildDispose_ = this.onChildDispose_.bind(this);
          this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
          this.onChildInputChange_ = this.onChildInputChange_.bind(this);
          this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
          this.onChildValueChange_ = this.onChildValueChange_.bind(this);
          this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
          this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
          this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
          this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
          this.emitter = new Emitter();
          this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
          (_b = this.blade_) === null || _b === void 0 ? void 0 : _b.value("positions").emitter.on("change", this.onBladePositionsChange_);
          this.viewProps = config.viewProps;
          this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
          this.bcSet_.emitter.on("add", this.onSetAdd_);
          this.bcSet_.emitter.on("remove", this.onSetRemove_);
        }
        get children() {
          return this.bcSet_.items;
        }
        add(bc, opt_index) {
          var _a;
          (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
          if (isPropertyWritable(bc, "parent")) {
            bc.parent = this;
          } else {
            bc["parent_"] = this;
            warnMissing({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.add"
            });
          }
          this.bcSet_.add(bc, opt_index);
        }
        remove(bc) {
          if (isPropertyWritable(bc, "parent")) {
            bc.parent = null;
          } else {
            bc["parent_"] = null;
            warnMissing({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.remove"
            });
          }
          this.bcSet_.remove(bc);
        }
        find(controllerClass) {
          return forceCast(this.bcSet_.allItems().filter((bc) => {
            return bc instanceof controllerClass;
          }));
        }
        onSetAdd_(ev) {
          this.updatePositions_();
          const isRoot2 = ev.target === ev.root;
          this.emitter.emit("add", {
            bladeController: ev.item,
            index: ev.index,
            isRoot: isRoot2,
            sender: this
          });
          if (!isRoot2) {
            return;
          }
          const bc = ev.item;
          bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
          bc.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
          bc.viewProps.handleDispose(this.onChildDispose_);
          if (bc instanceof InputBindingController) {
            bc.binding.emitter.on("change", this.onChildInputChange_);
          } else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.on("update", this.onChildMonitorUpdate_);
          } else if (bc instanceof ValueBladeController) {
            bc.value.emitter.on("change", this.onChildValueChange_);
          } else {
            const rack = findSubRack(bc);
            if (rack) {
              const emitter = rack.emitter;
              emitter.on("layout", this.onDescendantLayout_);
              emitter.on("inputchange", this.onDescendantInputChange_);
              emitter.on("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        onSetRemove_(ev) {
          this.updatePositions_();
          const isRoot2 = ev.target === ev.root;
          this.emitter.emit("remove", {
            bladeController: ev.item,
            isRoot: isRoot2,
            sender: this
          });
          if (!isRoot2) {
            return;
          }
          const bc = ev.item;
          if (bc instanceof InputBindingController) {
            bc.binding.emitter.off("change", this.onChildInputChange_);
          } else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.off("update", this.onChildMonitorUpdate_);
          } else if (bc instanceof ValueBladeController) {
            bc.value.emitter.off("change", this.onChildValueChange_);
          } else {
            const rack = findSubRack(bc);
            if (rack) {
              const emitter = rack.emitter;
              emitter.off("layout", this.onDescendantLayout_);
              emitter.off("inputchange", this.onDescendantInputChange_);
              emitter.off("monitorupdate", this.onDescendantMonitorUpdate_);
            }
          }
        }
        updatePositions_() {
          const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get("hidden"));
          const firstVisibleItem = visibleItems[0];
          const lastVisibleItem = visibleItems[visibleItems.length - 1];
          this.bcSet_.items.forEach((bc) => {
            const ps = [];
            if (bc === firstVisibleItem) {
              ps.push("first");
              if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
                ps.push("veryfirst");
              }
            }
            if (bc === lastVisibleItem) {
              ps.push("last");
              if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
                ps.push("verylast");
              }
            }
            bc.blade.set("positions", ps);
          });
        }
        onChildPositionsChange_() {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildViewPropsChange_(_ev) {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onChildDispose_() {
          const disposedUcs = this.bcSet_.items.filter((bc) => {
            return bc.viewProps.get("disposed");
          });
          disposedUcs.forEach((bc) => {
            this.bcSet_.remove(bc);
          });
        }
        onChildInputChange_(ev) {
          const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
          if (!bc) {
            throw TpError.alreadyDisposed();
          }
          this.emitter.emit("inputchange", {
            bladeController: bc,
            options: ev.options,
            sender: this
          });
        }
        onChildMonitorUpdate_(ev) {
          const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
          if (!bc) {
            throw TpError.alreadyDisposed();
          }
          this.emitter.emit("monitorupdate", {
            bladeController: bc,
            sender: this
          });
        }
        onChildValueChange_(ev) {
          const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
          if (!bc) {
            throw TpError.alreadyDisposed();
          }
          this.emitter.emit("inputchange", {
            bladeController: bc,
            options: ev.options,
            sender: this
          });
        }
        onDescendantLayout_(_) {
          this.updatePositions_();
          this.emitter.emit("layout", {
            sender: this
          });
        }
        onDescendantInputChange_(ev) {
          this.emitter.emit("inputchange", {
            bladeController: ev.bladeController,
            options: ev.options,
            sender: this
          });
        }
        onDescendantMonitorUpdate_(ev) {
          this.emitter.emit("monitorupdate", {
            bladeController: ev.bladeController,
            sender: this
          });
        }
        onBladePositionsChange_() {
          this.updatePositions_();
        }
      }
      class RackController extends BladeController {
        constructor(doc, config) {
          super(Object.assign(Object.assign({}, config), { view: new PlainView(doc, {
            viewName: "brk",
            viewProps: config.viewProps
          }) }));
          this.onRackAdd_ = this.onRackAdd_.bind(this);
          this.onRackRemove_ = this.onRackRemove_.bind(this);
          const rack = new BladeRack({
            blade: config.root ? void 0 : config.blade,
            viewProps: config.viewProps
          });
          rack.emitter.on("add", this.onRackAdd_);
          rack.emitter.on("remove", this.onRackRemove_);
          this.rack = rack;
          this.viewProps.handleDispose(() => {
            for (let i = this.rack.children.length - 1; i >= 0; i--) {
              const bc = this.rack.children[i];
              bc.viewProps.set("disposed", true);
            }
          });
        }
        onRackAdd_(ev) {
          if (!ev.isRoot) {
            return;
          }
          insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
        }
        onRackRemove_(ev) {
          if (!ev.isRoot) {
            return;
          }
          removeElement(ev.bladeController.view.element);
        }
      }
      const bladeContainerClassName = ClassName("cnt");
      class FolderView {
        constructor(doc, config) {
          var _a;
          this.className_ = ClassName((_a = config.viewName) !== null && _a !== void 0 ? _a : "fld");
          this.element = doc.createElement("div");
          this.element.classList.add(this.className_(), bladeContainerClassName());
          config.viewProps.bindClassModifiers(this.element);
          this.foldable_ = config.foldable;
          this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
          bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(this.className_("b"));
          bindValueMap(config.props, "title", (title) => {
            if (isEmpty(title)) {
              this.element.classList.add(this.className_(void 0, "not"));
            } else {
              this.element.classList.remove(this.className_(void 0, "not"));
            }
          });
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const indentElem = doc.createElement("div");
          indentElem.classList.add(this.className_("i"));
          this.element.appendChild(indentElem);
          const titleElem = doc.createElement("div");
          titleElem.classList.add(this.className_("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
          this.titleElement = titleElem;
          const markElem = doc.createElement("div");
          markElem.classList.add(this.className_("m"));
          this.buttonElement.appendChild(markElem);
          const containerElem = config.containerElement;
          containerElem.classList.add(this.className_("c"));
          this.element.appendChild(containerElem);
          this.containerElement = containerElem;
        }
      }
      class FolderController extends RackLikeController {
        constructor(doc, config) {
          var _a;
          const foldable = Foldable.create((_a = config.expanded) !== null && _a !== void 0 ? _a : true);
          const rc = new RackController(doc, {
            blade: config.blade,
            root: config.root,
            viewProps: config.viewProps
          });
          super(Object.assign(Object.assign({}, config), { rackController: rc, view: new FolderView(doc, {
            containerElement: rc.view.element,
            foldable,
            props: config.props,
            viewName: config.root ? "rot" : void 0,
            viewProps: config.viewProps
          }) }));
          this.onTitleClick_ = this.onTitleClick_.bind(this);
          this.props = config.props;
          this.foldable = foldable;
          bindFoldable(this.foldable, this.view.containerElement);
          this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition();
          });
          this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition();
          });
          this.view.buttonElement.addEventListener("click", this.onTitleClick_);
        }
        get document() {
          return this.view.element.ownerDocument;
        }
        onTitleClick_() {
          this.foldable.set("expanded", !this.foldable.get("expanded"));
        }
      }
      const FolderBladePlugin = {
        id: "folder",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            title: p.required.string,
            view: p.required.constant("folder"),
            expanded: p.optional.boolean
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new FolderController(args.document, {
            blade: args.blade,
            expanded: args.params.expanded,
            props: ValueMap.fromObject({
              title: args.params.title
            }),
            viewProps: args.viewProps
          });
        },
        api(args) {
          if (!(args.controller instanceof FolderController)) {
            return null;
          }
          return new FolderApi(args.controller, args.pool);
        }
      };
      class LabeledValueController extends ValueBladeController {
        constructor(doc, config) {
          const viewProps = config.valueController.viewProps;
          super(Object.assign(Object.assign({}, config), { value: config.valueController.value, view: new LabelView(doc, {
            props: config.props,
            viewProps
          }), viewProps }));
          this.props = config.props;
          this.valueController = config.valueController;
          this.view.valueElement.appendChild(this.valueController.view.element);
        }
      }
      class SeparatorApi extends BladeApi {
      }
      const className$m = ClassName("spr");
      class SeparatorView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$m());
          config.viewProps.bindClassModifiers(this.element);
          const hrElem = doc.createElement("hr");
          hrElem.classList.add(className$m("r"));
          this.element.appendChild(hrElem);
        }
      }
      class SeparatorController extends BladeController {
        constructor(doc, config) {
          super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
            viewProps: config.viewProps
          }) }));
        }
      }
      const SeparatorBladePlugin = {
        id: "separator",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            view: p.required.constant("separator")
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          return new SeparatorController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
        },
        api(args) {
          if (!(args.controller instanceof SeparatorController)) {
            return null;
          }
          return new SeparatorApi(args.controller);
        }
      };
      const className$l = ClassName("tbi");
      class TabItemView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$l());
          config.viewProps.bindClassModifiers(this.element);
          bindValueMap(config.props, "selected", (selected) => {
            if (selected) {
              this.element.classList.add(className$l(void 0, "sel"));
            } else {
              this.element.classList.remove(className$l(void 0, "sel"));
            }
          });
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$l("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$l("t"));
          bindValueToTextContent(config.props.value("title"), titleElem);
          this.buttonElement.appendChild(titleElem);
          this.titleElement = titleElem;
        }
      }
      class TabItemController {
        constructor(doc, config) {
          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new TabItemView(doc, {
            props: config.props,
            viewProps: config.viewProps
          });
          this.view.buttonElement.addEventListener("click", this.onClick_);
        }
        onClick_() {
          this.emitter.emit("click", {
            sender: this
          });
        }
      }
      class TabPageController {
        constructor(doc, config) {
          this.onItemClick_ = this.onItemClick_.bind(this);
          this.ic_ = new TabItemController(doc, {
            props: config.itemProps,
            viewProps: ViewProps.create()
          });
          this.ic_.emitter.on("click", this.onItemClick_);
          this.cc_ = new RackController(doc, {
            blade: createBlade(),
            viewProps: ViewProps.create()
          });
          this.props = config.props;
          bindValueMap(this.props, "selected", (selected) => {
            this.itemController.props.set("selected", selected);
            this.contentController.viewProps.set("hidden", !selected);
          });
        }
        get itemController() {
          return this.ic_;
        }
        get contentController() {
          return this.cc_;
        }
        onItemClick_() {
          this.props.set("selected", true);
        }
      }
      class TabPageApi {
        constructor(controller, contentRackApi) {
          this.controller_ = controller;
          this.rackApi_ = contentRackApi;
        }
        get title() {
          var _a;
          return (_a = this.controller_.itemController.props.get("title")) !== null && _a !== void 0 ? _a : "";
        }
        set title(title) {
          this.controller_.itemController.props.set("title", title);
        }
        get selected() {
          return this.controller_.props.get("selected");
        }
        set selected(selected) {
          this.controller_.props.set("selected", selected);
        }
        get children() {
          return this.rackApi_.children;
        }
        addButton(params) {
          return this.rackApi_.addButton(params);
        }
        addFolder(params) {
          return this.rackApi_.addFolder(params);
        }
        addSeparator(opt_params) {
          return this.rackApi_.addSeparator(opt_params);
        }
        addTab(params) {
          return this.rackApi_.addTab(params);
        }
        add(api, opt_index) {
          this.rackApi_.add(api, opt_index);
        }
        remove(api) {
          this.rackApi_.remove(api);
        }
        addInput(object, key2, opt_params) {
          return this.rackApi_.addInput(object, key2, opt_params);
        }
        addMonitor(object, key2, opt_params) {
          return this.rackApi_.addMonitor(object, key2, opt_params);
        }
        addBlade(params) {
          return this.rackApi_.addBlade(params);
        }
      }
      class TabApi extends RackLikeApi {
        constructor(controller, pool) {
          super(controller, new RackApi(controller.rackController, pool));
          this.onPageAdd_ = this.onPageAdd_.bind(this);
          this.onPageRemove_ = this.onPageRemove_.bind(this);
          this.onSelect_ = this.onSelect_.bind(this);
          this.emitter_ = new Emitter();
          this.pageApiMap_ = /* @__PURE__ */ new Map();
          this.rackApi_.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: ev
            });
          });
          this.rackApi_.on("update", (ev) => {
            this.emitter_.emit("update", {
              event: ev
            });
          });
          this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_);
          this.controller_.pageSet.emitter.on("add", this.onPageAdd_);
          this.controller_.pageSet.emitter.on("remove", this.onPageRemove_);
          this.controller_.pageSet.items.forEach((pc) => {
            this.setUpPageApi_(pc);
          });
        }
        get pages() {
          return this.controller_.pageSet.items.map((pc) => {
            const api = this.pageApiMap_.get(pc);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            return api;
          });
        }
        addPage(params) {
          const doc = this.controller_.view.element.ownerDocument;
          const pc = new TabPageController(doc, {
            itemProps: ValueMap.fromObject({
              selected: false,
              title: params.title
            }),
            props: ValueMap.fromObject({
              selected: false
            })
          });
          this.controller_.add(pc, params.index);
          const api = this.pageApiMap_.get(pc);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
        removePage(index) {
          this.controller_.remove(index);
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
        setUpPageApi_(pc) {
          const rackApi = this.rackApi_["apiSet_"].find((api2) => api2.controller_ === pc.contentController);
          if (!rackApi) {
            throw TpError.shouldNeverHappen();
          }
          const api = new TabPageApi(pc, rackApi);
          this.pageApiMap_.set(pc, api);
        }
        onPageAdd_(ev) {
          this.setUpPageApi_(ev.item);
        }
        onPageRemove_(ev) {
          const api = this.pageApiMap_.get(ev.item);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          this.pageApiMap_.delete(ev.item);
        }
        onSelect_(ev) {
          this.emitter_.emit("select", {
            event: new TpTabSelectEvent(this, ev.rawValue)
          });
        }
      }
      const INDEX_NOT_SELECTED = -1;
      class Tab {
        constructor() {
          this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
          this.empty = createValue(true);
          this.selectedIndex = createValue(INDEX_NOT_SELECTED);
          this.items_ = [];
        }
        add(item, opt_index) {
          const index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
          this.items_.splice(index, 0, item);
          item.emitter.on("change", this.onItemSelectedChange_);
          this.keepSelection_();
        }
        remove(item) {
          const index = this.items_.indexOf(item);
          if (index < 0) {
            return;
          }
          this.items_.splice(index, 1);
          item.emitter.off("change", this.onItemSelectedChange_);
          this.keepSelection_();
        }
        keepSelection_() {
          if (this.items_.length === 0) {
            this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
            this.empty.rawValue = true;
            return;
          }
          const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
          if (firstSelIndex < 0) {
            this.items_.forEach((s, i) => {
              s.rawValue = i === 0;
            });
            this.selectedIndex.rawValue = 0;
          } else {
            this.items_.forEach((s, i) => {
              s.rawValue = i === firstSelIndex;
            });
            this.selectedIndex.rawValue = firstSelIndex;
          }
          this.empty.rawValue = false;
        }
        onItemSelectedChange_(ev) {
          if (ev.rawValue) {
            const index = this.items_.findIndex((s) => s === ev.sender);
            this.items_.forEach((s, i) => {
              s.rawValue = i === index;
            });
            this.selectedIndex.rawValue = index;
          } else {
            this.keepSelection_();
          }
        }
      }
      const className$k = ClassName("tab");
      class TabView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$k(), bladeContainerClassName());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.empty, valueToClassName(this.element, className$k(void 0, "nop")));
          const titleElem = doc.createElement("div");
          titleElem.classList.add(className$k("t"));
          this.element.appendChild(titleElem);
          this.itemsElement = titleElem;
          const indentElem = doc.createElement("div");
          indentElem.classList.add(className$k("i"));
          this.element.appendChild(indentElem);
          const contentsElem = config.contentsElement;
          contentsElem.classList.add(className$k("c"));
          this.element.appendChild(contentsElem);
          this.contentsElement = contentsElem;
        }
      }
      class TabController extends RackLikeController {
        constructor(doc, config) {
          const cr = new RackController(doc, {
            blade: config.blade,
            viewProps: config.viewProps
          });
          const tab = new Tab();
          super({
            blade: config.blade,
            rackController: cr,
            view: new TabView(doc, {
              contentsElement: cr.view.element,
              empty: tab.empty,
              viewProps: config.viewProps
            })
          });
          this.onPageAdd_ = this.onPageAdd_.bind(this);
          this.onPageRemove_ = this.onPageRemove_.bind(this);
          this.pageSet_ = new NestedOrderedSet(() => null);
          this.pageSet_.emitter.on("add", this.onPageAdd_);
          this.pageSet_.emitter.on("remove", this.onPageRemove_);
          this.tab = tab;
        }
        get pageSet() {
          return this.pageSet_;
        }
        add(pc, opt_index) {
          this.pageSet_.add(pc, opt_index);
        }
        remove(index) {
          this.pageSet_.remove(this.pageSet_.items[index]);
        }
        onPageAdd_(ev) {
          const pc = ev.item;
          insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
          pc.itemController.viewProps.set("parent", this.viewProps);
          this.rackController.rack.add(pc.contentController, ev.index);
          this.tab.add(pc.props.value("selected"));
        }
        onPageRemove_(ev) {
          const pc = ev.item;
          removeElement(pc.itemController.view.element);
          pc.itemController.viewProps.set("parent", null);
          this.rackController.rack.remove(pc.contentController);
          this.tab.remove(pc.props.value("selected"));
        }
      }
      const TabBladePlugin = {
        id: "tab",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            pages: p.required.array(p.required.object({ title: p.required.string })),
            view: p.required.constant("tab")
          });
          if (!result || result.pages.length === 0) {
            return null;
          }
          return { params: result };
        },
        controller(args) {
          const c = new TabController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
          args.params.pages.forEach((p) => {
            const pc = new TabPageController(args.document, {
              itemProps: ValueMap.fromObject({
                selected: false,
                title: p.title
              }),
              props: ValueMap.fromObject({
                selected: false
              })
            });
            c.add(pc);
          });
          return c;
        },
        api(args) {
          if (!(args.controller instanceof TabController)) {
            return null;
          }
          return new TabApi(args.controller, args.pool);
        }
      };
      function createBladeController(plugin, args) {
        const ac = plugin.accept(args.params);
        if (!ac) {
          return null;
        }
        const disabled = ParamsParsers.optional.boolean(args.params["disabled"]).value;
        const hidden = ParamsParsers.optional.boolean(args.params["hidden"]).value;
        return plugin.controller({
          blade: createBlade(),
          document: args.document,
          params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled, hidden })),
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
      }
      class ManualTicker {
        constructor() {
          this.disabled = false;
          this.emitter = new Emitter();
        }
        dispose() {
        }
        tick() {
          if (this.disabled) {
            return;
          }
          this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class IntervalTicker {
        constructor(doc, interval) {
          this.disabled_ = false;
          this.timerId_ = null;
          this.onTick_ = this.onTick_.bind(this);
          this.doc_ = doc;
          this.emitter = new Emitter();
          this.interval_ = interval;
          this.setTimer_();
        }
        get disabled() {
          return this.disabled_;
        }
        set disabled(inactive) {
          this.disabled_ = inactive;
          if (this.disabled_) {
            this.clearTimer_();
          } else {
            this.setTimer_();
          }
        }
        dispose() {
          this.clearTimer_();
        }
        clearTimer_() {
          if (this.timerId_ === null) {
            return;
          }
          const win = this.doc_.defaultView;
          if (win) {
            win.clearInterval(this.timerId_);
          }
          this.timerId_ = null;
        }
        setTimer_() {
          this.clearTimer_();
          if (this.interval_ <= 0) {
            return;
          }
          const win = this.doc_.defaultView;
          if (win) {
            this.timerId_ = win.setInterval(this.onTick_, this.interval_);
          }
        }
        onTick_() {
          if (this.disabled_) {
            return;
          }
          this.emitter.emit("tick", {
            sender: this
          });
        }
      }
      class InputBinding {
        constructor(config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.reader = config.reader;
          this.writer = config.writer;
          this.emitter = new Emitter();
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.target = config.target;
          this.read();
        }
        read() {
          const targetValue = this.target.read();
          if (targetValue !== void 0) {
            this.value.rawValue = this.reader(targetValue);
          }
        }
        write_(rawValue) {
          this.writer(this.target, rawValue);
        }
        onValueChange_(ev) {
          this.write_(ev.rawValue);
          this.emitter.emit("change", {
            options: ev.options,
            rawValue: ev.rawValue,
            sender: this
          });
        }
      }
      function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
          buffer.push(void 0);
        }
      }
      function initializeBuffer(bufferSize) {
        const buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
      }
      function createTrimmedBuffer(buffer) {
        const index = buffer.indexOf(void 0);
        return forceCast(index < 0 ? buffer : buffer.slice(0, index));
      }
      function createPushedBuffer(buffer, newValue) {
        const newBuffer = [...createTrimmedBuffer(buffer), newValue];
        if (newBuffer.length > buffer.length) {
          newBuffer.splice(0, newBuffer.length - buffer.length);
        } else {
          fillBuffer(newBuffer, buffer.length);
        }
        return newBuffer;
      }
      class MonitorBinding {
        constructor(config) {
          this.onTick_ = this.onTick_.bind(this);
          this.reader_ = config.reader;
          this.target = config.target;
          this.emitter = new Emitter();
          this.value = config.value;
          this.ticker = config.ticker;
          this.ticker.emitter.on("tick", this.onTick_);
          this.read();
        }
        dispose() {
          this.ticker.dispose();
        }
        read() {
          const targetValue = this.target.read();
          if (targetValue === void 0) {
            return;
          }
          const buffer = this.value.rawValue;
          const newValue = this.reader_(targetValue);
          this.value.rawValue = createPushedBuffer(buffer, newValue);
          this.emitter.emit("update", {
            rawValue: newValue,
            sender: this
          });
        }
        onTick_(_) {
          this.read();
        }
      }
      class CompositeConstraint {
        constructor(constraints) {
          this.constraints = constraints;
        }
        constrain(value) {
          return this.constraints.reduce((result, c) => {
            return c.constrain(result);
          }, value);
        }
      }
      function findConstraint(c, constraintClass) {
        if (c instanceof constraintClass) {
          return c;
        }
        if (c instanceof CompositeConstraint) {
          const result = c.constraints.reduce((tmpResult, sc) => {
            if (tmpResult) {
              return tmpResult;
            }
            return sc instanceof constraintClass ? sc : null;
          }, null);
          if (result) {
            return result;
          }
        }
        return null;
      }
      class DefiniteRangeConstraint {
        constructor(config) {
          this.values = ValueMap.fromObject({
            max: config.max,
            min: config.min
          });
        }
        constrain(value) {
          const max = this.values.get("max");
          const min = this.values.get("min");
          return Math.min(Math.max(value, min), max);
        }
      }
      class ListConstraint {
        constructor(options) {
          this.values = ValueMap.fromObject({
            options
          });
        }
        get options() {
          return this.values.get("options");
        }
        constrain(value) {
          const opts = this.values.get("options");
          if (opts.length === 0) {
            return value;
          }
          const matched = opts.filter((item) => {
            return item.value === value;
          }).length > 0;
          return matched ? value : opts[0].value;
        }
      }
      class RangeConstraint {
        constructor(config) {
          this.values = ValueMap.fromObject({
            max: config.max,
            min: config.min
          });
        }
        get maxValue() {
          return this.values.get("max");
        }
        get minValue() {
          return this.values.get("min");
        }
        constrain(value) {
          const max = this.values.get("max");
          const min = this.values.get("min");
          let result = value;
          if (!isEmpty(min)) {
            result = Math.max(result, min);
          }
          if (!isEmpty(max)) {
            result = Math.min(result, max);
          }
          return result;
        }
      }
      class StepConstraint {
        constructor(step, origin3 = 0) {
          this.step = step;
          this.origin = origin3;
        }
        constrain(value) {
          const o = this.origin % this.step;
          const r = Math.round((value - o) / this.step);
          return o + r * this.step;
        }
      }
      const className$j = ClassName("lst");
      class ListView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.props_ = config.props;
          this.element = doc.createElement("div");
          this.element.classList.add(className$j());
          config.viewProps.bindClassModifiers(this.element);
          const selectElem = doc.createElement("select");
          selectElem.classList.add(className$j("s"));
          config.viewProps.bindDisabled(selectElem);
          this.element.appendChild(selectElem);
          this.selectElement = selectElem;
          const markElem = doc.createElement("div");
          markElem.classList.add(className$j("m"));
          markElem.appendChild(createSvgIconElement(doc, "dropdown"));
          this.element.appendChild(markElem);
          config.value.emitter.on("change", this.onValueChange_);
          this.value_ = config.value;
          bindValueMap(this.props_, "options", (opts) => {
            removeChildElements(this.selectElement);
            opts.forEach((item) => {
              const optionElem = doc.createElement("option");
              optionElem.textContent = item.text;
              this.selectElement.appendChild(optionElem);
            });
            this.update_();
          });
        }
        update_() {
          const values = this.props_.get("options").map((o) => o.value);
          this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class ListController {
        constructor(doc, config) {
          this.onSelectChange_ = this.onSelectChange_.bind(this);
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ListView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.selectElement.addEventListener("change", this.onSelectChange_);
        }
        onSelectChange_(e) {
          const selectElem = forceCast(e.currentTarget);
          this.value.rawValue = this.props.get("options")[selectElem.selectedIndex].value;
        }
      }
      const className$i = ClassName("pop");
      class PopupView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$i());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.shows, valueToClassName(this.element, className$i(void 0, "v")));
        }
      }
      class PopupController {
        constructor(doc, config) {
          this.shows = createValue(false);
          this.viewProps = config.viewProps;
          this.view = new PopupView(doc, {
            shows: this.shows,
            viewProps: this.viewProps
          });
        }
      }
      const className$h = ClassName("txt");
      class TextView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className$h());
          config.viewProps.bindClassModifiers(this.element);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$h("i"));
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on("change", this.onChange_);
          this.value_ = config.value;
          this.refresh();
        }
        refresh() {
          const formatter = this.props_.get("formatter");
          this.inputElement.value = formatter(this.value_.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class TextController {
        constructor(doc, config) {
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.parser_ = config.parser;
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new TextView(doc, {
            props: config.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(e) {
          const inputElem = forceCast(e.currentTarget);
          const value = inputElem.value;
          const parsedValue = this.parser_(value);
          if (!isEmpty(parsedValue)) {
            this.value.rawValue = parsedValue;
          }
          this.view.refresh();
        }
      }
      function boolToString(value) {
        return String(value);
      }
      function boolFromUnknown(value) {
        if (value === "false") {
          return false;
        }
        return !!value;
      }
      function BooleanFormatter(value) {
        return boolToString(value);
      }
      class NumberLiteralNode {
        constructor(text) {
          this.text = text;
        }
        evaluate() {
          return Number(this.text);
        }
        toString() {
          return this.text;
        }
      }
      const BINARY_OPERATION_MAP = {
        "**": (v12, v22) => Math.pow(v12, v22),
        "*": (v12, v22) => v12 * v22,
        "/": (v12, v22) => v12 / v22,
        "%": (v12, v22) => v12 % v22,
        "+": (v12, v22) => v12 + v22,
        "-": (v12, v22) => v12 - v22,
        "<<": (v12, v22) => v12 << v22,
        ">>": (v12, v22) => v12 >> v22,
        ">>>": (v12, v22) => v12 >>> v22,
        "&": (v12, v22) => v12 & v22,
        "^": (v12, v22) => v12 ^ v22,
        "|": (v12, v22) => v12 | v22
      };
      class BinaryOperationNode {
        constructor(operator, left, right) {
          this.left = left;
          this.operator = operator;
          this.right = right;
        }
        evaluate() {
          const op = BINARY_OPERATION_MAP[this.operator];
          if (!op) {
            throw new Error(`unexpected binary operator: '${this.operator}`);
          }
          return op(this.left.evaluate(), this.right.evaluate());
        }
        toString() {
          return [
            "b(",
            this.left.toString(),
            this.operator,
            this.right.toString(),
            ")"
          ].join(" ");
        }
      }
      const UNARY_OPERATION_MAP = {
        "+": (v4) => v4,
        "-": (v4) => -v4,
        "~": (v4) => ~v4
      };
      class UnaryOperationNode {
        constructor(operator, expr) {
          this.operator = operator;
          this.expression = expr;
        }
        evaluate() {
          const op = UNARY_OPERATION_MAP[this.operator];
          if (!op) {
            throw new Error(`unexpected unary operator: '${this.operator}`);
          }
          return op(this.expression.evaluate());
        }
        toString() {
          return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
        }
      }
      function combineReader(parsers) {
        return (text, cursor) => {
          for (let i = 0; i < parsers.length; i++) {
            const result = parsers[i](text, cursor);
            if (result !== "") {
              return result;
            }
          }
          return "";
        };
      }
      function readWhitespace(text, cursor) {
        var _a;
        const m2 = text.substr(cursor).match(/^\s+/);
        return (_a = m2 && m2[0]) !== null && _a !== void 0 ? _a : "";
      }
      function readNonZeroDigit(text, cursor) {
        const ch = text.substr(cursor, 1);
        return ch.match(/^[1-9]$/) ? ch : "";
      }
      function readDecimalDigits(text, cursor) {
        var _a;
        const m2 = text.substr(cursor).match(/^[0-9]+/);
        return (_a = m2 && m2[0]) !== null && _a !== void 0 ? _a : "";
      }
      function readSignedInteger(text, cursor) {
        const ds = readDecimalDigits(text, cursor);
        if (ds !== "") {
          return ds;
        }
        const sign = text.substr(cursor, 1);
        cursor += 1;
        if (sign !== "-" && sign !== "+") {
          return "";
        }
        const sds = readDecimalDigits(text, cursor);
        if (sds === "") {
          return "";
        }
        return sign + sds;
      }
      function readExponentPart(text, cursor) {
        const e = text.substr(cursor, 1);
        cursor += 1;
        if (e.toLowerCase() !== "e") {
          return "";
        }
        const si = readSignedInteger(text, cursor);
        if (si === "") {
          return "";
        }
        return e + si;
      }
      function readDecimalIntegerLiteral(text, cursor) {
        const ch = text.substr(cursor, 1);
        if (ch === "0") {
          return ch;
        }
        const nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;
        if (nzd === "") {
          return "";
        }
        return nzd + readDecimalDigits(text, cursor);
      }
      function readDecimalLiteral1(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === "") {
          return "";
        }
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== ".") {
          return "";
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
      }
      function readDecimalLiteral2(text, cursor) {
        const dot = text.substr(cursor, 1);
        cursor += dot.length;
        if (dot !== ".") {
          return "";
        }
        const dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        if (dds === "") {
          return "";
        }
        return dot + dds + readExponentPart(text, cursor);
      }
      function readDecimalLiteral3(text, cursor) {
        const dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;
        if (dil === "") {
          return "";
        }
        return dil + readExponentPart(text, cursor);
      }
      const readDecimalLiteral = combineReader([
        readDecimalLiteral1,
        readDecimalLiteral2,
        readDecimalLiteral3
      ]);
      function parseBinaryDigits(text, cursor) {
        var _a;
        const m2 = text.substr(cursor).match(/^[01]+/);
        return (_a = m2 && m2[0]) !== null && _a !== void 0 ? _a : "";
      }
      function readBinaryIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0b") {
          return "";
        }
        const bds = parseBinaryDigits(text, cursor);
        if (bds === "") {
          return "";
        }
        return prefix + bds;
      }
      function readOctalDigits(text, cursor) {
        var _a;
        const m2 = text.substr(cursor).match(/^[0-7]+/);
        return (_a = m2 && m2[0]) !== null && _a !== void 0 ? _a : "";
      }
      function readOctalIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0o") {
          return "";
        }
        const ods = readOctalDigits(text, cursor);
        if (ods === "") {
          return "";
        }
        return prefix + ods;
      }
      function readHexDigits(text, cursor) {
        var _a;
        const m2 = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a = m2 && m2[0]) !== null && _a !== void 0 ? _a : "";
      }
      function readHexIntegerLiteral(text, cursor) {
        const prefix = text.substr(cursor, 2);
        cursor += prefix.length;
        if (prefix.toLowerCase() !== "0x") {
          return "";
        }
        const hds = readHexDigits(text, cursor);
        if (hds === "") {
          return "";
        }
        return prefix + hds;
      }
      const readNonDecimalIntegerLiteral = combineReader([
        readBinaryIntegerLiteral,
        readOctalIntegerLiteral,
        readHexIntegerLiteral
      ]);
      const readNumericLiteral = combineReader([
        readNonDecimalIntegerLiteral,
        readDecimalLiteral
      ]);
      function parseLiteral(text, cursor) {
        const num = readNumericLiteral(text, cursor);
        cursor += num.length;
        if (num === "") {
          return null;
        }
        return {
          evaluable: new NumberLiteralNode(num),
          cursor
        };
      }
      function parseParenthesizedExpression(text, cursor) {
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== "(") {
          return null;
        }
        const expr = parseExpression(text, cursor);
        if (!expr) {
          return null;
        }
        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        const cl = text.substr(cursor, 1);
        cursor += cl.length;
        if (cl !== ")") {
          return null;
        }
        return {
          evaluable: expr.evaluable,
          cursor
        };
      }
      function parsePrimaryExpression(text, cursor) {
        var _a;
        return (_a = parseLiteral(text, cursor)) !== null && _a !== void 0 ? _a : parseParenthesizedExpression(text, cursor);
      }
      function parseUnaryExpression(text, cursor) {
        const expr = parsePrimaryExpression(text, cursor);
        if (expr) {
          return expr;
        }
        const op = text.substr(cursor, 1);
        cursor += op.length;
        if (op !== "+" && op !== "-" && op !== "~") {
          return null;
        }
        const num = parseUnaryExpression(text, cursor);
        if (!num) {
          return null;
        }
        cursor = num.cursor;
        return {
          cursor,
          evaluable: new UnaryOperationNode(op, num.evaluable)
        };
      }
      function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
        if (!op) {
          return null;
        }
        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
          cursor,
          operator: op
        };
      }
      function createBinaryOperationExpressionParser(exprParser, ops) {
        return (text, cursor) => {
          const firstExpr = exprParser(text, cursor);
          if (!firstExpr) {
            return null;
          }
          cursor = firstExpr.cursor;
          let expr = firstExpr.evaluable;
          for (; ; ) {
            const op = readBinaryOperator(ops, text, cursor);
            if (!op) {
              break;
            }
            cursor = op.cursor;
            const nextExpr = exprParser(text, cursor);
            if (!nextExpr) {
              return null;
            }
            cursor = nextExpr.cursor;
            expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
          }
          return expr ? {
            cursor,
            evaluable: expr
          } : null;
        };
      }
      const parseBinaryOperationExpression = [
        ["**"],
        ["*", "/", "%"],
        ["+", "-"],
        ["<<", ">>>", ">>"],
        ["&"],
        ["^"],
        ["|"]
      ].reduce((parser, ops) => {
        return createBinaryOperationExpressionParser(parser, ops);
      }, parseUnaryExpression);
      function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
      }
      function parseEcmaNumberExpression(text) {
        const expr = parseExpression(text, 0);
        if (!expr) {
          return null;
        }
        const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
        if (cursor !== text.length) {
          return null;
        }
        return expr.evaluable;
      }
      function parseNumber(text) {
        var _a;
        const r = parseEcmaNumberExpression(text);
        return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
      }
      function numberFromUnknown(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          const pv = parseNumber(value);
          if (!isEmpty(pv)) {
            return pv;
          }
        }
        return 0;
      }
      function numberToString(value) {
        return String(value);
      }
      function createNumberFormatter(digits) {
        return (value) => {
          return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
      }
      const innerFormatter = createNumberFormatter(0);
      function formatPercentage(value) {
        return innerFormatter(value) + "%";
      }
      function stringFromUnknown(value) {
        return String(value);
      }
      function formatString(value) {
        return value;
      }
      function connectValues({ primary, secondary, forward, backward }) {
        let changing = false;
        function preventFeedback(callback) {
          if (changing) {
            return;
          }
          changing = true;
          callback();
          changing = false;
        }
        primary.emitter.on("change", (ev) => {
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        secondary.emitter.on("change", (ev) => {
          preventFeedback(() => {
            primary.setRawValue(backward(primary, secondary), ev.options);
          });
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        preventFeedback(() => {
          secondary.setRawValue(forward(primary, secondary), {
            forceEmit: false,
            last: true
          });
        });
      }
      function getStepForKey(baseStep, keys) {
        const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
        if (keys.upKey) {
          return +step;
        } else if (keys.downKey) {
          return -step;
        }
        return 0;
      }
      function getVerticalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === "ArrowDown",
          shiftKey: ev.shiftKey,
          upKey: ev.key === "ArrowUp"
        };
      }
      function getHorizontalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === "ArrowLeft",
          shiftKey: ev.shiftKey,
          upKey: ev.key === "ArrowRight"
        };
      }
      function isVerticalArrowKey(key2) {
        return key2 === "ArrowUp" || key2 === "ArrowDown";
      }
      function isArrowKey(key2) {
        return isVerticalArrowKey(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight";
      }
      function computeOffset$1(ev, elem) {
        var _a, _b;
        const win = elem.ownerDocument.defaultView;
        const rect = elem.getBoundingClientRect();
        return {
          x: ev.pageX - (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) + rect.left),
          y: ev.pageY - (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) + rect.top)
        };
      }
      class PointerHandler {
        constructor(element2) {
          this.lastTouch_ = null;
          this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
          this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
          this.onMouseDown_ = this.onMouseDown_.bind(this);
          this.onTouchEnd_ = this.onTouchEnd_.bind(this);
          this.onTouchMove_ = this.onTouchMove_.bind(this);
          this.onTouchStart_ = this.onTouchStart_.bind(this);
          this.elem_ = element2;
          this.emitter = new Emitter();
          element2.addEventListener("touchstart", this.onTouchStart_, {
            passive: false
          });
          element2.addEventListener("touchmove", this.onTouchMove_, {
            passive: true
          });
          element2.addEventListener("touchend", this.onTouchEnd_);
          element2.addEventListener("mousedown", this.onMouseDown_);
        }
        computePosition_(offset) {
          const rect = this.elem_.getBoundingClientRect();
          return {
            bounds: {
              width: rect.width,
              height: rect.height
            },
            point: offset ? {
              x: offset.x,
              y: offset.y
            } : null
          };
        }
        onMouseDown_(ev) {
          var _a;
          ev.preventDefault();
          (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
          const doc = this.elem_.ownerDocument;
          doc.addEventListener("mousemove", this.onDocumentMouseMove_);
          doc.addEventListener("mouseup", this.onDocumentMouseUp_);
          this.emitter.emit("down", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onDocumentMouseMove_(ev) {
          this.emitter.emit("move", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onDocumentMouseUp_(ev) {
          const doc = this.elem_.ownerDocument;
          doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
          doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
          this.emitter.emit("up", {
            altKey: ev.altKey,
            data: this.computePosition_(computeOffset$1(ev, this.elem_)),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
        onTouchStart_(ev) {
          ev.preventDefault();
          const touch = ev.targetTouches.item(0);
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("down", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
          this.lastTouch_ = touch;
        }
        onTouchMove_(ev) {
          const touch = ev.targetTouches.item(0);
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("move", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
          this.lastTouch_ = touch;
        }
        onTouchEnd_(ev) {
          var _a;
          const touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
          const rect = this.elem_.getBoundingClientRect();
          this.emitter.emit("up", {
            altKey: ev.altKey,
            data: this.computePosition_(touch ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
            } : void 0),
            sender: this,
            shiftKey: ev.shiftKey
          });
        }
      }
      function mapRange(value, start1, end1, start2, end2) {
        const p = (value - start1) / (end1 - start1);
        return start2 + p * (end2 - start2);
      }
      function getDecimalDigits(value) {
        const text = String(value.toFixed(10));
        const frac = text.split(".")[1];
        return frac.replace(/0+$/, "").length;
      }
      function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      function loopRange(value, max) {
        return (value % max + max) % max;
      }
      const className$g = ClassName("txt");
      class NumberTextView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$g(), className$g(void 0, "num"));
          if (config.arrayPosition) {
            this.element.classList.add(className$g(void 0, config.arrayPosition));
          }
          config.viewProps.bindClassModifiers(this.element);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$g("i"));
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          this.onDraggingChange_ = this.onDraggingChange_.bind(this);
          this.dragging_ = config.dragging;
          this.dragging_.emitter.on("change", this.onDraggingChange_);
          this.element.classList.add(className$g());
          this.inputElement.classList.add(className$g("i"));
          const knobElem = doc.createElement("div");
          knobElem.classList.add(className$g("k"));
          this.element.appendChild(knobElem);
          this.knobElement = knobElem;
          const guideElem = doc.createElementNS(SVG_NS, "svg");
          guideElem.classList.add(className$g("g"));
          this.knobElement.appendChild(guideElem);
          const bodyElem = doc.createElementNS(SVG_NS, "path");
          bodyElem.classList.add(className$g("gb"));
          guideElem.appendChild(bodyElem);
          this.guideBodyElem_ = bodyElem;
          const headElem = doc.createElementNS(SVG_NS, "path");
          headElem.classList.add(className$g("gh"));
          guideElem.appendChild(headElem);
          this.guideHeadElem_ = headElem;
          const tooltipElem = doc.createElement("div");
          tooltipElem.classList.add(ClassName("tt")());
          this.knobElement.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on("change", this.onChange_);
          this.value = config.value;
          this.refresh();
        }
        onDraggingChange_(ev) {
          if (ev.rawValue === null) {
            this.element.classList.remove(className$g(void 0, "drg"));
            return;
          }
          this.element.classList.add(className$g(void 0, "drg"));
          const x = ev.rawValue / this.props_.get("draggingScale");
          const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
          const adx = constrainRange(-aox, -4, 4);
          this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(" "));
          this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
          const formatter = this.props_.get("formatter");
          this.tooltipElem_.textContent = formatter(this.value.rawValue);
          this.tooltipElem_.style.left = `${x}px`;
        }
        refresh() {
          const formatter = this.props_.get("formatter");
          this.inputElement.value = formatter(this.value.rawValue);
        }
        onChange_() {
          this.refresh();
        }
      }
      class NumberTextController {
        constructor(doc, config) {
          var _a;
          this.originRawValue_ = 0;
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
          this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.parser_ = config.parser;
          this.props = config.props;
          this.sliderProps_ = (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.dragging_ = createValue(null);
          this.view = new NumberTextView(doc, {
            arrayPosition: config.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
          this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
          this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
          const ph = new PointerHandler(this.view.knobElement);
          ph.emitter.on("down", this.onPointerDown_);
          ph.emitter.on("move", this.onPointerMove_);
          ph.emitter.on("up", this.onPointerUp_);
        }
        constrainValue_(value) {
          var _a, _b;
          const min = (_a = this.sliderProps_) === null || _a === void 0 ? void 0 : _a.get("minValue");
          const max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get("maxValue");
          let v4 = value;
          if (min !== void 0) {
            v4 = Math.max(v4, min);
          }
          if (max !== void 0) {
            v4 = Math.min(v4, max);
          }
          return v4;
        }
        onInputChange_(e) {
          const inputElem = forceCast(e.currentTarget);
          const value = inputElem.value;
          const parsedValue = this.parser_(value);
          if (!isEmpty(parsedValue)) {
            this.value.rawValue = this.constrainValue_(parsedValue);
          }
          this.view.refresh();
        }
        onInputKeyDown_(ev) {
          const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
            forceEmit: false,
            last: false
          });
        }
        onInputKeyUp_(ev) {
          const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
        onPointerDown_() {
          this.originRawValue_ = this.value.rawValue;
          this.dragging_.rawValue = 0;
        }
        computeDraggingValue_(data) {
          if (!data.point) {
            return null;
          }
          const dx = data.point.x - data.bounds.width / 2;
          return this.constrainValue_(this.originRawValue_ + dx * this.props.get("draggingScale"));
        }
        onPointerMove_(ev) {
          const v4 = this.computeDraggingValue_(ev.data);
          if (v4 === null) {
            return;
          }
          this.value.setRawValue(v4, {
            forceEmit: false,
            last: false
          });
          this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
        }
        onPointerUp_(ev) {
          const v4 = this.computeDraggingValue_(ev.data);
          if (v4 === null) {
            return;
          }
          this.value.setRawValue(v4, {
            forceEmit: true,
            last: true
          });
          this.dragging_.rawValue = null;
        }
      }
      const className$f = ClassName("sld");
      class SliderView {
        constructor(doc, config) {
          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on("change", this.onChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$f());
          config.viewProps.bindClassModifiers(this.element);
          const trackElem = doc.createElement("div");
          trackElem.classList.add(className$f("t"));
          config.viewProps.bindTabIndex(trackElem);
          this.element.appendChild(trackElem);
          this.trackElement = trackElem;
          const knobElem = doc.createElement("div");
          knobElem.classList.add(className$f("k"));
          this.trackElement.appendChild(knobElem);
          this.knobElement = knobElem;
          config.value.emitter.on("change", this.onChange_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const p = constrainRange(mapRange(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
          this.knobElement.style.width = `${p}%`;
        }
        onChange_() {
          this.update_();
        }
      }
      class SliderController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.props = config.props;
          this.view = new SliderView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.trackElement);
          this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
          this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), opts);
        }
        onPointerDownOrMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue + step, {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$e = ClassName("sldtxt");
      class SliderTextView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$e());
          const sliderElem = doc.createElement("div");
          sliderElem.classList.add(className$e("s"));
          this.sliderView_ = config.sliderView;
          sliderElem.appendChild(this.sliderView_.element);
          this.element.appendChild(sliderElem);
          const textElem = doc.createElement("div");
          textElem.classList.add(className$e("t"));
          this.textView_ = config.textView;
          textElem.appendChild(this.textView_.element);
          this.element.appendChild(textElem);
        }
      }
      class SliderTextController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.sliderC_ = new SliderController(doc, {
            baseStep: config.baseStep,
            props: config.sliderProps,
            value: config.value,
            viewProps: this.viewProps
          });
          this.textC_ = new NumberTextController(doc, {
            baseStep: config.baseStep,
            parser: config.parser,
            props: config.textProps,
            sliderProps: config.sliderProps,
            value: config.value,
            viewProps: config.viewProps
          });
          this.view = new SliderTextView(doc, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
          });
        }
        get sliderController() {
          return this.sliderC_;
        }
        get textController() {
          return this.textC_;
        }
      }
      function writePrimitive(target, value) {
        target.write(value);
      }
      function parseListOptions(value) {
        const p = ParamsParsers;
        if (Array.isArray(value)) {
          return p.required.array(p.required.object({
            text: p.required.string,
            value: p.required.raw
          }))(value).value;
        }
        if (typeof value === "object") {
          return p.required.raw(value).value;
        }
        return void 0;
      }
      function parsePickerLayout(value) {
        if (value === "inline" || value === "popup") {
          return value;
        }
        return void 0;
      }
      function parsePointDimensionParams(value) {
        const p = ParamsParsers;
        return p.required.object({
          max: p.optional.number,
          min: p.optional.number,
          step: p.optional.number
        })(value).value;
      }
      function normalizeListOptions(options) {
        if (Array.isArray(options)) {
          return options;
        }
        const items = [];
        Object.keys(options).forEach((text) => {
          items.push({ text, value: options[text] });
        });
        return items;
      }
      function createListConstraint(options) {
        return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
      }
      function findStep(constraint) {
        const c = constraint ? findConstraint(constraint, StepConstraint) : null;
        if (!c) {
          return null;
        }
        return c.step;
      }
      function getSuitableDecimalDigits(constraint, rawValue) {
        const sc = constraint && findConstraint(constraint, StepConstraint);
        if (sc) {
          return getDecimalDigits(sc.step);
        }
        return Math.max(getDecimalDigits(rawValue), 2);
      }
      function getBaseStep(constraint) {
        const step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
      }
      function getSuitableDraggingScale(constraint, rawValue) {
        var _a;
        const sc = constraint && findConstraint(constraint, StepConstraint);
        const base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
      }
      const className$d = ClassName("ckb");
      class CheckboxView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className$d());
          config.viewProps.bindClassModifiers(this.element);
          const labelElem = doc.createElement("label");
          labelElem.classList.add(className$d("l"));
          this.element.appendChild(labelElem);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$d("i"));
          inputElem.type = "checkbox";
          labelElem.appendChild(inputElem);
          this.inputElement = inputElem;
          config.viewProps.bindDisabled(this.inputElement);
          const wrapperElem = doc.createElement("div");
          wrapperElem.classList.add(className$d("w"));
          labelElem.appendChild(wrapperElem);
          const markElem = createSvgIconElement(doc, "check");
          wrapperElem.appendChild(markElem);
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class CheckboxController {
        constructor(doc, config) {
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new CheckboxView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener("change", this.onInputChange_);
        }
        onInputChange_(e) {
          const inputElem = forceCast(e.currentTarget);
          this.value.rawValue = inputElem.checked;
        }
      }
      function createConstraint$6(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
          constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
      }
      const BooleanInputPlugin = {
        id: "input-bool",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "boolean") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            options: p.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => boolFromUnknown,
          constraint: (args) => createConstraint$6(args.params),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c = args.constraint;
          const lc = c && findConstraint(c, ListConstraint);
          if (lc) {
            return new ListController(doc, {
              props: new ValueMap({
                options: lc.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new CheckboxController(doc, {
            value,
            viewProps: args.viewProps
          });
        }
      };
      const className$c = ClassName("col");
      class ColorView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$c());
          config.foldable.bindExpandedClass(this.element, className$c(void 0, "expanded"));
          bindValueMap(config.foldable, "completed", valueToClassName(this.element, className$c(void 0, "cpl")));
          const headElem = doc.createElement("div");
          headElem.classList.add(className$c("h"));
          this.element.appendChild(headElem);
          const swatchElem = doc.createElement("div");
          swatchElem.classList.add(className$c("s"));
          headElem.appendChild(swatchElem);
          this.swatchElement = swatchElem;
          const textElem = doc.createElement("div");
          textElem.classList.add(className$c("t"));
          headElem.appendChild(textElem);
          this.textElement = textElem;
          if (config.pickerLayout === "inline") {
            const pickerElem = doc.createElement("div");
            pickerElem.classList.add(className$c("p"));
            this.element.appendChild(pickerElem);
            this.pickerElement = pickerElem;
          } else {
            this.pickerElement = null;
          }
        }
      }
      function rgbToHslInt(r, g, b2) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g / 255, 0, 1);
        const bp = constrainRange(b2 / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const c = cmax - cmin;
        let h = 0;
        let s = 0;
        const l = (cmin + cmax) / 2;
        if (c !== 0) {
          s = c / (1 - Math.abs(cmax + cmin - 1));
          if (rp === cmax) {
            h = (gp - bp) / c;
          } else if (gp === cmax) {
            h = 2 + (bp - rp) / c;
          } else {
            h = 4 + (rp - gp) / c;
          }
          h = h / 6 + (h < 0 ? 1 : 0);
        }
        return [h * 360, s * 100, l * 100];
      }
      function hslToRgbInt(h, s, l) {
        const hp = (h % 360 + 360) % 360;
        const sp = constrainRange(s / 100, 0, 1);
        const lp = constrainRange(l / 100, 0, 1);
        const c = (1 - Math.abs(2 * lp - 1)) * sp;
        const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
        const m2 = lp - c / 2;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
          [rp, gp, bp] = [c, x, 0];
        } else if (hp >= 60 && hp < 120) {
          [rp, gp, bp] = [x, c, 0];
        } else if (hp >= 120 && hp < 180) {
          [rp, gp, bp] = [0, c, x];
        } else if (hp >= 180 && hp < 240) {
          [rp, gp, bp] = [0, x, c];
        } else if (hp >= 240 && hp < 300) {
          [rp, gp, bp] = [x, 0, c];
        } else {
          [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m2) * 255, (gp + m2) * 255, (bp + m2) * 255];
      }
      function rgbToHsvInt(r, g, b2) {
        const rp = constrainRange(r / 255, 0, 1);
        const gp = constrainRange(g / 255, 0, 1);
        const bp = constrainRange(b2 / 255, 0, 1);
        const cmax = Math.max(rp, gp, bp);
        const cmin = Math.min(rp, gp, bp);
        const d = cmax - cmin;
        let h;
        if (d === 0) {
          h = 0;
        } else if (cmax === rp) {
          h = 60 * (((gp - bp) / d % 6 + 6) % 6);
        } else if (cmax === gp) {
          h = 60 * ((bp - rp) / d + 2);
        } else {
          h = 60 * ((rp - gp) / d + 4);
        }
        const s = cmax === 0 ? 0 : d / cmax;
        const v4 = cmax;
        return [h, s * 100, v4 * 100];
      }
      function hsvToRgbInt(h, s, v4) {
        const hp = loopRange(h, 360);
        const sp = constrainRange(s / 100, 0, 1);
        const vp = constrainRange(v4 / 100, 0, 1);
        const c = vp * sp;
        const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
        const m2 = vp - c;
        let rp, gp, bp;
        if (hp >= 0 && hp < 60) {
          [rp, gp, bp] = [c, x, 0];
        } else if (hp >= 60 && hp < 120) {
          [rp, gp, bp] = [x, c, 0];
        } else if (hp >= 120 && hp < 180) {
          [rp, gp, bp] = [0, c, x];
        } else if (hp >= 180 && hp < 240) {
          [rp, gp, bp] = [0, x, c];
        } else if (hp >= 240 && hp < 300) {
          [rp, gp, bp] = [x, 0, c];
        } else {
          [rp, gp, bp] = [c, 0, x];
        }
        return [(rp + m2) * 255, (gp + m2) * 255, (bp + m2) * 255];
      }
      function hslToHsvInt(h, s, l) {
        const sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);
        return [
          h,
          sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0,
          l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)
        ];
      }
      function hsvToHslInt(h, s, v4) {
        const sd = 100 - Math.abs(v4 * (200 - s) / 100 - 100);
        return [h, sd !== 0 ? s * v4 / sd : 0, v4 * (200 - s) / (2 * 100)];
      }
      function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
      }
      function appendAlphaComponent(comps, alpha) {
        return [comps[0], comps[1], comps[2], alpha];
      }
      const MODE_CONVERTER_MAP = {
        hsl: {
          hsl: (h, s, l) => [h, s, l],
          hsv: hslToHsvInt,
          rgb: hslToRgbInt
        },
        hsv: {
          hsl: hsvToHslInt,
          hsv: (h, s, v4) => [h, s, v4],
          rgb: hsvToRgbInt
        },
        rgb: {
          hsl: rgbToHslInt,
          hsv: rgbToHsvInt,
          rgb: (r, g, b2) => [r, g, b2]
        }
      };
      function getColorMaxComponents(mode, type) {
        return [
          type === "float" ? 1 : mode === "rgb" ? 255 : 360,
          type === "float" ? 1 : mode === "rgb" ? 255 : 100,
          type === "float" ? 1 : mode === "rgb" ? 255 : 100
        ];
      }
      function loopHueRange(hue, max) {
        return hue === max ? max : loopRange(hue, max);
      }
      function constrainColorComponents(components, mode, type) {
        var _a;
        const ms = getColorMaxComponents(mode, type);
        return [
          mode === "rgb" ? constrainRange(components[0], 0, ms[0]) : loopHueRange(components[0], ms[0]),
          constrainRange(components[1], 0, ms[1]),
          constrainRange(components[2], 0, ms[2]),
          constrainRange((_a = components[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
        ];
      }
      function convertColorType(comps, mode, from2, to) {
        const fms = getColorMaxComponents(mode, from2);
        const tms = getColorMaxComponents(mode, to);
        return comps.map((c, index) => c / fms[index] * tms[index]);
      }
      function convertColor(components, from2, to) {
        const intComps = convertColorType(components, from2.mode, from2.type, "int");
        const result = MODE_CONVERTER_MAP[from2.mode][to.mode](...intComps);
        return convertColorType(result, to.mode, "int", to.type);
      }
      function isRgbColorComponent(obj, key2) {
        if (typeof obj !== "object" || isEmpty(obj)) {
          return false;
        }
        return key2 in obj && typeof obj[key2] === "number";
      }
      class Color12 {
        static black(type = "int") {
          return new Color12([0, 0, 0], "rgb", type);
        }
        static fromObject(obj, type = "int") {
          const comps = "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
          return new Color12(comps, "rgb", type);
        }
        static toRgbaObject(color, type = "int") {
          return color.toRgbaObject(type);
        }
        static isRgbColorObject(obj) {
          return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
        }
        static isRgbaColorObject(obj) {
          return this.isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
        }
        static isColorObject(obj) {
          return this.isRgbColorObject(obj);
        }
        static equals(v12, v22) {
          if (v12.mode !== v22.mode) {
            return false;
          }
          const comps1 = v12.comps_;
          const comps2 = v22.comps_;
          for (let i = 0; i < comps1.length; i++) {
            if (comps1[i] !== comps2[i]) {
              return false;
            }
          }
          return true;
        }
        constructor(comps, mode, type = "int") {
          this.mode = mode;
          this.type = type;
          this.comps_ = constrainColorComponents(comps, mode, type);
        }
        getComponents(opt_mode, type = "int") {
          return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type }), this.comps_[3]);
        }
        toRgbaObject(type = "int") {
          const rgbComps = this.getComponents("rgb", type);
          return {
            r: rgbComps[0],
            g: rgbComps[1],
            b: rgbComps[2],
            a: rgbComps[3]
          };
        }
      }
      const className$b = ClassName("colp");
      class ColorPickerView {
        constructor(doc, config) {
          this.alphaViews_ = null;
          this.element = doc.createElement("div");
          this.element.classList.add(className$b());
          config.viewProps.bindClassModifiers(this.element);
          const hsvElem = doc.createElement("div");
          hsvElem.classList.add(className$b("hsv"));
          const svElem = doc.createElement("div");
          svElem.classList.add(className$b("sv"));
          this.svPaletteView_ = config.svPaletteView;
          svElem.appendChild(this.svPaletteView_.element);
          hsvElem.appendChild(svElem);
          const hElem = doc.createElement("div");
          hElem.classList.add(className$b("h"));
          this.hPaletteView_ = config.hPaletteView;
          hElem.appendChild(this.hPaletteView_.element);
          hsvElem.appendChild(hElem);
          this.element.appendChild(hsvElem);
          const rgbElem = doc.createElement("div");
          rgbElem.classList.add(className$b("rgb"));
          this.textView_ = config.textView;
          rgbElem.appendChild(this.textView_.element);
          this.element.appendChild(rgbElem);
          if (config.alphaViews) {
            this.alphaViews_ = {
              palette: config.alphaViews.palette,
              text: config.alphaViews.text
            };
            const aElem = doc.createElement("div");
            aElem.classList.add(className$b("a"));
            const apElem = doc.createElement("div");
            apElem.classList.add(className$b("ap"));
            apElem.appendChild(this.alphaViews_.palette.element);
            aElem.appendChild(apElem);
            const atElem = doc.createElement("div");
            atElem.classList.add(className$b("at"));
            atElem.appendChild(this.alphaViews_.text.element);
            aElem.appendChild(atElem);
            this.element.appendChild(aElem);
          }
        }
        get allFocusableElements() {
          const elems = [
            this.svPaletteView_.element,
            this.hPaletteView_.element,
            this.textView_.modeSelectElement,
            ...this.textView_.textViews.map((v4) => v4.inputElement)
          ];
          if (this.alphaViews_) {
            elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
          }
          return elems;
        }
      }
      function parseColorType(value) {
        return value === "int" ? "int" : value === "float" ? "float" : void 0;
      }
      function parseColorInputParams(params) {
        const p = ParamsParsers;
        return parseParams(params, {
          alpha: p.optional.boolean,
          color: p.optional.object({
            alpha: p.optional.boolean,
            type: p.optional.custom(parseColorType)
          }),
          expanded: p.optional.boolean,
          picker: p.optional.custom(parsePickerLayout)
        });
      }
      function getBaseStepForColor(forAlpha) {
        return forAlpha ? 0.1 : 1;
      }
      function extractColorType(params) {
        var _a;
        return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
      }
      function equalsStringColorFormat(f1, f2) {
        return f1.alpha === f2.alpha && f1.mode === f2.mode && f1.notation === f2.notation && f1.type === f2.type;
      }
      function parseCssNumberOrPercentage(text, maxValue) {
        const m2 = text.match(/^(.+)%$/);
        if (!m2) {
          return Math.min(parseFloat(text), maxValue);
        }
        return Math.min(parseFloat(m2[1]) * 0.01 * maxValue, maxValue);
      }
      const ANGLE_TO_DEG_MAP = {
        deg: (angle) => angle,
        grad: (angle) => angle * 360 / 400,
        rad: (angle) => angle * 360 / (2 * Math.PI),
        turn: (angle) => angle * 360
      };
      function parseCssNumberOrAngle(text) {
        const m2 = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
        if (!m2) {
          return parseFloat(text);
        }
        const angle = parseFloat(m2[1]);
        const unit = m2[2];
        return ANGLE_TO_DEG_MAP[unit](angle);
      }
      function parseFunctionalRgbColorComponents(text) {
        const m2 = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m2) {
          return null;
        }
        const comps = [
          parseCssNumberOrPercentage(m2[1], 255),
          parseCssNumberOrPercentage(m2[2], 255),
          parseCssNumberOrPercentage(m2[3], 255)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createFunctionalRgbColorParser(type) {
        return (text) => {
          const comps = parseFunctionalRgbColorComponents(text);
          return comps ? new Color12(comps, "rgb", type) : null;
        };
      }
      function parseFunctionalRgbaColorComponents(text) {
        const m2 = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m2) {
          return null;
        }
        const comps = [
          parseCssNumberOrPercentage(m2[1], 255),
          parseCssNumberOrPercentage(m2[2], 255),
          parseCssNumberOrPercentage(m2[3], 255),
          parseCssNumberOrPercentage(m2[4], 1)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createFunctionalRgbaColorParser(type) {
        return (text) => {
          const comps = parseFunctionalRgbaColorComponents(text);
          return comps ? new Color12(comps, "rgb", type) : null;
        };
      }
      function parseHslColorComponents(text) {
        const m2 = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m2) {
          return null;
        }
        const comps = [
          parseCssNumberOrAngle(m2[1]),
          parseCssNumberOrPercentage(m2[2], 100),
          parseCssNumberOrPercentage(m2[3], 100)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createHslColorParser(type) {
        return (text) => {
          const comps = parseHslColorComponents(text);
          return comps ? new Color12(comps, "hsl", type) : null;
        };
      }
      function parseHslaColorComponents(text) {
        const m2 = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
        if (!m2) {
          return null;
        }
        const comps = [
          parseCssNumberOrAngle(m2[1]),
          parseCssNumberOrPercentage(m2[2], 100),
          parseCssNumberOrPercentage(m2[3], 100),
          parseCssNumberOrPercentage(m2[4], 1)
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createHslaColorParser(type) {
        return (text) => {
          const comps = parseHslaColorComponents(text);
          return comps ? new Color12(comps, "hsl", type) : null;
        };
      }
      function parseHexRgbColorComponents(text) {
        const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
          return [
            parseInt(mRgb[1] + mRgb[1], 16),
            parseInt(mRgb[2] + mRgb[2], 16),
            parseInt(mRgb[3] + mRgb[3], 16)
          ];
        }
        const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
          return [
            parseInt(mRrggbb[1], 16),
            parseInt(mRrggbb[2], 16),
            parseInt(mRrggbb[3], 16)
          ];
        }
        return null;
      }
      function parseHexRgbColor(text) {
        const comps = parseHexRgbColorComponents(text);
        return comps ? new Color12(comps, "rgb", "int") : null;
      }
      function parseHexRgbaColorComponents(text) {
        const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
        if (mRgb) {
          return [
            parseInt(mRgb[1] + mRgb[1], 16),
            parseInt(mRgb[2] + mRgb[2], 16),
            parseInt(mRgb[3] + mRgb[3], 16),
            mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
          ];
        }
        const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
        if (mRrggbb) {
          return [
            parseInt(mRrggbb[1], 16),
            parseInt(mRrggbb[2], 16),
            parseInt(mRrggbb[3], 16),
            mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
          ];
        }
        return null;
      }
      function parseHexRgbaColor(text) {
        const comps = parseHexRgbaColorComponents(text);
        return comps ? new Color12(comps, "rgb", "int") : null;
      }
      function parseObjectRgbColorComponents(text) {
        const m2 = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m2) {
          return null;
        }
        const comps = [
          parseFloat(m2[1]),
          parseFloat(m2[2]),
          parseFloat(m2[3])
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }
        return comps;
      }
      function createObjectRgbColorParser(type) {
        return (text) => {
          const comps = parseObjectRgbColorComponents(text);
          return comps ? new Color12(comps, "rgb", type) : null;
        };
      }
      function parseObjectRgbaColorComponents(text) {
        const m2 = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
        if (!m2) {
          return null;
        }
        const comps = [
          parseFloat(m2[1]),
          parseFloat(m2[2]),
          parseFloat(m2[3]),
          parseFloat(m2[4])
        ];
        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }
        return comps;
      }
      function createObjectRgbaColorParser(type) {
        return (text) => {
          const comps = parseObjectRgbaColorComponents(text);
          return comps ? new Color12(comps, "rgb", type) : null;
        };
      }
      const PARSER_AND_RESULT = [
        {
          parser: parseHexRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: parseHexRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "hex"
          }
        },
        {
          parser: parseFunctionalRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: parseFunctionalRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "func"
          }
        },
        {
          parser: parseHslColorComponents,
          result: {
            alpha: false,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: parseHslaColorComponents,
          result: {
            alpha: true,
            mode: "hsl",
            notation: "func"
          }
        },
        {
          parser: parseObjectRgbColorComponents,
          result: {
            alpha: false,
            mode: "rgb",
            notation: "object"
          }
        },
        {
          parser: parseObjectRgbaColorComponents,
          result: {
            alpha: true,
            mode: "rgb",
            notation: "object"
          }
        }
      ];
      function detectStringColor(text) {
        return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
          if (prev) {
            return prev;
          }
          return parser(text) ? detection : null;
        }, null);
      }
      function detectStringColorFormat(text, type = "int") {
        const r = detectStringColor(text);
        if (!r) {
          return null;
        }
        if (r.notation === "hex" && type !== "float") {
          return Object.assign(Object.assign({}, r), { type: "int" });
        }
        if (r.notation === "func") {
          return Object.assign(Object.assign({}, r), { type });
        }
        return null;
      }
      const TYPE_TO_PARSERS = {
        int: [
          parseHexRgbColor,
          parseHexRgbaColor,
          createFunctionalRgbColorParser("int"),
          createFunctionalRgbaColorParser("int"),
          createHslColorParser("int"),
          createHslaColorParser("int"),
          createObjectRgbColorParser("int"),
          createObjectRgbaColorParser("int")
        ],
        float: [
          createFunctionalRgbColorParser("float"),
          createFunctionalRgbaColorParser("float"),
          createHslColorParser("float"),
          createHslaColorParser("float"),
          createObjectRgbColorParser("float"),
          createObjectRgbaColorParser("float")
        ]
      };
      function createColorStringBindingReader(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
          if (typeof value !== "string") {
            return Color12.black(type);
          }
          const result = parsers.reduce((prev, parser) => {
            if (prev) {
              return prev;
            }
            return parser(value);
          }, null);
          return result !== null && result !== void 0 ? result : Color12.black(type);
        };
      }
      function createColorStringParser(type) {
        const parsers = TYPE_TO_PARSERS[type];
        return (value) => {
          return parsers.reduce((prev, parser) => {
            if (prev) {
              return prev;
            }
            return parser(value);
          }, null);
        };
      }
      function zerofill(comp) {
        const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      }
      function colorToHexRgbString(value, prefix = "#") {
        const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
        return `${prefix}${hexes}`;
      }
      function colorToHexRgbaString(value, prefix = "#") {
        const rgbaComps = value.getComponents("rgb");
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
        return `${prefix}${hexes}`;
      }
      function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents("rgb", opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(", ")})`;
      }
      function createFunctionalRgbColorFormatter(type) {
        return (value) => {
          return colorToFunctionalRgbString(value, type);
        };
      }
      function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
        const comps = value.getComponents("rgb", opt_type).map((comp, index) => {
          const formatter = index === 3 ? aFormatter : rgbFormatter;
          return formatter(comp);
        });
        return `rgba(${comps.join(", ")})`;
      }
      function createFunctionalRgbaColorFormatter(type) {
        return (value) => {
          return colorToFunctionalRgbaString(value, type);
        };
      }
      function colorToFunctionalHslString(value) {
        const formatters = [
          createNumberFormatter(0),
          formatPercentage,
          formatPercentage
        ];
        const comps = removeAlphaComponent(value.getComponents("hsl")).map((comp, index) => formatters[index](comp));
        return `hsl(${comps.join(", ")})`;
      }
      function colorToFunctionalHslaString(value) {
        const formatters = [
          createNumberFormatter(0),
          formatPercentage,
          formatPercentage,
          createNumberFormatter(2)
        ];
        const comps = value.getComponents("hsl").map((comp, index) => formatters[index](comp));
        return `hsla(${comps.join(", ")})`;
      }
      function colorToObjectRgbString(value, type) {
        const formatter = createNumberFormatter(type === "float" ? 2 : 0);
        const names = ["r", "g", "b"];
        const comps = removeAlphaComponent(value.getComponents("rgb", type)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
        return `{${comps.join(", ")}}`;
      }
      function createObjectRgbColorFormatter(type) {
        return (value) => colorToObjectRgbString(value, type);
      }
      function colorToObjectRgbaString(value, type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type === "float" ? 2 : 0);
        const names = ["r", "g", "b", "a"];
        const comps = value.getComponents("rgb", type).map((comp, index) => {
          const formatter = index === 3 ? aFormatter : rgbFormatter;
          return `${names[index]}: ${formatter(comp)}`;
        });
        return `{${comps.join(", ")}}`;
      }
      function createObjectRgbaColorFormatter(type) {
        return (value) => colorToObjectRgbaString(value, type);
      }
      const FORMAT_AND_STRINGIFIERS = [
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: colorToHexRgbString
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "hex",
            type: "int"
          },
          stringifier: colorToHexRgbaString
        },
        {
          format: {
            alpha: false,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: colorToFunctionalHslString
        },
        {
          format: {
            alpha: true,
            mode: "hsl",
            notation: "func",
            type: "int"
          },
          stringifier: colorToFunctionalHslaString
        },
        ...["int", "float"].reduce((prev, type) => {
          return [
            ...prev,
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "func",
                type
              },
              stringifier: createFunctionalRgbColorFormatter(type)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "func",
                type
              },
              stringifier: createFunctionalRgbaColorFormatter(type)
            },
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "object",
                type
              },
              stringifier: createObjectRgbColorFormatter(type)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "object",
                type
              },
              stringifier: createObjectRgbaColorFormatter(type)
            }
          ];
        }, [])
      ];
      function findColorStringifier(format) {
        return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
          if (prev) {
            return prev;
          }
          return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;
        }, null);
      }
      const className$a = ClassName("apl");
      class APaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$a());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          const barElem = doc.createElement("div");
          barElem.classList.add(className$a("b"));
          this.element.appendChild(barElem);
          const colorElem = doc.createElement("div");
          colorElem.classList.add(className$a("c"));
          barElem.appendChild(colorElem);
          this.colorElem_ = colorElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$a("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          const previewElem = doc.createElement("div");
          previewElem.classList.add(className$a("p"));
          this.markerElem_.appendChild(previewElem);
          this.previewElem_ = previewElem;
          this.update_();
        }
        update_() {
          const c = this.value.rawValue;
          const rgbaComps = c.getComponents("rgb");
          const leftColor = new Color12([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
          const rightColor = new Color12([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
          const gradientComps = [
            "to right",
            colorToFunctionalRgbaString(leftColor),
            colorToFunctionalRgbaString(rightColor)
          ];
          this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
          this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
          const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
          this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class APaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new APaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const alpha = d.point.x / d.bounds.width;
          const c = this.value.rawValue;
          const [h, s, v4] = c.getComponents("hsv");
          this.value.setRawValue(new Color12([h, s, v4, alpha], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          const c = this.value.rawValue;
          const [h, s, v4, a] = c.getComponents("hsv");
          this.value.setRawValue(new Color12([h, s, v4, a + step], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$9 = ClassName("coltxt");
      function createModeSelectElement(doc) {
        const selectElem = doc.createElement("select");
        const items = [
          { text: "RGB", value: "rgb" },
          { text: "HSL", value: "hsl" },
          { text: "HSV", value: "hsv" }
        ];
        selectElem.appendChild(items.reduce((frag, item) => {
          const optElem = doc.createElement("option");
          optElem.textContent = item.text;
          optElem.value = item.value;
          frag.appendChild(optElem);
          return frag;
        }, doc.createDocumentFragment()));
        return selectElem;
      }
      class ColorTextView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$9());
          config.viewProps.bindClassModifiers(this.element);
          const modeElem = doc.createElement("div");
          modeElem.classList.add(className$9("m"));
          this.modeElem_ = createModeSelectElement(doc);
          this.modeElem_.classList.add(className$9("ms"));
          modeElem.appendChild(this.modeSelectElement);
          config.viewProps.bindDisabled(this.modeElem_);
          const modeMarkerElem = doc.createElement("div");
          modeMarkerElem.classList.add(className$9("mm"));
          modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
          modeElem.appendChild(modeMarkerElem);
          this.element.appendChild(modeElem);
          const textsElem = doc.createElement("div");
          textsElem.classList.add(className$9("w"));
          this.element.appendChild(textsElem);
          this.textsElem_ = textsElem;
          this.textViews_ = config.textViews;
          this.applyTextViews_();
          bindValue(config.colorMode, (mode) => {
            this.modeElem_.value = mode;
          });
        }
        get modeSelectElement() {
          return this.modeElem_;
        }
        get textViews() {
          return this.textViews_;
        }
        set textViews(textViews) {
          this.textViews_ = textViews;
          this.applyTextViews_();
        }
        applyTextViews_() {
          removeChildElements(this.textsElem_);
          const doc = this.element.ownerDocument;
          this.textViews_.forEach((v4) => {
            const compElem = doc.createElement("div");
            compElem.classList.add(className$9("c"));
            compElem.appendChild(v4.element);
            this.textsElem_.appendChild(compElem);
          });
        }
      }
      function createFormatter$2(type) {
        return createNumberFormatter(type === "float" ? 2 : 0);
      }
      function createConstraint$5(mode, type, index) {
        const max = getColorMaxComponents(mode, type)[index];
        return new DefiniteRangeConstraint({
          min: 0,
          max
        });
      }
      function createComponentController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
          baseStep: getBaseStepForColor(false),
          parser: config.parser,
          props: ValueMap.fromObject({
            draggingScale: config.colorType === "float" ? 0.01 : 1,
            formatter: createFormatter$2(config.colorType)
          }),
          value: createValue(0, {
            constraint: createConstraint$5(config.colorMode, config.colorType, index)
          }),
          viewProps: config.viewProps
        });
      }
      class ColorTextController {
        constructor(doc, config) {
          this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
          this.colorType_ = config.colorType;
          this.parser_ = config.parser;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.colorMode = createValue(this.value.rawValue.mode);
          this.ccs_ = this.createComponentControllers_(doc);
          this.view = new ColorTextView(doc, {
            colorMode: this.colorMode,
            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            viewProps: this.viewProps
          });
          this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
        }
        createComponentControllers_(doc) {
          const cc = {
            colorMode: this.colorMode.rawValue,
            colorType: this.colorType_,
            parser: this.parser_,
            viewProps: this.viewProps
          };
          const ccs = [
            createComponentController(doc, cc, 0),
            createComponentController(doc, cc, 1),
            createComponentController(doc, cc, 2)
          ];
          ccs.forEach((cs, index) => {
            connectValues({
              primary: this.value,
              secondary: cs.value,
              forward: (p) => {
                return p.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[index];
              },
              backward: (p, s) => {
                const pickedMode = this.colorMode.rawValue;
                const comps = p.rawValue.getComponents(pickedMode, this.colorType_);
                comps[index] = s.rawValue;
                return new Color12(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, this.colorType_);
              }
            });
          });
          return ccs;
        }
        onModeSelectChange_(ev) {
          const selectElem = ev.currentTarget;
          this.colorMode.rawValue = selectElem.value;
          this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
          this.view.textViews = [
            this.ccs_[0].view,
            this.ccs_[1].view,
            this.ccs_[2].view
          ];
        }
      }
      const className$8 = ClassName("hpl");
      class HPaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$8());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          const colorElem = doc.createElement("div");
          colorElem.classList.add(className$8("c"));
          this.element.appendChild(colorElem);
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$8("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }
        update_() {
          const c = this.value.rawValue;
          const [h] = c.getComponents("hsv");
          this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color12([h, 100, 100], "hsv"));
          const left = mapRange(h, 0, 360, 0, 100);
          this.markerElem_.style.left = `${left}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class HPaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new HPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 360);
          const c = this.value.rawValue;
          const [, s, v4, a] = c.getComponents("hsv");
          this.value.setRawValue(new Color12([hue, s, v4, a], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          const c = this.value.rawValue;
          const [h, s, v4, a] = c.getComponents("hsv");
          this.value.setRawValue(new Color12([h + step, s, v4, a], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
          if (step === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      const className$7 = ClassName("svp");
      const CANVAS_RESOL = 64;
      class SvPaletteView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on("change", this.onValueChange_);
          this.element = doc.createElement("div");
          this.element.classList.add(className$7());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          const canvasElem = doc.createElement("canvas");
          canvasElem.height = CANVAS_RESOL;
          canvasElem.width = CANVAS_RESOL;
          canvasElem.classList.add(className$7("c"));
          this.element.appendChild(canvasElem);
          this.canvasElement = canvasElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$7("m"));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }
        update_() {
          const ctx = getCanvasContext(this.canvasElement);
          if (!ctx) {
            return;
          }
          const c = this.value.rawValue;
          const hsvComps = c.getComponents("hsv");
          const width2 = this.canvasElement.width;
          const height2 = this.canvasElement.height;
          const imgData = ctx.getImageData(0, 0, width2, height2);
          const data = imgData.data;
          for (let iy = 0; iy < height2; iy++) {
            for (let ix = 0; ix < width2; ix++) {
              const s = mapRange(ix, 0, width2, 0, 100);
              const v4 = mapRange(iy, 0, height2, 100, 0);
              const rgbComps = hsvToRgbInt(hsvComps[0], s, v4);
              const i = (iy * width2 + ix) * 4;
              data[i] = rgbComps[0];
              data[i + 1] = rgbComps[1];
              data[i + 2] = rgbComps[2];
              data[i + 3] = 255;
            }
          }
          ctx.putImageData(imgData, 0, 0);
          const left = mapRange(hsvComps[1], 0, 100, 0, 100);
          this.markerElem_.style.left = `${left}%`;
          const top = mapRange(hsvComps[2], 0, 100, 100, 0);
          this.markerElem_.style.top = `${top}%`;
        }
        onValueChange_() {
          this.update_();
        }
      }
      class SvPaletteController {
        constructor(doc, config) {
          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SvPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.element.addEventListener("keydown", this.onKeyDown_);
          this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
          const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);
          const [h, , , a] = this.value.rawValue.getComponents("hsv");
          this.value.setRawValue(new Color12([h, saturation, value, a], "hsv"), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onKeyDown_(ev) {
          if (isArrowKey(ev.key)) {
            ev.preventDefault();
          }
          const [h, s, v4, a] = this.value.rawValue.getComponents("hsv");
          const baseStep = getBaseStepForColor(false);
          const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
          const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
          if (ds === 0 && dv === 0) {
            return;
          }
          this.value.setRawValue(new Color12([h, s + ds, v4 + dv, a], "hsv"), {
            forceEmit: false,
            last: false
          });
        }
        onKeyUp_(ev) {
          const baseStep = getBaseStepForColor(false);
          const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
          const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
          if (ds === 0 && dv === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      class ColorPickerController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.hPaletteC_ = new HPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.svPaletteC_ = new SvPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.alphaIcs_ = config.supportsAlpha ? {
            palette: new APaletteController(doc, {
              value: this.value,
              viewProps: this.viewProps
            }),
            text: new NumberTextController(doc, {
              parser: parseNumber,
              baseStep: 0.1,
              props: ValueMap.fromObject({
                draggingScale: 0.01,
                formatter: createNumberFormatter(2)
              }),
              value: createValue(0, {
                constraint: new DefiniteRangeConstraint({ min: 0, max: 1 })
              }),
              viewProps: this.viewProps
            })
          } : null;
          if (this.alphaIcs_) {
            connectValues({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: (p) => {
                return p.rawValue.getComponents()[3];
              },
              backward: (p, s) => {
                const comps = p.rawValue.getComponents();
                comps[3] = s.rawValue;
                return new Color12(comps, p.rawValue.mode);
              }
            });
          }
          this.textC_ = new ColorTextController(doc, {
            colorType: config.colorType,
            parser: parseNumber,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorPickerView(doc, {
            alphaViews: this.alphaIcs_ ? {
              palette: this.alphaIcs_.palette.view,
              text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: config.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view,
            viewProps: this.viewProps
          });
        }
        get textController() {
          return this.textC_;
        }
      }
      const className$6 = ClassName("colsw");
      class ColorSwatchView {
        constructor(doc, config) {
          this.onValueChange_ = this.onValueChange_.bind(this);
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.element = doc.createElement("div");
          this.element.classList.add(className$6());
          config.viewProps.bindClassModifiers(this.element);
          const swatchElem = doc.createElement("div");
          swatchElem.classList.add(className$6("sw"));
          this.element.appendChild(swatchElem);
          this.swatchElem_ = swatchElem;
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$6("b"));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          this.update_();
        }
        update_() {
          const value = this.value.rawValue;
          this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
        }
        onValueChange_() {
          this.update_();
        }
      }
      class ColorSwatchController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ColorSwatchView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      class ColorController {
        constructor(doc, config) {
          this.onButtonBlur_ = this.onButtonBlur_.bind(this);
          this.onButtonClick_ = this.onButtonClick_.bind(this);
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.swatchC_ = new ColorSwatchController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          const buttonElem = this.swatchC_.view.buttonElement;
          buttonElem.addEventListener("blur", this.onButtonBlur_);
          buttonElem.addEventListener("click", this.onButtonClick_);
          this.textC_ = new TextController(doc, {
            parser: config.parser,
            props: ValueMap.fromObject({
              formatter: config.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorView(doc, {
            foldable: this.foldable_,
            pickerLayout: config.pickerLayout
          });
          this.view.swatchElement.appendChild(this.swatchC_.view.element);
          this.view.textElement.appendChild(this.textC_.view.element);
          this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          const pickerC = new ColorPickerController(doc, {
            colorType: config.colorType,
            supportsAlpha: config.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
          });
          pickerC.view.allFocusableElements.forEach((elem) => {
            elem.addEventListener("blur", this.onPopupChildBlur_);
            elem.addEventListener("keydown", this.onPopupChildKeydown_);
          });
          this.pickerC_ = pickerC;
          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(pickerC.view.element);
            connectValues({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (p) => p.rawValue,
              backward: (_, s) => s.rawValue
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }
        get textController() {
          return this.textC_;
        }
        onButtonBlur_(e) {
          if (!this.popC_) {
            return;
          }
          const elem = this.view.element;
          const nextTarget = forceCast(e.relatedTarget);
          if (!nextTarget || !elem.contains(nextTarget)) {
            this.popC_.shows.rawValue = false;
          }
        }
        onButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded"));
          if (this.foldable_.get("expanded")) {
            this.pickerC_.view.allFocusableElements[0].focus();
          }
        }
        onPopupChildBlur_(ev) {
          if (!this.popC_) {
            return;
          }
          const elem = this.popC_.view.element;
          const nextTarget = findNextTarget(ev);
          if (nextTarget && elem.contains(nextTarget)) {
            return;
          }
          if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
            return;
          }
          this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
          if (this.popC_) {
            if (ev.key === "Escape") {
              this.popC_.shows.rawValue = false;
            }
          } else if (this.view.pickerElement) {
            if (ev.key === "Escape") {
              this.swatchC_.view.buttonElement.focus();
            }
          }
        }
      }
      function colorFromObject(value, opt_type) {
        if (Color12.isColorObject(value)) {
          return Color12.fromObject(value, opt_type);
        }
        return Color12.black(opt_type);
      }
      function colorToRgbNumber(value) {
        return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
          return result << 8 | Math.floor(comp) & 255;
        }, 0);
      }
      function colorToRgbaNumber(value) {
        return value.getComponents("rgb").reduce((result, comp, index) => {
          const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
          return result << 8 | hex;
        }, 0) >>> 0;
      }
      function numberToRgbColor(num) {
        return new Color12([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
      }
      function numberToRgbaColor(num) {
        return new Color12([
          num >> 24 & 255,
          num >> 16 & 255,
          num >> 8 & 255,
          mapRange(num & 255, 0, 255, 0, 1)
        ], "rgb");
      }
      function colorFromRgbNumber(value) {
        if (typeof value !== "number") {
          return Color12.black();
        }
        return numberToRgbColor(value);
      }
      function colorFromRgbaNumber(value) {
        if (typeof value !== "number") {
          return Color12.black();
        }
        return numberToRgbaColor(value);
      }
      function createColorStringWriter(format) {
        const stringify = findColorStringifier(format);
        return stringify ? (target, value) => {
          writePrimitive(target, stringify(value));
        } : null;
      }
      function createColorNumberWriter(supportsAlpha) {
        const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
        return (target, value) => {
          writePrimitive(target, colorToNumber(value));
        };
      }
      function writeRgbaColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty("r", obj.r);
        target.writeProperty("g", obj.g);
        target.writeProperty("b", obj.b);
        target.writeProperty("a", obj.a);
      }
      function writeRgbColorObject(target, value, opt_type) {
        const obj = value.toRgbaObject(opt_type);
        target.writeProperty("r", obj.r);
        target.writeProperty("g", obj.g);
        target.writeProperty("b", obj.b);
      }
      function createColorObjectWriter(supportsAlpha, opt_type) {
        return (target, inValue) => {
          if (supportsAlpha) {
            writeRgbaColorObject(target, inValue, opt_type);
          } else {
            writeRgbColorObject(target, inValue, opt_type);
          }
        };
      }
      function shouldSupportAlpha$1(inputParams) {
        var _a;
        if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a === void 0 ? void 0 : _a.alpha)) {
          return true;
        }
        return false;
      }
      function createFormatter$1(supportsAlpha) {
        return supportsAlpha ? (v4) => colorToHexRgbaString(v4, "0x") : (v4) => colorToHexRgbString(v4, "0x");
      }
      function isForColor(params) {
        if ("color" in params) {
          return true;
        }
        if ("view" in params && params.view === "color") {
          return true;
        }
        return false;
      }
      const NumberColorInputPlugin = {
        id: "input-color-number",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          if (!isForColor(params)) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => {
            return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
          },
          equals: Color12.equals,
          writer: (args) => {
            return createColorNumberWriter(shouldSupportAlpha$1(args.params));
          }
        },
        controller: (args) => {
          const supportsAlpha = shouldSupportAlpha$1(args.params);
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new ColorController(args.document, {
            colorType: "int",
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createFormatter$1(supportsAlpha),
            parser: createColorStringParser("int"),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      function shouldSupportAlpha(initialValue) {
        return Color12.isRgbaColorObject(initialValue);
      }
      function createColorObjectReader(opt_type) {
        return (value) => {
          return colorFromObject(value, opt_type);
        };
      }
      function createColorObjectFormatter(supportsAlpha, type) {
        return (value) => {
          if (supportsAlpha) {
            return colorToObjectRgbaString(value, type);
          }
          return colorToObjectRgbString(value, type);
        };
      }
      const ObjectColorInputPlugin = {
        id: "input-color-object",
        type: "input",
        accept: (value, params) => {
          if (!Color12.isColorObject(value)) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => createColorObjectReader(extractColorType(args.params)),
          equals: Color12.equals,
          writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params))
        },
        controller: (args) => {
          var _a;
          const supportsAlpha = Color12.isRgbaColorObject(args.initialValue);
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          const type = (_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : "int";
          return new ColorController(args.document, {
            colorType: type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createColorObjectFormatter(supportsAlpha, type),
            parser: createColorStringParser(type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      const StringColorInputPlugin = {
        id: "input-color-string",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          if ("view" in params && params.view === "text") {
            return null;
          }
          const format = detectStringColorFormat(value, extractColorType(params));
          if (!format) {
            return null;
          }
          const stringifier = findColorStringifier(format);
          if (!stringifier) {
            return null;
          }
          const result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (args) => {
            var _a;
            return createColorStringBindingReader((_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : "int");
          },
          equals: Color12.equals,
          writer: (args) => {
            const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
            if (!format) {
              throw TpError.shouldNeverHappen();
            }
            const writer = createColorStringWriter(format);
            if (!writer) {
              throw TpError.notBindable();
            }
            return writer;
          }
        },
        controller: (args) => {
          const format = detectStringColorFormat(args.initialValue, extractColorType(args.params));
          if (!format) {
            throw TpError.shouldNeverHappen();
          }
          const stringifier = findColorStringifier(format);
          if (!stringifier) {
            throw TpError.shouldNeverHappen();
          }
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new ColorController(args.document, {
            colorType: format.type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: stringifier,
            parser: createColorStringParser(format.type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            supportsAlpha: format.alpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      class PointNdConstraint {
        constructor(config) {
          this.components = config.components;
          this.asm_ = config.assembly;
        }
        constrain(value) {
          const comps = this.asm_.toComponents(value).map((comp, index) => {
            var _a, _b;
            return (_b = (_a = this.components[index]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
          });
          return this.asm_.fromComponents(comps);
        }
      }
      const className$5 = ClassName("pndtxt");
      class PointNdTextView {
        constructor(doc, config) {
          this.textViews = config.textViews;
          this.element = doc.createElement("div");
          this.element.classList.add(className$5());
          this.textViews.forEach((v4) => {
            const axisElem = doc.createElement("div");
            axisElem.classList.add(className$5("a"));
            axisElem.appendChild(v4.element);
            this.element.appendChild(axisElem);
          });
        }
      }
      function createAxisController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
          baseStep: config.axes[index].baseStep,
          parser: config.parser,
          props: config.axes[index].textProps,
          value: createValue(0, {
            constraint: config.axes[index].constraint
          }),
          viewProps: config.viewProps
        });
      }
      class PointNdTextController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));
          this.acs_.forEach((c, index) => {
            connectValues({
              primary: this.value,
              secondary: c.value,
              forward: (p) => {
                return config.assembly.toComponents(p.rawValue)[index];
              },
              backward: (p, s) => {
                const comps = config.assembly.toComponents(p.rawValue);
                comps[index] = s.rawValue;
                return config.assembly.fromComponents(comps);
              }
            });
          });
          this.view = new PointNdTextView(doc, {
            textViews: this.acs_.map((ac) => ac.view)
          });
        }
      }
      function createStepConstraint(params, initialValue) {
        if ("step" in params && !isEmpty(params.step)) {
          return new StepConstraint(params.step, initialValue);
        }
        return null;
      }
      function createRangeConstraint(params) {
        if (!isEmpty(params.max) && !isEmpty(params.min)) {
          return new DefiniteRangeConstraint({
            max: params.max,
            min: params.min
          });
        }
        if (!isEmpty(params.max) || !isEmpty(params.min)) {
          return new RangeConstraint({
            max: params.max,
            min: params.min
          });
        }
        return null;
      }
      function findNumberRange(c) {
        const drc = findConstraint(c, DefiniteRangeConstraint);
        if (drc) {
          return [drc.values.get("min"), drc.values.get("max")];
        }
        const rc = findConstraint(c, RangeConstraint);
        if (rc) {
          return [rc.minValue, rc.maxValue];
        }
        return [void 0, void 0];
      }
      function createConstraint$4(params, initialValue) {
        const constraints = [];
        const sc = createStepConstraint(params, initialValue);
        if (sc) {
          constraints.push(sc);
        }
        const rc = createRangeConstraint(params);
        if (rc) {
          constraints.push(rc);
        }
        const lc = createListConstraint(params.options);
        if (lc) {
          constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
      }
      const NumberInputPlugin = {
        id: "input-number",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            format: p.optional.function,
            max: p.optional.number,
            min: p.optional.number,
            options: p.optional.custom(parseListOptions),
            step: p.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => numberFromUnknown,
          constraint: (args) => createConstraint$4(args.params, args.initialValue),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          var _a;
          const value = args.value;
          const c = args.constraint;
          const lc = c && findConstraint(c, ListConstraint);
          if (lc) {
            return new ListController(args.document, {
              props: new ValueMap({
                options: lc.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
          }
          const formatter = (_a = "format" in args.params ? args.params.format : void 0) !== null && _a !== void 0 ? _a : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
          const drc = c && findConstraint(c, DefiniteRangeConstraint);
          if (drc) {
            return new SliderTextController(args.document, {
              baseStep: getBaseStep(c),
              parser: parseNumber,
              sliderProps: new ValueMap({
                maxValue: drc.values.value("max"),
                minValue: drc.values.value("min")
              }),
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(c, value.rawValue),
                formatter
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new NumberTextController(args.document, {
            baseStep: getBaseStep(c),
            parser: parseNumber,
            props: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(c, value.rawValue),
              formatter
            }),
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point2d {
        constructor(x = 0, y2 = 0) {
          this.x = x;
          this.y = y2;
        }
        getComponents() {
          return [this.x, this.y];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x = obj.x;
          const y2 = obj.y;
          if (typeof x !== "number" || typeof y2 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v12, v22) {
          return v12.x === v22.x && v12.y === v22.y;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y
          };
        }
      }
      const Point2dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point2d(...comps)
      };
      const className$4 = ClassName("p2d");
      class Point2dView {
        constructor(doc, config) {
          this.element = doc.createElement("div");
          this.element.classList.add(className$4());
          config.viewProps.bindClassModifiers(this.element);
          bindValue(config.expanded, valueToClassName(this.element, className$4(void 0, "expanded")));
          const headElem = doc.createElement("div");
          headElem.classList.add(className$4("h"));
          this.element.appendChild(headElem);
          const buttonElem = doc.createElement("button");
          buttonElem.classList.add(className$4("b"));
          buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
          config.viewProps.bindDisabled(buttonElem);
          headElem.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          const textElem = doc.createElement("div");
          textElem.classList.add(className$4("t"));
          headElem.appendChild(textElem);
          this.textElement = textElem;
          if (config.pickerLayout === "inline") {
            const pickerElem = doc.createElement("div");
            pickerElem.classList.add(className$4("p"));
            this.element.appendChild(pickerElem);
            this.pickerElement = pickerElem;
          } else {
            this.pickerElement = null;
          }
        }
      }
      const className$3 = ClassName("p2dp");
      class Point2dPickerView {
        constructor(doc, config) {
          this.onFoldableChange_ = this.onFoldableChange_.bind(this);
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.invertsY_ = config.invertsY;
          this.maxValue_ = config.maxValue;
          this.element = doc.createElement("div");
          this.element.classList.add(className$3());
          if (config.layout === "popup") {
            this.element.classList.add(className$3(void 0, "p"));
          }
          config.viewProps.bindClassModifiers(this.element);
          const padElem = doc.createElement("div");
          padElem.classList.add(className$3("p"));
          config.viewProps.bindTabIndex(padElem);
          this.element.appendChild(padElem);
          this.padElement = padElem;
          const svgElem = doc.createElementNS(SVG_NS, "svg");
          svgElem.classList.add(className$3("g"));
          this.padElement.appendChild(svgElem);
          this.svgElem_ = svgElem;
          const xAxisElem = doc.createElementNS(SVG_NS, "line");
          xAxisElem.classList.add(className$3("ax"));
          xAxisElem.setAttributeNS(null, "x1", "0");
          xAxisElem.setAttributeNS(null, "y1", "50%");
          xAxisElem.setAttributeNS(null, "x2", "100%");
          xAxisElem.setAttributeNS(null, "y2", "50%");
          this.svgElem_.appendChild(xAxisElem);
          const yAxisElem = doc.createElementNS(SVG_NS, "line");
          yAxisElem.classList.add(className$3("ax"));
          yAxisElem.setAttributeNS(null, "x1", "50%");
          yAxisElem.setAttributeNS(null, "y1", "0");
          yAxisElem.setAttributeNS(null, "x2", "50%");
          yAxisElem.setAttributeNS(null, "y2", "100%");
          this.svgElem_.appendChild(yAxisElem);
          const lineElem = doc.createElementNS(SVG_NS, "line");
          lineElem.classList.add(className$3("l"));
          lineElem.setAttributeNS(null, "x1", "50%");
          lineElem.setAttributeNS(null, "y1", "50%");
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          const markerElem = doc.createElement("div");
          markerElem.classList.add(className$3("m"));
          this.padElement.appendChild(markerElem);
          this.markerElem_ = markerElem;
          config.value.emitter.on("change", this.onValueChange_);
          this.value = config.value;
          this.update_();
        }
        get allFocusableElements() {
          return [this.padElement];
        }
        update_() {
          const [x, y2] = this.value.rawValue.getComponents();
          const max = this.maxValue_;
          const px = mapRange(x, -max, +max, 0, 100);
          const py = mapRange(y2, -max, +max, 0, 100);
          const ipy = this.invertsY_ ? 100 - py : py;
          this.lineElem_.setAttributeNS(null, "x2", `${px}%`);
          this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
          this.markerElem_.style.left = `${px}%`;
          this.markerElem_.style.top = `${ipy}%`;
        }
        onValueChange_() {
          this.update_();
        }
        onFoldableChange_() {
          this.update_();
        }
      }
      function computeOffset(ev, baseSteps, invertsY) {
        return [
          getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
          getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
        ];
      }
      class Point2dPickerController {
        constructor(doc, config) {
          this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
          this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.baseSteps_ = config.baseSteps;
          this.maxValue_ = config.maxValue;
          this.invertsY_ = config.invertsY;
          this.view = new Point2dPickerView(doc, {
            invertsY: this.invertsY_,
            layout: config.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.padElement);
          this.ptHandler_.emitter.on("down", this.onPointerDown_);
          this.ptHandler_.emitter.on("move", this.onPointerMove_);
          this.ptHandler_.emitter.on("up", this.onPointerUp_);
          this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
          this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
        }
        handlePointerEvent_(d, opts) {
          if (!d.point) {
            return;
          }
          const max = this.maxValue_;
          const px = mapRange(d.point.x, 0, d.bounds.width, -max, +max);
          const py = mapRange(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
          this.value.setRawValue(new Point2d(px, py), opts);
        }
        onPointerDown_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerMove_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: false,
            last: false
          });
        }
        onPointerUp_(ev) {
          this.handlePointerEvent_(ev.data, {
            forceEmit: true,
            last: true
          });
        }
        onPadKeyDown_(ev) {
          if (isArrowKey(ev.key)) {
            ev.preventDefault();
          }
          const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
          if (dx === 0 && dy === 0) {
            return;
          }
          this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
            forceEmit: false,
            last: false
          });
        }
        onPadKeyUp_(ev) {
          const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
          if (dx === 0 && dy === 0) {
            return;
          }
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: true,
            last: true
          });
        }
      }
      class Point2dController {
        constructor(doc, config) {
          var _a, _b;
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
          this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          const padC = new Point2dPickerController(doc, {
            baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
            invertsY: config.invertsY,
            layout: config.pickerLayout,
            maxValue: config.maxValue,
            value: this.value,
            viewProps: this.viewProps
          });
          padC.view.allFocusableElements.forEach((elem) => {
            elem.addEventListener("blur", this.onPopupChildBlur_);
            elem.addEventListener("keydown", this.onPopupChildKeydown_);
          });
          this.pickerC_ = padC;
          this.textC_ = new PointNdTextController(doc, {
            assembly: Point2dAssembly,
            axes: config.axes,
            parser: config.parser,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new Point2dView(doc, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: config.pickerLayout,
            viewProps: this.viewProps
          });
          this.view.textElement.appendChild(this.textC_.view.element);
          (_a = this.view.buttonElement) === null || _a === void 0 ? void 0 : _a.addEventListener("blur", this.onPadButtonBlur_);
          (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener("click", this.onPadButtonClick_);
          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(this.pickerC_.view.element);
            connectValues({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (p) => p.rawValue,
              backward: (_, s) => s.rawValue
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }
        onPadButtonBlur_(e) {
          if (!this.popC_) {
            return;
          }
          const elem = this.view.element;
          const nextTarget = forceCast(e.relatedTarget);
          if (!nextTarget || !elem.contains(nextTarget)) {
            this.popC_.shows.rawValue = false;
          }
        }
        onPadButtonClick_() {
          this.foldable_.set("expanded", !this.foldable_.get("expanded"));
          if (this.foldable_.get("expanded")) {
            this.pickerC_.view.allFocusableElements[0].focus();
          }
        }
        onPopupChildBlur_(ev) {
          if (!this.popC_) {
            return;
          }
          const elem = this.popC_.view.element;
          const nextTarget = findNextTarget(ev);
          if (nextTarget && elem.contains(nextTarget)) {
            return;
          }
          if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
            return;
          }
          this.popC_.shows.rawValue = false;
        }
        onPopupChildKeydown_(ev) {
          if (this.popC_) {
            if (ev.key === "Escape") {
              this.popC_.shows.rawValue = false;
            }
          } else if (this.view.pickerElement) {
            if (ev.key === "Escape") {
              this.view.buttonElement.focus();
            }
          }
        }
      }
      class Point3d {
        constructor(x = 0, y2 = 0, z2 = 0) {
          this.x = x;
          this.y = y2;
          this.z = z2;
        }
        getComponents() {
          return [this.x, this.y, this.z];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x = obj.x;
          const y2 = obj.y;
          const z2 = obj.z;
          if (typeof x !== "number" || typeof y2 !== "number" || typeof z2 !== "number") {
            return false;
          }
          return true;
        }
        static equals(v12, v22) {
          return v12.x === v22.x && v12.y === v22.y && v12.z === v22.z;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z
          };
        }
      }
      const Point3dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point3d(...comps)
      };
      function point3dFromUnknown(value) {
        return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
      }
      function writePoint3d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
        target.writeProperty("z", value.z);
      }
      function createConstraint$3(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point3dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
            createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z)
          ]
        });
      }
      function createAxis$2(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      const Point3dInputPlugin = {
        id: "input-point3d",
        type: "input",
        accept: (value, params) => {
          if (!Point3d.isObject(value)) {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point3dFromUnknown,
          constraint: (args) => createConstraint$3(args.params, args.initialValue),
          equals: Point3d.equals,
          writer: (_args) => writePoint3d
        },
        controller: (args) => {
          const value = args.value;
          const c = args.constraint;
          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          return new PointNdTextController(args.document, {
            assembly: Point3dAssembly,
            axes: [
              createAxis$2(value.rawValue.x, c.components[0]),
              createAxis$2(value.rawValue.y, c.components[1]),
              createAxis$2(value.rawValue.z, c.components[2])
            ],
            parser: parseNumber,
            value,
            viewProps: args.viewProps
          });
        }
      };
      class Point4d {
        constructor(x = 0, y2 = 0, z2 = 0, w = 0) {
          this.x = x;
          this.y = y2;
          this.z = z2;
          this.w = w;
        }
        getComponents() {
          return [this.x, this.y, this.z, this.w];
        }
        static isObject(obj) {
          if (isEmpty(obj)) {
            return false;
          }
          const x = obj.x;
          const y2 = obj.y;
          const z2 = obj.z;
          const w = obj.w;
          if (typeof x !== "number" || typeof y2 !== "number" || typeof z2 !== "number" || typeof w !== "number") {
            return false;
          }
          return true;
        }
        static equals(v12, v22) {
          return v12.x === v22.x && v12.y === v22.y && v12.z === v22.z && v12.w === v22.w;
        }
        toObject() {
          return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
          };
        }
      }
      const Point4dAssembly = {
        toComponents: (p) => p.getComponents(),
        fromComponents: (comps) => new Point4d(...comps)
      };
      function point4dFromUnknown(value) {
        return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
      }
      function writePoint4d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
        target.writeProperty("z", value.z);
        target.writeProperty("w", value.w);
      }
      function createConstraint$2(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point4dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
            createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z),
            createDimensionConstraint("w" in params ? params.w : void 0, initialValue.w)
          ]
        });
      }
      function createAxis$1(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      const Point4dInputPlugin = {
        id: "input-point4d",
        type: "input",
        accept: (value, params) => {
          if (!Point4d.isObject(value)) {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams),
            w: p.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point4dFromUnknown,
          constraint: (args) => createConstraint$2(args.params, args.initialValue),
          equals: Point4d.equals,
          writer: (_args) => writePoint4d
        },
        controller: (args) => {
          const value = args.value;
          const c = args.constraint;
          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          return new PointNdTextController(args.document, {
            assembly: Point4dAssembly,
            axes: value.rawValue.getComponents().map((comp, index) => createAxis$1(comp, c.components[index])),
            parser: parseNumber,
            value,
            viewProps: args.viewProps
          });
        }
      };
      function createConstraint$1(params) {
        const constraints = [];
        const lc = createListConstraint(params.options);
        if (lc) {
          constraints.push(lc);
        }
        return new CompositeConstraint(constraints);
      }
      const StringInputPlugin = {
        id: "input-string",
        type: "input",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            options: p.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => stringFromUnknown,
          constraint: (args) => createConstraint$1(args.params),
          writer: (_args) => writePrimitive
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c = args.constraint;
          const lc = c && findConstraint(c, ListConstraint);
          if (lc) {
            return new ListController(doc, {
              props: new ValueMap({
                options: lc.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
          }
          return new TextController(doc, {
            parser: (v4) => v4,
            props: ValueMap.fromObject({
              formatter: formatString
            }),
            value,
            viewProps: args.viewProps
          });
        }
      };
      const Constants = {
        monitor: {
          defaultInterval: 200,
          defaultLineCount: 3
        }
      };
      const className$2 = ClassName("mll");
      class MultiLogView {
        constructor(doc, config) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement("div");
          this.element.classList.add(className$2());
          config.viewProps.bindClassModifiers(this.element);
          const textareaElem = doc.createElement("textarea");
          textareaElem.classList.add(className$2("i"));
          textareaElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
          textareaElem.readOnly = true;
          config.viewProps.bindDisabled(textareaElem);
          this.element.appendChild(textareaElem);
          this.textareaElem_ = textareaElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const elem = this.textareaElem_;
          const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
          const lines = [];
          this.value.rawValue.forEach((value) => {
            if (value !== void 0) {
              lines.push(this.formatter_(value));
            }
          });
          elem.textContent = lines.join("\n");
          if (shouldScroll) {
            elem.scrollTop = elem.scrollHeight;
          }
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class MultiLogController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new MultiLogView(doc, {
            formatter: config.formatter,
            lineCount: config.lineCount,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const className$1 = ClassName("sgl");
      class SingleLogView {
        constructor(doc, config) {
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement("div");
          this.element.classList.add(className$1());
          config.viewProps.bindClassModifiers(this.element);
          const inputElem = doc.createElement("input");
          inputElem.classList.add(className$1("i"));
          inputElem.readOnly = true;
          inputElem.type = "text";
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        update_() {
          const values = this.value.rawValue;
          const lastValue = values[values.length - 1];
          this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
        }
        onValueUpdate_() {
          this.update_();
        }
      }
      class SingleLogController {
        constructor(doc, config) {
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SingleLogView(doc, {
            formatter: config.formatter,
            value: this.value,
            viewProps: this.viewProps
          });
        }
      }
      const BooleanMonitorPlugin = {
        id: "monitor-bool",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "boolean") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            lineCount: p.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => boolFromUnknown
        },
        controller: (args) => {
          var _a;
          if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
              formatter: BooleanFormatter,
              value: args.value,
              viewProps: args.viewProps
            });
          }
          return new MultiLogController(args.document, {
            formatter: BooleanFormatter,
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      const className = ClassName("grl");
      class GraphLogView {
        constructor(doc, config) {
          this.onCursorChange_ = this.onCursorChange_.bind(this);
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.element = doc.createElement("div");
          this.element.classList.add(className());
          config.viewProps.bindClassModifiers(this.element);
          this.formatter_ = config.formatter;
          this.props_ = config.props;
          this.cursor_ = config.cursor;
          this.cursor_.emitter.on("change", this.onCursorChange_);
          const svgElem = doc.createElementNS(SVG_NS, "svg");
          svgElem.classList.add(className("g"));
          svgElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          const lineElem = doc.createElementNS(SVG_NS, "polyline");
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          const tooltipElem = doc.createElement("div");
          tooltipElem.classList.add(className("t"), ClassName("tt")());
          this.element.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on("change", this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }
        get graphElement() {
          return this.svgElem_;
        }
        update_() {
          const bounds = this.svgElem_.getBoundingClientRect();
          const maxIndex = this.value.rawValue.length - 1;
          const min = this.props_.get("minValue");
          const max = this.props_.get("maxValue");
          const points = [];
          this.value.rawValue.forEach((v4, index) => {
            if (v4 === void 0) {
              return;
            }
            const x = mapRange(index, 0, maxIndex, 0, bounds.width);
            const y2 = mapRange(v4, min, max, bounds.height, 0);
            points.push([x, y2].join(","));
          });
          this.lineElem_.setAttributeNS(null, "points", points.join(" "));
          const tooltipElem = this.tooltipElem_;
          const value = this.value.rawValue[this.cursor_.rawValue];
          if (value === void 0) {
            tooltipElem.classList.remove(className("t", "a"));
            return;
          }
          const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
          const ty = mapRange(value, min, max, bounds.height, 0);
          tooltipElem.style.left = `${tx}px`;
          tooltipElem.style.top = `${ty}px`;
          tooltipElem.textContent = `${this.formatter_(value)}`;
          if (!tooltipElem.classList.contains(className("t", "a"))) {
            tooltipElem.classList.add(className("t", "a"), className("t", "in"));
            forceReflow(tooltipElem);
            tooltipElem.classList.remove(className("t", "in"));
          }
        }
        onValueUpdate_() {
          this.update_();
        }
        onCursorChange_() {
          this.update_();
        }
      }
      class GraphLogController {
        constructor(doc, config) {
          this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
          this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
          this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
          this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
          this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
          this.props_ = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.cursor_ = createValue(-1);
          this.view = new GraphLogView(doc, {
            cursor: this.cursor_,
            formatter: config.formatter,
            lineCount: config.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps
          });
          if (!supportsTouch(doc)) {
            this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
            this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
          } else {
            const ph = new PointerHandler(this.view.element);
            ph.emitter.on("down", this.onGraphPointerDown_);
            ph.emitter.on("move", this.onGraphPointerMove_);
            ph.emitter.on("up", this.onGraphPointerUp_);
          }
        }
        onGraphMouseLeave_() {
          this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(ev) {
          const bounds = this.view.element.getBoundingClientRect();
          this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerDown_(ev) {
          this.onGraphPointerMove_(ev);
        }
        onGraphPointerMove_(ev) {
          if (!ev.data.point) {
            this.cursor_.rawValue = -1;
            return;
          }
          this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
        }
        onGraphPointerUp_() {
          this.cursor_.rawValue = -1;
        }
      }
      function createFormatter(params) {
        return "format" in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
      }
      function createTextMonitor(args) {
        var _a;
        if (args.value.rawValue.length === 1) {
          return new SingleLogController(args.document, {
            formatter: createFormatter(args.params),
            value: args.value,
            viewProps: args.viewProps
          });
        }
        return new MultiLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
          value: args.value,
          viewProps: args.viewProps
        });
      }
      function createGraphMonitor(args) {
        var _a, _b, _c;
        return new GraphLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
          props: ValueMap.fromObject({
            maxValue: (_b = "max" in args.params ? args.params.max : null) !== null && _b !== void 0 ? _b : 100,
            minValue: (_c = "min" in args.params ? args.params.min : null) !== null && _c !== void 0 ? _c : 0
          }),
          value: args.value,
          viewProps: args.viewProps
        });
      }
      function shouldShowGraph(params) {
        return "view" in params && params.view === "graph";
      }
      const NumberMonitorPlugin = {
        id: "monitor-number",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "number") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            format: p.optional.function,
            lineCount: p.optional.number,
            max: p.optional.number,
            min: p.optional.number,
            view: p.optional.string
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
          reader: (_args) => numberFromUnknown
        },
        controller: (args) => {
          if (shouldShowGraph(args.params)) {
            return createGraphMonitor(args);
          }
          return createTextMonitor(args);
        }
      };
      const StringMonitorPlugin = {
        id: "monitor-string",
        type: "monitor",
        accept: (value, params) => {
          if (typeof value !== "string") {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            lineCount: p.optional.number,
            multiline: p.optional.boolean
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => stringFromUnknown
        },
        controller: (args) => {
          var _a;
          const value = args.value;
          const multiline = value.rawValue.length > 1 || "multiline" in args.params && args.params.multiline;
          if (multiline) {
            return new MultiLogController(args.document, {
              formatter: formatString,
              lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
              value,
              viewProps: args.viewProps
            });
          }
          return new SingleLogController(args.document, {
            formatter: formatString,
            value,
            viewProps: args.viewProps
          });
        }
      };
      function createInputBindingController(plugin, args) {
        var _a;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
          return null;
        }
        const p = ParamsParsers;
        const valueArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        const reader = plugin.binding.reader(valueArgs);
        const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
        const value = createValue(reader(result.initialValue), {
          constraint,
          equals: plugin.binding.equals
        });
        const binding = new InputBinding({
          reader,
          target: args.target,
          value,
          writer: plugin.binding.writer(valueArgs)
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
          constraint,
          document: args.document,
          initialValue: result.initialValue,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
        return new InputBindingController(args.document, {
          binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: "label" in args.params ? (_a = p.optional.string(args.params.label).value) !== null && _a !== void 0 ? _a : null : args.target.key
          }),
          valueController: controller
        });
      }
      function createTicker(document2, interval) {
        return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
      }
      function createMonitorBindingController(plugin, args) {
        var _a, _b, _c;
        const p = ParamsParsers;
        const result = plugin.accept(args.target.read(), args.params);
        if (isEmpty(result)) {
          return null;
        }
        const bindingArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        const reader = plugin.binding.reader(bindingArgs);
        const bufferSize = (_b = (_a = p.optional.number(args.params.bufferSize).value) !== null && _a !== void 0 ? _a : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== void 0 ? _b : 1;
        const interval = p.optional.number(args.params.interval).value;
        const binding = new MonitorBinding({
          reader,
          target: args.target,
          ticker: createTicker(args.document, interval),
          value: initializeBuffer(bufferSize)
        });
        const disabled = p.optional.boolean(args.params.disabled).value;
        const hidden = p.optional.boolean(args.params.hidden).value;
        const controller = plugin.controller({
          document: args.document,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled,
            hidden
          })
        });
        return new MonitorBindingController(args.document, {
          binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: "label" in args.params ? (_c = p.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : null : args.target.key
          }),
          valueController: controller
        });
      }
      class PluginPool {
        constructor() {
          this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
          };
        }
        getAll() {
          return [
            ...this.pluginsMap_.blades,
            ...this.pluginsMap_.inputs,
            ...this.pluginsMap_.monitors
          ];
        }
        register(r) {
          if (r.type === "blade") {
            this.pluginsMap_.blades.unshift(r);
          } else if (r.type === "input") {
            this.pluginsMap_.inputs.unshift(r);
          } else if (r.type === "monitor") {
            this.pluginsMap_.monitors.unshift(r);
          }
        }
        createInput(document2, target, params) {
          const initialValue = target.read();
          if (isEmpty(initialValue)) {
            throw new TpError({
              context: {
                key: target.key
              },
              type: "nomatchingcontroller"
            });
          }
          const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
            document: document2,
            target,
            params
          }), null);
          if (bc) {
            return bc;
          }
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        createMonitor(document2, target, params) {
          const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
            document: document2,
            params,
            target
          }), null);
          if (bc) {
            return bc;
          }
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        createBlade(document2, params) {
          const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
            document: document2,
            params
          }), null);
          if (!bc) {
            throw new TpError({
              type: "nomatchingview",
              context: {
                params
              }
            });
          }
          return bc;
        }
        createBladeApi(bc) {
          if (bc instanceof InputBindingController) {
            return new InputBindingApi(bc);
          }
          if (bc instanceof MonitorBindingController) {
            return new MonitorBindingApi(bc);
          }
          if (bc instanceof RackController) {
            return new RackApi(bc, this);
          }
          const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
            controller: bc,
            pool: this
          }), null);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
      }
      function createDefaultPluginPool() {
        const pool = new PluginPool();
        [
          Point2dInputPlugin,
          Point3dInputPlugin,
          Point4dInputPlugin,
          StringInputPlugin,
          NumberInputPlugin,
          StringColorInputPlugin,
          ObjectColorInputPlugin,
          NumberColorInputPlugin,
          BooleanInputPlugin,
          BooleanMonitorPlugin,
          StringMonitorPlugin,
          NumberMonitorPlugin,
          ButtonBladePlugin,
          FolderBladePlugin,
          SeparatorBladePlugin,
          TabBladePlugin
        ].forEach((p) => {
          pool.register(p);
        });
        return pool;
      }
      function point2dFromUnknown(value) {
        return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
      }
      function writePoint2d(target, value) {
        target.writeProperty("x", value.x);
        target.writeProperty("y", value.y);
      }
      function createDimensionConstraint(params, initialValue) {
        if (!params) {
          return void 0;
        }
        const constraints = [];
        const cs = createStepConstraint(params, initialValue);
        if (cs) {
          constraints.push(cs);
        }
        const rs = createRangeConstraint(params);
        if (rs) {
          constraints.push(rs);
        }
        return new CompositeConstraint(constraints);
      }
      function createConstraint(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point2dAssembly,
          components: [
            createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
            createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y)
          ]
        });
      }
      function getSuitableMaxDimensionValue(constraint, rawValue) {
        const [min, max] = constraint ? findNumberRange(constraint) : [];
        if (!isEmpty(min) || !isEmpty(max)) {
          return Math.max(Math.abs(min !== null && min !== void 0 ? min : 0), Math.abs(max !== null && max !== void 0 ? max : 0));
        }
        const step = getBaseStep(constraint);
        return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
      }
      function getSuitableMaxValue(initialValue, constraint) {
        const xc = constraint instanceof PointNdConstraint ? constraint.components[0] : void 0;
        const yc = constraint instanceof PointNdConstraint ? constraint.components[1] : void 0;
        const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
        const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
        return Math.max(xr, yr);
      }
      function createAxis2(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }
      function shouldInvertY(params) {
        if (!("y" in params)) {
          return false;
        }
        const yParams = params.y;
        if (!yParams) {
          return false;
        }
        return "inverted" in yParams ? !!yParams.inverted : false;
      }
      const Point2dInputPlugin = {
        id: "input-point2d",
        type: "input",
        accept: (value, params) => {
          if (!Point2d.isObject(value)) {
            return null;
          }
          const p = ParamsParsers;
          const result = parseParams(params, {
            expanded: p.optional.boolean,
            picker: p.optional.custom(parsePickerLayout),
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.object({
              inverted: p.optional.boolean,
              max: p.optional.number,
              min: p.optional.number,
              step: p.optional.number
            })
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: (_args) => point2dFromUnknown,
          constraint: (args) => createConstraint(args.params, args.initialValue),
          equals: Point2d.equals,
          writer: (_args) => writePoint2d
        },
        controller: (args) => {
          const doc = args.document;
          const value = args.value;
          const c = args.constraint;
          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }
          const expanded = "expanded" in args.params ? args.params.expanded : void 0;
          const picker = "picker" in args.params ? args.params.picker : void 0;
          return new Point2dController(doc, {
            axes: [
              createAxis2(value.rawValue.x, c.components[0]),
              createAxis2(value.rawValue.y, c.components[1])
            ],
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            invertsY: shouldInvertY(args.params),
            maxValue: getSuitableMaxValue(value.rawValue, c),
            parser: parseNumber,
            pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
            value,
            viewProps: args.viewProps
          });
        }
      };
      class ListApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get options() {
          return this.controller_.valueController.props.get("options");
        }
        set options(options) {
          this.controller_.valueController.props.set("options", options);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class SliderApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get maxValue() {
          return this.controller_.valueController.sliderController.props.get("maxValue");
        }
        set maxValue(maxValue) {
          this.controller_.valueController.sliderController.props.set("maxValue", maxValue);
        }
        get minValue() {
          return this.controller_.valueController.sliderController.props.get("minValue");
        }
        set minValue(minValue) {
          this.controller_.valueController.sliderController.props.set("minValue", minValue);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      class TextApi extends BladeApi {
        constructor(controller) {
          super(controller);
          this.emitter_ = new Emitter();
          this.controller_.valueController.value.emitter.on("change", (ev) => {
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, ev.rawValue)
            });
          });
        }
        get label() {
          return this.controller_.props.get("label");
        }
        set label(label) {
          this.controller_.props.set("label", label);
        }
        get formatter() {
          return this.controller_.valueController.props.get("formatter");
        }
        set formatter(formatter) {
          this.controller_.valueController.props.set("formatter", formatter);
        }
        get value() {
          return this.controller_.valueController.value.rawValue;
        }
        set value(value) {
          this.controller_.valueController.value.rawValue = value;
        }
        on(eventName, handler) {
          const bh = handler.bind(this);
          this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
          });
          return this;
        }
      }
      const ListBladePlugin = /* @__PURE__ */ (function() {
        return {
          id: "list",
          type: "blade",
          accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
              options: p.required.custom(parseListOptions),
              value: p.required.raw,
              view: p.required.constant("list"),
              label: p.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            const lc = new ListConstraint(normalizeListOptions(args.params.options));
            const value = createValue(args.params.value, {
              constraint: lc
            });
            const ic = new ListController(args.document, {
              props: new ValueMap({
                options: lc.values.value("options")
              }),
              value,
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof ListController)) {
              return null;
            }
            return new ListApi(args.controller);
          }
        };
      })();
      function exportPresetJson(targets) {
        return targets.reduce((result, target) => {
          return Object.assign(result, {
            [target.presetKey]: target.read()
          });
        }, {});
      }
      function importPresetJson(bindings, preset) {
        bindings.forEach((binding) => {
          const value = preset[binding.target.presetKey];
          if (value !== void 0) {
            binding.writer(binding.target, binding.reader(value));
          }
        });
      }
      class RootApi extends FolderApi {
        /**
         * @hidden
         */
        constructor(controller, pool) {
          super(controller, pool);
        }
        get element() {
          return this.controller_.view.element;
        }
        /**
         * Imports a preset of all inputs.
         * @param preset The preset object to import.
         */
        importPreset(preset) {
          const bindings = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
            return ibc.binding;
          });
          importPresetJson(bindings, preset);
          this.refresh();
        }
        /**
         * Exports a preset of all inputs.
         * @return An exported preset object.
         */
        exportPreset() {
          const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
            return ibc.binding.target;
          });
          return exportPresetJson(targets);
        }
        /**
         * Refreshes all bindings of the pane.
         */
        refresh() {
          this.controller_.rackController.rack.find(InputBindingController).forEach((ibc) => {
            ibc.binding.read();
          });
          this.controller_.rackController.rack.find(MonitorBindingController).forEach((mbc) => {
            mbc.binding.read();
          });
        }
      }
      class RootController extends FolderController {
        constructor(doc, config) {
          super(doc, {
            expanded: config.expanded,
            blade: config.blade,
            props: config.props,
            root: true,
            viewProps: config.viewProps
          });
        }
      }
      const SliderBladePlugin = {
        id: "slider",
        type: "blade",
        accept(params) {
          const p = ParamsParsers;
          const result = parseParams(params, {
            max: p.required.number,
            min: p.required.number,
            view: p.required.constant("slider"),
            format: p.optional.function,
            label: p.optional.string,
            value: p.optional.number
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          var _a, _b;
          const initialValue = (_a = args.params.value) !== null && _a !== void 0 ? _a : 0;
          const drc = new DefiniteRangeConstraint({
            max: args.params.max,
            min: args.params.min
          });
          const vc = new SliderTextController(args.document, {
            baseStep: 1,
            parser: parseNumber,
            sliderProps: new ValueMap({
              maxValue: drc.values.value("max"),
              minValue: drc.values.value("min")
            }),
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(void 0, initialValue),
              formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString
            }),
            value: createValue(initialValue, {
              constraint: drc
            }),
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: vc
          });
        },
        api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof SliderTextController)) {
            return null;
          }
          return new SliderApi(args.controller);
        }
      };
      const TextBladePlugin = /* @__PURE__ */ (function() {
        return {
          id: "text",
          type: "blade",
          accept(params) {
            const p = ParamsParsers;
            const result = parseParams(params, {
              parse: p.required.function,
              value: p.required.raw,
              view: p.required.constant("text"),
              format: p.optional.function,
              label: p.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            var _a;
            const ic = new TextController(args.document, {
              parser: args.params.parse,
              props: ValueMap.fromObject({
                formatter: (_a = args.params.format) !== null && _a !== void 0 ? _a : ((v4) => String(v4))
              }),
              value: createValue(args.params.value),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof TextController)) {
              return null;
            }
            return new TextApi(args.controller);
          }
        };
      })();
      function createDefaultWrapperElement(doc) {
        const elem = doc.createElement("div");
        elem.classList.add(ClassName("dfw")());
        if (doc.body) {
          doc.body.appendChild(elem);
        }
        return elem;
      }
      function embedStyle(doc, id, css) {
        if (doc.querySelector(`style[data-tp-style=${id}]`)) {
          return;
        }
        const styleElem = doc.createElement("style");
        styleElem.dataset.tpStyle = id;
        styleElem.textContent = css;
        doc.head.appendChild(styleElem);
      }
      class Pane2 extends RootApi {
        constructor(opt_config) {
          var _a, _b;
          const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
          const doc = (_a = config.document) !== null && _a !== void 0 ? _a : getWindowDocument();
          const pool = createDefaultPluginPool();
          const rootController = new RootController(doc, {
            expanded: config.expanded,
            blade: createBlade(),
            props: ValueMap.fromObject({
              title: config.title
            }),
            viewProps: ViewProps.create()
          });
          super(rootController, pool);
          this.pool_ = pool;
          this.containerElem_ = (_b = config.container) !== null && _b !== void 0 ? _b : createDefaultWrapperElement(doc);
          this.containerElem_.appendChild(this.element);
          this.doc_ = doc;
          this.usesDefaultWrapper_ = !config.container;
          this.setUpDefaultPlugins_();
        }
        get document() {
          if (!this.doc_) {
            throw TpError.alreadyDisposed();
          }
          return this.doc_;
        }
        dispose() {
          const containerElem = this.containerElem_;
          if (!containerElem) {
            throw TpError.alreadyDisposed();
          }
          if (this.usesDefaultWrapper_) {
            const parentElem = containerElem.parentElement;
            if (parentElem) {
              parentElem.removeChild(containerElem);
            }
          }
          this.containerElem_ = null;
          this.doc_ = null;
          super.dispose();
        }
        registerPlugin(bundle) {
          const plugins = "plugin" in bundle ? [bundle.plugin] : "plugins" in bundle ? bundle.plugins : [];
          plugins.forEach((p) => {
            this.pool_.register(p);
            this.embedPluginStyle_(p);
          });
        }
        embedPluginStyle_(plugin) {
          if (plugin.css) {
            embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
          }
        }
        setUpDefaultPlugins_() {
          embedStyle(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
          this.pool_.getAll().forEach((plugin) => {
            this.embedPluginStyle_(plugin);
          });
          this.registerPlugin({
            plugins: [
              SliderBladePlugin,
              ListBladePlugin,
              TabBladePlugin,
              TextBladePlugin
            ]
          });
        }
      }
      const VERSION2 = new Semver("3.1.10");
      exports2.BladeApi = BladeApi;
      exports2.ButtonApi = ButtonApi;
      exports2.FolderApi = FolderApi;
      exports2.InputBindingApi = InputBindingApi;
      exports2.ListApi = ListApi;
      exports2.MonitorBindingApi = MonitorBindingApi;
      exports2.Pane = Pane2;
      exports2.SeparatorApi = SeparatorApi;
      exports2.SliderApi = SliderApi;
      exports2.TabApi = TabApi;
      exports2.TabPageApi = TabPageApi;
      exports2.TextApi = TextApi;
      exports2.TpChangeEvent = TpChangeEvent;
      exports2.VERSION = VERSION2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    }));
  }
});

// node_modules/@threlte/extras/dist/hooks/useCursor.js
var useCursor = (onPointerOver = "pointer", onPointerOut = "auto", target = void 0) => {
  let hovering = false;
  const hoveringStore = writable(false);
  const onPointerEnter = () => {
    hoveringStore.set(true);
  };
  const onPointerLeave = () => {
    hoveringStore.set(false);
  };
  if (typeof window === "undefined") {
    return {
      hovering: hoveringStore,
      onPointerEnter,
      onPointerLeave
    };
  }
  const el2 = target ?? document.body;
  let onPointerOverValue = typeof onPointerOver === "string" ? onPointerOver : get2(onPointerOver);
  if (typeof onPointerOver !== "string") {
    watch(onPointerOver, (cursorStyle) => {
      onPointerOverValue = cursorStyle;
      if (hovering) {
        el2.style.cursor = cursorStyle;
      }
    });
  }
  let onPointerOutValue = typeof onPointerOut === "string" ? onPointerOut : get2(onPointerOut);
  if (typeof onPointerOut !== "string") {
    watch(onPointerOut, (cursorStyle) => {
      onPointerOutValue = cursorStyle;
      if (!hovering) {
        el2.style.cursor = cursorStyle;
      }
    });
  }
  watch(hoveringStore, (isHovering) => {
    hovering = isHovering;
    if (hovering) {
      el2.style.cursor = onPointerOverValue;
    } else {
      el2.style.cursor = onPointerOutValue;
    }
  });
  onDestroy(() => {
    el2.style.cursor = onPointerOutValue;
  });
  return {
    hovering: hoveringStore,
    onPointerEnter,
    onPointerLeave
  };
};

// node_modules/@threlte/extras/dist/hooks/useGltf.js
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

// node_modules/@threlte/extras/dist/lib/buildSceneGraph.js
var buildSceneGraph = (object) => {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name])
        data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
};

// node_modules/@threlte/extras/dist/hooks/useGltf.js
function useGltf(urlOrOptions, options) {
  const opts = typeof urlOrOptions === "string" ? options : urlOrOptions;
  const loader = useLoader(GLTFLoader, {
    extend(loader2) {
      if (opts?.dracoLoader) {
        loader2.setDRACOLoader(opts.dracoLoader);
      }
      if (opts?.meshoptDecoder) {
        loader2.setMeshoptDecoder(opts.meshoptDecoder);
      }
      if (opts?.ktx2Loader) {
        loader2.setKTX2Loader(opts.ktx2Loader);
      }
    }
  });
  const load = (url2) => {
    return loader.load(url2, {
      transform(result) {
        return {
          ...result,
          ...buildSceneGraph(result.scene)
        };
      }
    });
  };
  const url = typeof urlOrOptions === "string" ? urlOrOptions : void 0;
  if (url) {
    return load(url);
  } else {
    return {
      load
    };
  }
}

// node_modules/@threlte/extras/dist/hooks/useDraco.js
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader.js";
var defaultPath = "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
var dracoLoaderInstances = {};
var useDraco = (decoderPath = defaultPath) => {
  const cachedLoader = dracoLoaderInstances[decoderPath];
  if (cachedLoader) {
    return cachedLoader;
  }
  const loader = new DRACOLoader().setDecoderPath(decoderPath);
  dracoLoaderInstances[decoderPath] = loader;
  return loader;
};

// node_modules/@threlte/extras/dist/hooks/useMeshopt.js
import { MeshoptDecoder } from "three/examples/jsm/libs/meshopt_decoder.module.js";
var useMeshopt = () => {
  return MeshoptDecoder;
};

// node_modules/@threlte/extras/dist/hooks/useKtx2.js
import { KTX2Loader } from "three/examples/jsm/loaders/KTX2Loader.js";
var ktxLoaderInstances = {};
var useKtx2 = (transcoderPath) => {
  const cachedLoader = ktxLoaderInstances[transcoderPath];
  if (cachedLoader) {
    return cachedLoader;
  }
  const { renderer } = useThrelte();
  const ktx2Loader = new KTX2Loader();
  ktx2Loader.setTranscoderPath(transcoderPath);
  ktx2Loader.detectSupport(renderer);
  ktxLoaderInstances[transcoderPath] = ktx2Loader;
  return ktx2Loader;
};

// node_modules/@threlte/extras/dist/hooks/useGltfAnimations.js
import { AnimationMixer } from "three";
var isRoot = (value) => !!value?.isObject3D;
var isGltfStore = (value) => !!value?.subscribe && typeof value.subscribe === "function";
function useGltfAnimations(rootOrGltf, maybeRoot) {
  const gltf = isGltfStore(rootOrGltf) ? rootOrGltf : writable(void 0);
  const root6 = currentWritable(isRoot(rootOrGltf) ? rootOrGltf : isRoot(maybeRoot) ? maybeRoot : void 0);
  const actualRoot = derived([root6, gltf], ([root7, gltf2]) => {
    return root7 ?? gltf2?.scene;
  });
  const actions = currentWritable({});
  const mixer = new AnimationMixer(void 0);
  watch([gltf, actualRoot], async ([gltf2, actualRoot2]) => {
    if (!gltf2 || !gltf2.animations.length || !actualRoot2)
      return;
    await tick();
    const newActions = gltf2.animations.reduce((acc, clip) => {
      const action2 = mixer.clipAction(clip, actualRoot2);
      return {
        ...acc,
        [clip.name]: action2
      };
    }, {});
    actions.set(newActions);
    return () => {
      Object.values(newActions).forEach((a) => {
        const action2 = a;
        action2.stop();
        mixer.uncacheClip(action2.getClip());
      });
    };
  });
  const { start, stop } = useTask((delta) => {
    mixer.update(delta);
  }, { autoStart: false });
  watch(actions, (actions2) => {
    if (Object.keys(actions2).length)
      start();
    else
      stop();
  });
  return {
    gltf,
    root: root6,
    mixer,
    actions
  };
}

// node_modules/@threlte/extras/dist/hooks/useProgress.js
import { DefaultLoadingManager } from "three";

// node_modules/@threlte/extras/dist/lib/storeUtils.js
var toCurrentReadable = (store) => {
  return {
    subscribe: store.subscribe,
    get current() {
      return store.current;
    }
  };
};

// node_modules/@threlte/extras/dist/hooks/useProgress.js
var previousTotalLoaded = 0;
var finishedOnce = currentWritable(false);
var activeStore = currentWritable(false);
var itemStore = currentWritable(void 0);
var loadedStore = currentWritable(0);
var totalStore = currentWritable(0);
var errorsStore = currentWritable([]);
var progressStore = currentWritable(0);
var { onStart, onLoad, onError } = DefaultLoadingManager;
DefaultLoadingManager.onStart = (url, loaded, total) => {
  onStart?.(url, loaded, total);
  activeStore.set(true);
  itemStore.set(url);
  loadedStore.set(loaded);
  totalStore.set(total);
  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded);
  progressStore.set(progress);
  if (progress === 1)
    finishedOnce.set(true);
};
DefaultLoadingManager.onLoad = () => {
  onLoad?.();
  activeStore.set(false);
};
DefaultLoadingManager.onError = (url) => {
  onError?.(url);
  errorsStore.update((errors) => {
    return [...errors, url];
  });
};
DefaultLoadingManager.onProgress = (url, loaded, total) => {
  if (loaded === total) {
    previousTotalLoaded = total;
  }
  activeStore.set(true);
  itemStore.set(url);
  loadedStore.set(loaded);
  totalStore.set(total);
  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded) || 1;
  progressStore.set(progress);
  if (progress === 1)
    finishedOnce.set(true);
};
var stores = {
  active: toCurrentReadable(activeStore),
  item: toCurrentReadable(itemStore),
  loaded: toCurrentReadable(loadedStore),
  total: toCurrentReadable(totalStore),
  errors: toCurrentReadable(errorsStore),
  progress: toCurrentReadable(progressStore),
  finishedOnce: toCurrentReadable(finishedOnce)
};
var useProgress = () => {
  return stores;
};

// node_modules/@threlte/extras/dist/hooks/useTexture.js
import { TextureLoader } from "three";
var useTexture = (input, options) => {
  const loader = useLoader(TextureLoader, options);
  const { renderer } = useThrelte();
  return loader.load(input, {
    ...options,
    transform: (res) => {
      res.colorSpace = renderer.outputColorSpace;
      res.needsUpdate = true;
      return options?.transform?.(res) ?? res;
    }
  });
};

// node_modules/@threlte/extras/dist/hooks/useFBO.js
import { DepthTexture, WebGLRenderTarget } from "three";
var useFBO = ({ depth = false, size, ...targetOptions } = {}) => {
  const target = new WebGLRenderTarget(1, 1, targetOptions);
  if (size === void 0) {
    const { dpr, size: size2 } = useThrelte();
    watch([dpr, size2], ([dpr2, { width: width2, height: height2 }]) => {
      target.setSize(dpr2 * width2, dpr2 * height2);
    });
  } else {
    const width2 = Math.max(size.width ?? 1, target.width);
    const height2 = Math.max(size.height ?? 1, target.height);
    target.setSize(width2, height2);
  }
  if (depth === true) {
    target.depthTexture = new DepthTexture(target.width, target.height);
  } else if (isInstanceOf(depth, "DepthTexture")) {
    target.depthTexture = depth;
  } else if (depth !== false) {
    const width2 = Math.max(depth.width ?? 1, 1);
    const height2 = Math.max(depth.height ?? 1, 1);
    target.depthTexture = new DepthTexture(width2, height2);
  }
  onDestroy(() => {
    target.dispose();
  });
  return target;
};

// node_modules/@threlte/extras/dist/hooks/useGamepad.js
var standardButtons = [
  "clusterBottom",
  "clusterRight",
  "clusterLeft",
  "clusterTop",
  "leftBumper",
  "rightBumper",
  "leftTrigger",
  "rightTrigger",
  "select",
  "start",
  "leftStickButton",
  "rightStickButton",
  "directionalTop",
  "directionalBottom",
  "directionalLeft",
  "directionalRight",
  "center"
];
var xrButtons = [
  "trigger",
  "squeeze",
  "touchpadButton",
  "thumbstickButton",
  "clusterBottom",
  "clusterTop"
];
var standardAxes = ["leftStick", "rightStick"];
var xrAxes = ["touchpad", "thumbstick"];
var createButton = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    events[index][name] ??= [];
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    pressed: false,
    touched: false,
    value: 0,
    on,
    off
  };
};
var createAxis = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    events[index][name] ??= [];
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    x: 0,
    y: 0,
    on,
    off
  };
};
var createXrStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ??= [];
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Primary trigger */
    trigger: createButton(events, 0),
    /** buttons[1] - Primary squeeze button */
    squeeze: createButton(events, 1),
    /** buttons[2] - Primary touchpad */
    touchpadButton: createButton(events, 2),
    /** buttons[3] - Primary thumbstick */
    thumbstickButton: createButton(events, 3),
    /** buttons[4] - Bottom cluster button */
    clusterBottom: createButton(events, 4),
    /** buttons[5] - Top cluster button */
    clusterTop: createButton(events, 5),
    /** axes[0], axes[1] - Horizontal / vertical axis for the primary touchpad */
    touchpad: createAxis(events, 6),
    /** axes[2], axes[3] - Horizontal / vertical axis for the primary thumbstick */
    thumbstick: createAxis(events, 7)
  };
};
var createStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ??= [];
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Botton button in right cluster */
    clusterBottom: createButton(events, 0),
    /** buttons[1] - Right button in right cluster */
    clusterRight: createButton(events, 1),
    /** buttons[2] - Left button in right cluster */
    clusterLeft: createButton(events, 2),
    /** buttons[3] - Top button in right cluster */
    clusterTop: createButton(events, 3),
    /** buttons[4] - Top left front button */
    leftBumper: createButton(events, 4),
    /** buttons[5] - Top right front button */
    rightBumper: createButton(events, 5),
    /** buttons[6] - Bottom left front button */
    leftTrigger: createButton(events, 6),
    /** buttons[7] - Bottom right front button */
    rightTrigger: createButton(events, 7),
    /** buttons[8] - Left button in center cluster */
    select: createButton(events, 8),
    /** buttons[9] - Right button in center cluster */
    start: createButton(events, 9),
    /** buttons[10] - Left stick pressed button */
    leftStickButton: createButton(events, 10),
    /** buttons[11] -	Right stick pressed button */
    rightStickButton: createButton(events, 11),
    /** buttons[12] -	Top button in left cluster */
    directionalTop: createButton(events, 12),
    /** buttons[13] -	Bottom button in left cluster */
    directionalBottom: createButton(events, 13),
    /** buttons[14] -	Left button in left cluster */
    directionalLeft: createButton(events, 14),
    /** buttons[15] -	Right button in left cluster */
    directionalRight: createButton(events, 15),
    /** buttons[16] -	Center button in center cluster */
    center: createButton(events, 16),
    /** axes[0], axes[1] - Horizontal / vertical axis for left stick (negative left/positive right) */
    leftStick: createAxis(events, 17),
    /** axes[2], axes[3] - Horizontal / vertical axis for right stick (negative left/positive right) */
    rightStick: createAxis(events, 18)
  };
};
var processButton = (target, mappedButton, allEvents, buttonEvents, source) => {
  const lastTouched = mappedButton.touched;
  const lastPressed = mappedButton.pressed;
  const lastValue = mappedButton.value;
  mappedButton.touched = source?.touched ?? false;
  mappedButton.pressed = source?.pressed ?? false;
  const value = mappedButton.value = source?.value ?? 0;
  if (!lastTouched && mappedButton.touched) {
    allEvents.touchstart?.forEach((fn) => fn({ type: "touchstart", target, value }));
    buttonEvents.touchstart?.forEach((fn) => fn({ type: "touchstart", target, value }));
  } else if (lastTouched && !mappedButton.touched) {
    allEvents.touch?.forEach((fn) => fn({ type: "touch", target, value }));
    buttonEvents.touch?.forEach((fn) => fn({ type: "touch", target, value }));
    allEvents.touchend?.forEach((fn) => fn({ type: "touchend", target, value }));
    buttonEvents.touchend?.forEach((fn) => fn({ type: "touchend", target, value }));
  }
  if (!lastPressed && mappedButton.pressed) {
    allEvents.down?.forEach((fn) => fn({ type: "down", target, value }));
    buttonEvents.down?.forEach((fn) => fn({ type: "down", target, value }));
  } else if (lastPressed && !mappedButton.pressed) {
    allEvents.press?.forEach((fn) => fn({ type: "press", target, value }));
    buttonEvents.press?.forEach((fn) => fn({ type: "press", target, value }));
    allEvents.up?.forEach((fn) => fn({ type: "up", target, value }));
    buttonEvents.up?.forEach((fn) => fn({ type: "up", target, value }));
  }
  if (lastValue !== mappedButton.value) {
    allEvents.change?.forEach((fn) => fn({ type: "change", target, value }));
    buttonEvents.change?.forEach((fn) => fn({ type: "change", target, value }));
  }
};
var processAxis = (target, mappedStick, allEvents, axisEvents, axisDeadzone, rawX = 0, rawY = 0) => {
  const lastValueX = mappedStick.x;
  const lastValueY = mappedStick.y;
  const x = Math.abs(rawX) < axisDeadzone ? 0 : rawX;
  const y2 = Math.abs(rawY) < axisDeadzone ? 0 : rawY;
  mappedStick.x = x;
  mappedStick.y = y2;
  if (lastValueX !== x || lastValueY !== y2) {
    allEvents.change?.forEach((fn) => fn({ type: "change", target, value: { x, y: y2 } }));
    axisEvents.change?.forEach((fn) => fn({ type: "change", target, value: { x, y: y2 } }));
  }
};
function useGamepad(options = {}) {
  const { axisDeadzone = 0.05 } = options;
  const allEvents = {};
  const events = [];
  if ("xr" in options) {
    for (let i = 0; i < xrButtons.length + xrAxes.length; i += 1) {
      events.push({});
    }
    const gamepad = createXrStandard(allEvents, events);
    const { xr } = useThrelte().renderer;
    const processSnapshot = () => {
      xr.getSession()?.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        gamepad.raw = source.gamepad ?? null;
        const { buttons = [], axes = [] } = gamepad.raw ?? {};
        xrButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
        processAxis("touchpad", gamepad.touchpad, allEvents, events[6], axisDeadzone, axes[0], axes[1]);
        processAxis("thumbstick", gamepad.thumbstick, allEvents, events[7], axisDeadzone, axes[2], axes[3]);
      });
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleConnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      const pad = event.data.gamepad;
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    const handleDisconnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      gamepad.raw = null;
      gamepad.connected.set(false);
      stop();
    };
    const session = xr.getSession();
    if (session) {
      session.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        const pad = source.gamepad;
        if (pad) {
          gamepad.raw = pad;
          gamepad.connected.set(true);
          start();
        }
      });
    }
    for (const index of [0, 1]) {
      const controller = xr.getController(index);
      controller.addEventListener("connected", handleConnected);
      controller.addEventListener("disconnected", handleDisconnected);
    }
    onDestroy(() => {
      for (const index of [0, 1]) {
        const controller = xr.getController(index);
        controller.removeEventListener("connected", handleConnected);
        controller.removeEventListener("disconnected", handleDisconnected);
      }
    });
    return gamepad;
  } else {
    for (let i = 0; i < standardButtons.length + standardAxes.length; i += 1) {
      events.push({});
    }
    const { index: gamepadIndex = 0 } = options;
    const gamepad = createStandard(allEvents, events);
    const processSnapshot = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      gamepad.raw = pad;
      const { buttons = [], axes = [] } = pad ?? {};
      standardButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
      processAxis("leftStick", gamepad.leftStick, allEvents, events[17], axisDeadzone, axes[0], axes[1]);
      processAxis("rightStick", gamepad.rightStick, allEvents, events[18], axisDeadzone, axes[2], axes[3]);
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleGamepadDisconnected = (event) => {
      const { id } = event.gamepad;
      if (id === gamepad.raw?.id) {
        gamepad.raw = null;
        gamepad.connected.set(false);
        stop();
      }
    };
    const handleGamepadConnected = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    handleGamepadConnected();
    window.addEventListener("gamepadconnected", handleGamepadConnected);
    window.addEventListener("gamepaddisconnected", handleGamepadDisconnected);
    onDestroy(() => {
      window.removeEventListener("gamepadconnected", handleGamepadConnected);
      window.removeEventListener("gamepaddisconnected", handleGamepadDisconnected);
    });
    return gamepad;
  }
}

// node_modules/@threlte/extras/dist/hooks/useMask.js
import { NotEqualStencilFunc, EqualStencilFunc, KeepStencilOp } from "three";
var useMask = (id = 1, inverse = false) => {
  return {
    stencilRef: id,
    stencilWrite: true,
    stencilFunc: inverse ? NotEqualStencilFunc : EqualStencilFunc,
    stencilFail: KeepStencilOp,
    stencilZFail: KeepStencilOp,
    stencilZPass: KeepStencilOp
  };
};

// node_modules/@threlte/extras/dist/hooks/useViewport.js
import { Camera, Vector3 } from "three";
var origin = new Vector3();
var position = new Vector3();
var lastPosition = new Vector3();
var useViewport = (target) => {
  const viewport = currentWritable({
    width: 0,
    height: 0,
    factor: 0,
    distance: 0
  });
  const { camera, size, renderStage, scheduler } = useThrelte();
  const updateViewport = ($size, $camera, distance) => {
    viewport.update(($viewport) => {
      const { width: width2, height: height2 } = $size;
      if (Array.isArray(target)) {
        origin.fromArray(target);
      } else if (target !== void 0) {
        origin.copy(target);
      }
      $viewport.distance = distance;
      if (isInstanceOf($camera, "OrthographicCamera")) {
        $viewport.width = width2 / $camera.zoom;
        $viewport.height = height2 / $camera.zoom;
        $viewport.factor = 1;
      } else if (isInstanceOf($camera, "PerspectiveCamera")) {
        const fov = $camera.fov * Math.PI / 180;
        const h = 2 * Math.tan(fov / 2) * distance;
        const w = h * (width2 / height2);
        $viewport.width = w;
        $viewport.height = h;
        $viewport.factor = width2 / w;
      }
      return $viewport;
    });
  };
  useTask(() => {
    camera.current.getWorldPosition(position);
    if (!position.equals(lastPosition)) {
      const distance = position.distanceTo(origin);
      updateViewport(size.current, camera.current, distance);
      lastPosition.copy(position);
    }
  }, {
    autoInvalidate: false,
    stage: scheduler.createStage(/* @__PURE__ */ Symbol("viewport-stage"), { before: renderStage })
  });
  watch([camera, size], ([$camera, $size]) => {
    const distance = $camera.getWorldPosition(position).distanceTo(origin);
    updateViewport($size, $camera, distance);
  });
  return viewport;
};

// node_modules/@threlte/extras/dist/utilities/meshBounds.js
import { Matrix4, Ray, Sphere, Vector3 as Vector32 } from "three";
var sphere = new Sphere();
var inverseMatrix = new Matrix4();
var ray = new Ray();
var v = new Vector32();
var meshBounds = function(raycaster, intersects) {
  if (this.geometry.boundingSphere === null) {
    this.geometry.computeBoundingSphere();
  }
  sphere.copy(this.geometry.boundingSphere ?? sphere);
  sphere.applyMatrix4(this.matrixWorld);
  if (!raycaster.ray.intersectsSphere(sphere)) {
    return;
  }
  inverseMatrix.copy(this.matrixWorld).invert();
  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
  if (this.geometry.boundingBox !== null && ray.intersectBox(this.geometry.boundingBox, v) === null) {
    return;
  }
  const distance = v.distanceTo(raycaster.ray.origin);
  const point = v.clone();
  intersects.push({
    distance,
    point,
    object: this
  });
};

// node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte
import {
  DoubleSide,
  FileLoader,
  LinearFilter,
  MeshBasicMaterial,
  NearestFilter,
  RepeatWrapping,
  RGBADepthPacking,
  SpriteMaterial
} from "three";

// node_modules/@threlte/extras/dist/suspense/context.js
var suspenseContextIdentifier = /* @__PURE__ */ Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER");
var createSuspenseContext = (options) => {
  const promises = currentWritable(/* @__PURE__ */ new Set());
  const errors = currentWritable(/* @__PURE__ */ new Map());
  const finalized = writable(false);
  const checkFinalized = () => {
    if (promises.current.size === 0 && errors.current.size === 0)
      finalized.set(true);
  };
  const finalStore = writable(options?.final ?? false);
  const addPromise = (promise) => {
    promises.update((set2) => {
      set2.add(promise);
      return set2;
    });
  };
  const removePromise = (promise) => {
    promises.update((set2) => {
      set2.delete(promise);
      return set2;
    });
  };
  const addError = (promise, error) => {
    errors.update((map) => {
      map.set(promise, error);
      return map;
    });
  };
  const removeError = (promise) => {
    errors.update((map) => {
      map.delete(promise);
      return map;
    });
  };
  const suspended = derived([promises, errors, finalStore, finalized], ([promises2, errors2, final, finalized2]) => {
    if (final && finalized2) {
      return false;
    } else if (errors2.size > 0) {
      return true;
    } else {
      return promises2.size > 0;
    }
  });
  const context = {
    suspend(promise) {
      addPromise(promise);
      promise.catch((error) => {
        addError(promise, error);
      }).finally(() => {
        removePromise(promise);
        checkFinalized();
      });
    },
    onComponentDestroy(promise) {
      removePromise(promise);
      removeError(promise);
      checkFinalized();
    },
    suspended
  };
  const errorsArray = derived(errors, (errors2) => Array.from(errors2.values()));
  setContext(suspenseContextIdentifier, context);
  return {
    promises,
    suspended,
    errors: errorsArray,
    setFinal: (final) => finalStore.set(final ?? false)
  };
};

// node_modules/@threlte/extras/dist/suspense/useSuspense.js
var useSuspense = () => {
  const ctx = getContext(suspenseContextIdentifier);
  const promises = /* @__PURE__ */ new Set();
  const suspend = (promise) => {
    if (ctx) {
      ctx.suspend(promise);
      promises.add(promise);
    }
    return promise;
  };
  const state2 = {
    suspended: derived(ctx?.suspended ?? readable(false), (suspended) => suspended)
  };
  onDestroy(() => {
    if (!ctx)
      return;
    for (const promise of promises) {
      ctx.onComponentDestroy(promise);
    }
    promises.clear();
  });
  return Object.assign(suspend, state2);
};

// node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte
AnimatedSpriteMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte";
var root_1 = add_locations(from_html(`<!> <!>`, 1), AnimatedSpriteMaterial[FILENAME], []);
function AnimatedSpriteMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AnimatedSpriteMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let dataUrl = prop($$props, "dataUrl", 3, ""), animation = prop($$props, "animation", 3, ""), loop = prop($$props, "loop", 3, true), autoplay = prop($$props, "autoplay", 3, true), fps = prop($$props, "fps", 3, 10), filter = prop($$props, "filter", 3, "nearest"), alphaTest = prop($$props, "alphaTest", 3, 0.1), delay = prop($$props, "delay", 3, 0), transparent = prop($$props, "transparent", 3, true), flipX = prop($$props, "flipX", 3, false), startFrame = prop($$props, "startFrame", 3, 0), endFrame = prop($$props, "endFrame", 3, void 0), rows = prop($$props, "rows", 3, 1), columns = prop($$props, "columns", 3, void 0), totalFrames = prop($$props, "totalFrames", 3, 0), is = prop($$props, "is", 7), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "textureUrl",
      "dataUrl",
      "animation",
      "loop",
      "autoplay",
      "fps",
      "filter",
      "alphaTest",
      "delay",
      "transparent",
      "flipX",
      "startFrame",
      "endFrame",
      "rows",
      "columns",
      "totalFrames",
      "is",
      "ref",
      "onload",
      "onstart",
      "onend",
      "onloop"
    ],
    "props"
  );
  const parent = useParent();
  const supportedDirections = ["forward", "reverse"];
  const isSupportedDirection = (value) => {
    const isSupported = supportedDirections.includes(value);
    if (!isSupported) {
      console.warn(`frame tag direction: "${value}" is not supported.${equals(dataUrl(), "", false) ? `
source dataURL: ${dataUrl()}` : `
texture URL: ${$$props.textureUrl}`}`);
    }
    return isSupported;
  };
  let timerOffset = 0;
  let currentFrame = startFrame();
  let numFrames = 0;
  let flipOffset = flipX() ? -1 : 1;
  let frameWidth = 0;
  let frameHeight = 0;
  let texture = tag(state(void 0), "texture");
  let json;
  let frameNames = [];
  let direction2 = "forward";
  let frameTag;
  let spritesheetSize = { w: 0, h: 0 };
  let fpsInterval = tag(user_derived(() => 1e3 / fps()), "fpsInterval");
  let isMesh = tag(user_derived(() => strict_equals($parent(), void 0, false) && isInstanceOf($parent(), "Mesh")), "isMesh");
  user_pre_effect(() => {
    is(is() ?? (get(isMesh) ? new MeshBasicMaterial() : new SpriteMaterial()));
  });
  const suspend = useSuspense();
  const textureStore = suspend(useTexture($$props.textureUrl, {
    transform: (value) => {
      value.matrixAutoUpdate = false;
      value.generateMipmaps = false;
      value.premultiplyAlpha = false;
      value.wrapS = assign(value, "wrapT", RepeatWrapping, "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte:98:22");
      value.magFilter = assign(value, "minFilter", strict_equals(filter(), "nearest") ? NearestFilter : LinearFilter, "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte:99:26");
      return value;
    }
  }));
  const jsonStore = suspend(dataUrl() ? useLoader(FileLoader).load(dataUrl(), {
    transform: (file) => {
      if (strict_equals(typeof file, "string", false)) return;
      try {
        return JSON.parse(file);
      } catch {
        return;
      }
    }
  }) : asyncWritable(new Promise((resolve) => {
    const unsub = textureStore.subscribe((value) => {
      if (!value) return;
      unsub();
      resolve(createData(value));
    });
  })));
  const createData = (texture2) => {
    const { width: width2, height: height2 } = texture2.image;
    const cols = columns() ?? totalFrames();
    numFrames = totalFrames();
    const frameWidth2 = width2 / cols;
    const frameHeight2 = height2 / rows();
    const data = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: width2, h: height2 },
        scale: 1
      }
    };
    for (let i = 0; i < numFrames; i += 1) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      const x = col * frameWidth2;
      const y2 = row * frameHeight2;
      data.frames[`${i}`] = {
        frame: { x, y: y2, w: frameWidth2, h: frameHeight2 },
        spriteSourceSize: { x: 0, y: 0, w: frameWidth2, h: frameHeight2 },
        sourceSize: { w: frameWidth2, h: frameHeight2 }
      };
    }
    return data;
  };
  const setFrame = (frame) => {
    const horizontalFrames = spritesheetSize.w / frameWidth;
    const verticalFrames = spritesheetSize.h / frameHeight;
    const frameOffsetX = 1 / horizontalFrames;
    const frameOffsetY = 1 / verticalFrames;
    const x = flipOffset > 0 ? frameOffsetX * (frame.x / frameWidth) : frameOffsetX * (frame.x / frameHeight) - get(texture).repeat.x;
    const y2 = Math.abs(1 - frameOffsetY) - frameOffsetY * (frame.y / frameHeight);
    get(texture)?.offset.set(x, y2);
    get(texture)?.updateMatrix();
  };
  const setAnimation = (name) => {
    if (!json) return;
    frameTag = json?.meta.frameTags.find((tag2) => strict_equals(tag2.name, name));
    direction2 = "forward";
    if (frameTag?.direction) {
      direction2 = isSupportedDirection(frameTag?.direction) ? frameTag.direction : "forward";
    }
    currentFrame = strict_equals(direction2, "forward") ? frameTag?.from ?? 0 : frameTag?.to ?? numFrames - 1;
    setFrame(json.frames[frameNames[currentFrame]].frame);
    $$props.onstart?.();
  };
  let playQueued = false;
  const play = async () => {
    playQueued = true;
    (await track_reactivity_loss(Promise.all([textureStore, jsonStore])))();
    if (!playQueued) return;
    timerOffset = performance.now() - delay();
    start();
  };
  const pause = () => {
    playQueued = false;
    stop();
  };
  const { start, stop } = useTask(
    () => {
      if (!json) return;
      const now2 = performance.now();
      const diff = now2 - timerOffset;
      const name = frameNames[currentFrame];
      const { frame, duration } = json.frames[name];
      const interval = duration ?? get(fpsInterval);
      if (diff <= interval) return;
      timerOffset = now2 - diff % interval;
      const start2 = strict_equals(direction2, "forward") ? frameTag?.from ?? startFrame() ?? 0 : frameTag?.to ?? endFrame() ?? numFrames - 1;
      const end2 = strict_equals(direction2, "forward") ? frameTag?.to ?? endFrame() ?? numFrames - 1 : frameTag?.from ?? startFrame() ?? 0;
      setFrame(frame);
      switch (direction2) {
        case "forward":
          currentFrame += 1;
          break;
        case "reverse":
          currentFrame -= 1;
          break;
        default:
          break;
      }
      if (strict_equals(direction2, "forward") && currentFrame > end2 || strict_equals(direction2, "reverse") && currentFrame < end2) {
        currentFrame = start2;
        if (loop()) {
          $$props.onloop?.();
        } else {
          pause();
          $$props.onend?.();
        }
      }
    },
    { autoStart: false }
  );
  watch([textureStore, jsonStore], ([nextTexture, nextJson]) => {
    if (strict_equals(nextTexture, void 0) || strict_equals(nextJson, void 0)) return;
    set(texture, nextTexture.clone(), true);
    json = nextJson;
    frameNames = Object.keys(json.frames);
    numFrames = frameNames.length;
    spritesheetSize = json.meta.size;
    const { sourceSize } = Object.values(json.frames)[0];
    frameWidth = sourceSize.w;
    frameHeight = sourceSize.h;
    get(texture).repeat.set(1 * flipOffset / (spritesheetSize.w / frameWidth), 1 / (spritesheetSize.h / frameHeight));
    setAnimation(animation());
    $$props.onload?.();
    if (autoplay()) {
      play();
    }
  });
  user_pre_effect(() => {
    setAnimation(animation());
    if (autoplay()) {
      play();
    }
  });
  var $$exports = {
    get play() {
      return play;
    },
    get pause() {
      return pause;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_1();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", T, ref);
        add_svelte_meta(
          () => T(node_1, spread_props(
            {
              get is() {
                return is();
              },
              get map() {
                return get(texture);
              },
              toneMapped: false,
              get side() {
                return DoubleSide;
              },
              get shadowSide() {
                return DoubleSide;
              },
              get transparent() {
                return transparent();
              },
              get alphaTest() {
                return alphaTest();
              }
            },
            () => props,
            {
              get ref() {
                return ref();
              },
              set ref($$value) {
                ref($$value);
              }
            }
          )),
          "component",
          AnimatedSpriteMaterial,
          313,
          2,
          { componentTag: "T" }
        );
      }
      var node_2 = sibling(node_1, 2);
      add_svelte_meta(
        () => component(node_2, () => T.MeshDepthMaterial, ($$anchor3, T_MeshDepthMaterial) => {
          T_MeshDepthMaterial($$anchor3, {
            attach: "customDepthMaterial",
            get depthPacking() {
              return RGBADepthPacking;
            },
            get map() {
              return get(texture);
            },
            get alphaTest() {
              return alphaTest();
            }
          });
        }),
        "component",
        AnimatedSpriteMaterial,
        324,
        2,
        { componentTag: "T.MeshDepthMaterial" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          {
            $$ownership_validator.binding("ref", T, ref);
            add_svelte_meta(
              () => T(node_4, spread_props(
                {
                  get is() {
                    return is();
                  },
                  get map() {
                    return get(texture);
                  },
                  toneMapped: false,
                  get transparent() {
                    return transparent();
                  },
                  get alphaTest() {
                    return alphaTest();
                  }
                },
                () => props,
                {
                  get ref() {
                    return ref();
                  },
                  set ref($$value) {
                    ref($$value);
                  }
                }
              )),
              "component",
              AnimatedSpriteMaterial,
              331,
              2,
              { componentTag: "T" }
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(
            node_3,
            ($$render) => {
              if (get(texture)) $$render(consequent_1);
            },
            true
          ),
          "if",
          AnimatedSpriteMaterial,
          330,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(texture) && get(isMesh)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      AnimatedSpriteMaterial,
      312,
      0
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  AnimatedSpriteMaterial = hmr(AnimatedSpriteMaterial);
  import.meta.hot.accept((module) => {
    AnimatedSpriteMaterial[HMR].update(module.default);
  });
}
var AnimatedSpriteMaterial_default = AnimatedSpriteMaterial;

// node_modules/@threlte/extras/dist/components/AsciiRenderer/AsciiRenderer.svelte
import { AsciiEffect } from "three/examples/jsm/effects/AsciiEffect.js";
AsciiRenderer[FILENAME] = "node_modules/@threlte/extras/dist/components/AsciiRenderer/AsciiRenderer.svelte";
function AsciiRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AsciiRenderer);
  const defaultCharacters = " .:-+*=%@#";
  let autoRender = prop($$props, "autoRender", 3, true), bgColor = prop($$props, "bgColor", 3, "#000000"), characters = prop($$props, "characters", 3, defaultCharacters), fgColor = prop($$props, "fgColor", 3, "#ffffff"), options = prop($$props, "options", 19, () => ({}));
  const {
    autoRender: threlteAutoRender,
    camera: defaultCamera,
    renderStage,
    renderer,
    canvas,
    dom,
    scene: defaultScene,
    size
  } = useThrelte();
  const charSet = tag(user_derived(() => characters() || defaultCharacters), "charSet");
  const asciiEffect = tag(
    user_derived(() => {
      const effect = new AsciiEffect(renderer, get(charSet), options());
      effect.domElement.style.position = "absolute";
      effect.domElement.style.top = "0px";
      effect.domElement.style.left = "0px";
      effect.domElement.style.pointerEvents = "none";
      return effect;
    }),
    "asciiEffect"
  );
  const getEffect = () => get(asciiEffect);
  const sizeStore = fromStore(size);
  user_pre_effect(() => {
    get(asciiEffect).setSize(sizeStore.current.width, sizeStore.current.height);
  });
  user_pre_effect(() => {
    get(asciiEffect).domElement.style.color = fgColor();
  });
  user_pre_effect(() => {
    get(asciiEffect).domElement.style.backgroundColor = bgColor();
  });
  user_effect(() => {
    canvas.style.opacity = "0";
    const last = get(asciiEffect).domElement;
    dom.appendChild(last);
    return () => {
      canvas.style.opacity = "1";
      dom.removeChild(last);
    };
  });
  const { start: startRendering, stop: stopRendering } = useTask(
    () => {
      get(asciiEffect).render($$props.scene ?? defaultScene, $$props.camera ?? defaultCamera.current);
    },
    { autoInvalidate: false, autoStart: false, stage: renderStage }
  );
  const start = () => {
    startRendering();
    $$props.onstart?.();
  };
  const stop = () => {
    stopRendering();
    $$props.onstop?.();
  };
  user_effect(() => {
    if (!autoRender()) {
      return;
    }
    start();
    return () => {
      stop();
    };
  });
  user_effect(() => {
    const lastAutoRender = threlteAutoRender.current;
    threlteAutoRender.set(!autoRender());
    return () => {
      threlteAutoRender.set(lastAutoRender);
    };
  });
  var $$exports = {
    get getEffect() {
      return getEffect;
    },
    get start() {
      return start;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ asciiEffect: get(asciiEffect) })), "render", AsciiRenderer, 110, 0);
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  AsciiRenderer = hmr(AsciiRenderer);
  import.meta.hot.accept((module) => {
    AsciiRenderer[HMR].update(module.default);
  });
}
var AsciiRenderer_default = AsciiRenderer;

// node_modules/@threlte/extras/dist/components/Decal/Decal.svelte
import { Euler, Matrix4 as Matrix42, Mesh, Object3D, Texture, Vector3 as Vector33 } from "three";
import { DecalGeometry } from "three/examples/jsm/geometries/DecalGeometry.js";
Decal[FILENAME] = "node_modules/@threlte/extras/dist/components/Decal/Decal.svelte";
var vertex = new Vector33();
var matrixWorld = new Matrix42();
var closestNormal = new Vector33();
var vec3 = new Vector33();
var object3d = new Object3D();
var root_4 = add_locations(from_html(`<!> <!> <!>`, 1), Decal[FILENAME], []);
var root_2 = add_locations(from_html(`<!> <!>`, 1), Decal[FILENAME], []);
function Decal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Decal);
  var $$ownership_validator = create_ownership_validator($$props);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $map = () => (validate_store(get(map), "map"), store_get(get(map), "$map", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let polygonOffsetFactor = prop($$props, "polygonOffsetFactor", 19, () => -10), depthTest = prop($$props, "depthTest", 3, true), debug = prop($$props, "debug", 3, false), ref = prop($$props, "ref", 15), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "mesh",
      "position",
      "rotation",
      "scale",
      "polygonOffsetFactor",
      "depthTest",
      "debug",
      "ref",
      "children"
    ],
    "rest"
  );
  const parent = useParent();
  const parentNode = tag(user_derived(() => $$props.mesh ?? $parent()), "parentNode");
  const mesh = new Mesh();
  const projectorPosition = new Vector33();
  const projectorRotation = new Euler();
  const projectorSize = new Vector33(1, 1, 1);
  let helper = new Mesh();
  const suspend = useSuspense();
  const map = tag(
    user_derived(() => strict_equals(typeof $$props.src, "string") ? suspend(useTexture($$props.src)) : $$props.src ? asyncWritable(Promise.resolve($$props.src)) : void 0),
    "map"
  );
  user_pre_effect(() => {
    if (!("geometry" in get(parentNode))) {
      throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');
    }
    if (!$map() && !$$props.children) return;
    if (strict_equals($$props.position, void 0, false)) {
      projectorPosition.fromArray($$props.position);
    }
    if (strict_equals($$props.scale, void 0, false)) {
      if (strict_equals(typeof $$props.scale, "number")) {
        projectorSize.setScalar($$props.scale);
      } else {
        projectorSize.fromArray($$props.scale);
      }
    }
    matrixWorld.copy(get(parentNode).matrixWorld);
    get(parentNode).matrixWorld.identity();
    if (strict_equals($$props.rotation, void 0) || strict_equals(typeof $$props.rotation, "number")) {
      object3d.matrixWorld.identity();
      object3d.position.copy(projectorPosition);
      const vertices = get(parentNode).geometry.attributes.position.array;
      if (strict_equals(get(parentNode).geometry.attributes.normal, void 0)) {
        get(parentNode).geometry.computeVertexNormals();
      }
      const normal = get(parentNode).geometry.attributes.normal.array;
      let distance = Infinity;
      let chosenIdx = -1;
      for (let i = 0, l = vertices.length; i < l; i += 3) {
        const distSquared = vertex.fromArray(vertices, i).distanceToSquared(object3d.position);
        if (distSquared < distance) {
          distance = distSquared;
          chosenIdx = i;
        }
      }
      closestNormal.fromArray(normal, chosenIdx);
      object3d.lookAt(vec3.copy(object3d.position).add(closestNormal));
      object3d.rotateZ(Math.PI);
      object3d.rotateY(Math.PI);
      if (strict_equals(typeof $$props.rotation, "number")) {
        object3d.rotateZ($$props.rotation);
      }
      projectorRotation.copy(object3d.rotation);
    } else {
      projectorRotation.fromArray($$props.rotation);
    }
    mesh.geometry = new DecalGeometry(get(parentNode), projectorPosition, projectorRotation, projectorSize);
    get(parentNode).matrixWorld.copy(matrixWorld);
    if (debug()) {
      helper.position.copy(projectorPosition);
      helper.rotation.copy(projectorRotation);
      helper.scale.copy(projectorSize);
    }
    return () => mesh.geometry.dispose();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", T, ref);
        add_svelte_meta(
          () => T(node_1, spread_props(
            {
              get is() {
                return mesh;
              },
              "material.transparent": true,
              "material.polygonOffset": true,
              get "material.polygonOffsetFactor"() {
                return polygonOffsetFactor();
              },
              get "material.depthTest"() {
                return depthTest();
              },
              get "material.map"() {
                return $map();
              }
            },
            () => rest,
            {
              get ref() {
                return ref();
              },
              set ref($$value) {
                ref($$value);
              },
              children: wrap_snippet(Decal, ($$anchor3, $$slotProps) => {
                var fragment_2 = root_2();
                var node_2 = first_child(fragment_2);
                add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: mesh })), "render", Decal, 170, 4);
                var node_3 = sibling(node_2, 2);
                {
                  var consequent = ($$anchor4) => {
                    var fragment_3 = comment();
                    var node_4 = first_child(fragment_3);
                    add_svelte_meta(
                      () => T(node_4, {
                        get is() {
                          return helper;
                        },
                        raycast: () => null,
                        children: wrap_snippet(Decal, ($$anchor5, $$slotProps2) => {
                          var fragment_4 = root_4();
                          var node_5 = first_child(fragment_4);
                          add_svelte_meta(
                            () => component(node_5, () => T.BoxGeometry, ($$anchor6, T_BoxGeometry) => {
                              T_BoxGeometry($$anchor6, {});
                            }),
                            "component",
                            Decal,
                            177,
                            8,
                            { componentTag: "T.BoxGeometry" }
                          );
                          var node_6 = sibling(node_5, 2);
                          add_svelte_meta(
                            () => component(node_6, () => T.MeshNormalMaterial, ($$anchor6, T_MeshNormalMaterial) => {
                              T_MeshNormalMaterial($$anchor6, { wireframe: true });
                            }),
                            "component",
                            Decal,
                            178,
                            8,
                            { componentTag: "T.MeshNormalMaterial" }
                          );
                          var node_7 = sibling(node_6, 2);
                          add_svelte_meta(
                            () => component(node_7, () => T.AxesHelper, ($$anchor6, T_AxesHelper) => {
                              T_AxesHelper($$anchor6, { raycast: () => null });
                            }),
                            "component",
                            Decal,
                            179,
                            8,
                            { componentTag: "T.AxesHelper" }
                          );
                          append($$anchor5, fragment_4);
                        }),
                        $$slots: { default: true }
                      }),
                      "component",
                      Decal,
                      173,
                      6,
                      { componentTag: "T" }
                    );
                    append($$anchor4, fragment_3);
                  };
                  add_svelte_meta(
                    () => if_block(node_3, ($$render) => {
                      if (debug()) $$render(consequent);
                    }),
                    "if",
                    Decal,
                    172,
                    4
                  );
                }
                append($$anchor3, fragment_2);
              }),
              $$slots: { default: true }
            }
          )),
          "component",
          Decal,
          160,
          2,
          { componentTag: "T" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($map() || $$props.children) $$render(consequent_1);
      }),
      "if",
      Decal,
      159,
      0
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Decal = hmr(Decal);
  import.meta.hot.accept((module) => {
    Decal[HMR].update(module.default);
  });
}
var Decal_default = Decal;

// node_modules/@threlte/extras/dist/components/CameraControls/CameraControls.svelte
import {
  Box3,
  Matrix4 as Matrix43,
  Quaternion,
  Raycaster,
  Sphere as Sphere2,
  Spherical,
  Vector2,
  Vector3 as Vector34,
  Vector4
} from "three";

// node_modules/camera-controls/dist/camera-controls.module.js
var MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
var DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
var PI_2 = Math.PI * 2;
var PI_HALF = Math.PI / 2;
var EPSILON = 1e-5;
var DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b2, error = EPSILON) {
  return approxZero(a - b2, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  const temp5 = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp5) * exp;
  let output = target + (change + temp5) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
var EventDispatcher = class {
  _listeners = {};
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
};
var VERSION = "3.1.2";
var TOUCH_DOLLY_FACTOR = 1 / 8;
var isMac = /Mac/.test(globalThis?.navigator?.platform);
var THREE;
var _ORIGIN;
var _AXIS_Y;
var _AXIS_Z;
var _v2;
var _v3A;
var _v3B;
var _v3C;
var _cameraDirection;
var _xColumn;
var _yColumn;
var _zColumn;
var _deltaTarget;
var _deltaOffset;
var _sphericalA;
var _sphericalB;
var _box3A;
var _box3B;
var _sphere;
var _quaternionA;
var _quaternionB;
var _rotationMatrix;
var _raycaster;
var CameraControls = class _CameraControls extends EventDispatcher {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * Minimum vertical angle in radians.
   * The angle has to be between `0` and `.maxPolarAngle` inclusive.
   * The default value is `0`.
   *
   * e.g.
   * ```
   * cameraControls.maxPolarAngle = 0;
   * ```
   * @category Properties
   */
  minPolarAngle = 0;
  // radians
  /**
   * Maximum vertical angle in radians.
   * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
   * The default value is `Math.PI`.
   *
   * e.g.
   * ```
   * cameraControls.maxPolarAngle = Math.PI;
   * ```
   * @category Properties
   */
  maxPolarAngle = Math.PI;
  // radians
  /**
   * Minimum horizontal angle in radians.
   * The angle has to be less than `.maxAzimuthAngle`.
   * The default value is `- Infinity`.
   *
   * e.g.
   * ```
   * cameraControls.minAzimuthAngle = - Infinity;
   * ```
   * @category Properties
   */
  minAzimuthAngle = -Infinity;
  // radians
  /**
   * Maximum horizontal angle in radians.
   * The angle has to be greater than `.minAzimuthAngle`.
   * The default value is `Infinity`.
   *
   * e.g.
   * ```
   * cameraControls.maxAzimuthAngle = Infinity;
   * ```
   * @category Properties
   */
  maxAzimuthAngle = Infinity;
  // radians
  // How far you can dolly in and out ( PerspectiveCamera only )
  /**
   * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.
   * PerspectiveCamera only.
   * @category Properties
   */
  minDistance = Number.EPSILON;
  /**
   * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.
   * PerspectiveCamera only.
   * @category Properties
   */
  maxDistance = Infinity;
  /**
   * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`
   * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.
   * @category Properties
   */
  infinityDolly = false;
  /**
   * Minimum camera zoom.
   * @category Properties
   */
  minZoom = 0.01;
  /**
   * Maximum camera zoom.
   * @category Properties
   */
  maxZoom = Infinity;
  /**
   * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
   * @category Properties
   */
  smoothTime = 0.25;
  /**
   * the smoothTime while dragging
   * @category Properties
   */
  draggingSmoothTime = 0.125;
  /**
   * Max transition speed in unit-per-seconds
   * @category Properties
   */
  maxSpeed = Infinity;
  /**
   * Speed of azimuth (horizontal) rotation.
   * @category Properties
   */
  azimuthRotateSpeed = 1;
  /**
   * Speed of polar (vertical) rotation.
   * @category Properties
   */
  polarRotateSpeed = 1;
  /**
   * Speed of mouse-wheel dollying.
   * @category Properties
   */
  dollySpeed = 1;
  /**
   * `true` to invert direction when dollying or zooming via drag
   * @category Properties
   */
  dollyDragInverted = false;
  /**
   * Speed of drag for truck and pedestal.
   * @category Properties
   */
  truckSpeed = 2;
  /**
   * `true` to enable Dolly-in to the mouse cursor coords.
   * @category Properties
   */
  dollyToCursor = false;
  /**
   * @category Properties
   */
  dragToOffset = false;
  /**
   * Friction ratio of the boundary.
   * @category Properties
   */
  boundaryFriction = 0;
  /**
   * Controls how soon the `rest` event fires as the camera slows.
   * @category Properties
   */
  restThreshold = 0.01;
  /**
   * An array of Meshes to collide with camera.
   * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
   * @category Properties
   */
  colliderMeshes = [];
  // button configs
  /**
   * User's mouse input config.
   *
   * | button to assign      | behavior |
   * | --------------------- | -------- |
   * | `mouseButtons.left`   | `CameraControls.ACTION.ROTATE`* \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
   * | `mouseButtons.right`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK`* \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
   * | `mouseButtons.wheel`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
   * | `mouseButtons.middle`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY`* \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
   *
   * 1. Mouse wheel event for scroll "up/down" on mac "up/down/left/right"
   * 2. Mouse click on wheel event "button"
   * - \* is the default.
   * - The default of `mouseButtons.wheel` is:
   *   - `DOLLY` for Perspective camera.
   *   - `ZOOM` for Orthographic camera, and can't set `DOLLY`.
   * @category Properties
   */
  mouseButtons;
  /**
   * User's touch input config.
   *
   * | fingers to assign     | behavior |
   * | --------------------- | -------- |
   * | `touches.one` | `CameraControls.ACTION.TOUCH_ROTATE`* \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.DOLLY` | `CameraControls.ACTION.ZOOM` | `CameraControls.ACTION.NONE` |
   * | `touches.two` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `ACTION.TOUCH_DOLLY` \| `ACTION.TOUCH_ZOOM` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
   * | `touches.three` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
   *
   * - \* is the default.
   * - The default of `touches.two` and `touches.three` is:
   *   - `TOUCH_DOLLY_TRUCK` for Perspective camera.
   *   - `TOUCH_ZOOM_TRUCK` for Orthographic camera, and can't set `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY`.
   * @category Properties
   */
  touches;
  /**
   * Force cancel user dragging.
   * @category Methods
   */
  // cancel will be overwritten in the constructor.
  cancel = () => {
  };
  /**
   * Still an experimental feature.
   * This could change at any time.
   * @category Methods
   */
  lockPointer;
  /**
   * Still an experimental feature.
   * This could change at any time.
   * @category Methods
   */
  unlockPointer;
  _enabled = true;
  _camera;
  _yAxisUpSpace;
  _yAxisUpSpaceInverse;
  _state = ACTION.NONE;
  _domElement;
  _viewport = null;
  // the location of focus, where the object orbits around
  _target;
  _targetEnd;
  _focalOffset;
  _focalOffsetEnd;
  // rotation and dolly distance
  _spherical;
  _sphericalEnd;
  _lastDistance;
  _zoom;
  _zoomEnd;
  _lastZoom;
  // reset
  _cameraUp0;
  _target0;
  _position0;
  _zoom0;
  _focalOffset0;
  _dollyControlCoord;
  _changedDolly = 0;
  _changedZoom = 0;
  // collisionTest uses nearPlane. ( PerspectiveCamera only )
  _nearPlaneCorners;
  _hasRested = true;
  _boundary;
  _boundaryEnclosesCamera = false;
  _needsUpdate = true;
  _updatedLastTime = false;
  _elementRect = new DOMRect();
  _isDragging = false;
  _dragNeedsUpdate = true;
  _activePointers = [];
  _lockedPointer = null;
  _interactiveArea = new DOMRect(0, 0, 1, 1);
  // Use draggingSmoothTime over smoothTime while true.
  // set automatically true on user-dragging start.
  // set automatically false on programmable methods call.
  _isUserControllingRotate = false;
  _isUserControllingDolly = false;
  _isUserControllingTruck = false;
  _isUserControllingOffset = false;
  _isUserControllingZoom = false;
  _lastDollyDirection = DOLLY_DIRECTION.NONE;
  // velocities for smoothDamp
  _thetaVelocity = { value: 0 };
  _phiVelocity = { value: 0 };
  _radiusVelocity = { value: 0 };
  _targetVelocity = new THREE.Vector3();
  _focalOffsetVelocity = new THREE.Vector3();
  _zoomVelocity = { value: 0 };
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(_) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onPointerUp = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now2 = performance.now();
        if (lastScrollTimeStamp - now2 < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now2;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 && !event.ctrlKey ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y2 = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      const controlMode = event.ctrlKey ? ACTION.ZOOM : this.mouseButtons.wheel;
      switch (controlMode) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.SCREEN_PAN: {
          this._truckInternal(event.deltaX, event.deltaY, false, true);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true, false);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y2);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y2);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === _CameraControls.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2);
      lastDragPosition.copy(_v2);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y2 = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y2);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2);
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;
      lastDragPosition.copy(_v2);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {
        this._truckInternal(deltaX, deltaY, false, true);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true, false);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2);
      lastDragPosition.copy(_v2);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      startDragging();
    };
    this.unlockPointer = () => {
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      this._domElement?.ownerDocument.exitPointerLock();
      this._domElement?.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement?.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
      this.cancel();
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown);
      this._domElement.addEventListener("pointercancel", onPointerUp);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown);
      this._domElement.removeEventListener("pointercancel", onPointerUp);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y2, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y2, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y2, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y2);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height2, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height2);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y2, z2, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y2, z2).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y2, z2, enableTransition = false) {
    const point = _v3A.set(x, y2, z2);
    const direction2 = point.sub(this._targetEnd).normalize();
    const position2 = direction2.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(position2.x, position2.y, position2.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width2 = camera.right - camera.left;
      const height2 = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width2 / bbSize.x, height2 / bbSize.y) : Math.min(width2 / bbSize.x, height2 / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isObject3D = "isObject3D" in sphereOrMesh;
    const boundingSphere = isObject3D ? _CameraControls.createBoundingSphere(sphereOrMesh, _sphere) : _sphere.copy(sphereOrMesh);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width2 = this._camera.right - this._camera.left;
      const height2 = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width2 / diameter, height2 / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position2 = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position2.sub(target).applyQuaternion(this._yAxisUpSpace));
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Interpolates between two states.
   * @param stateA
   * @param stateB
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerp(stateA, stateB, t, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(...stateA.target);
    if ("spherical" in stateA) {
      _sphericalA.set(...stateA.spherical);
    } else {
      const positionA = _v3B.set(...stateA.position);
      _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    }
    const targetB = _v3C.set(...stateB.target);
    if ("spherical" in stateB) {
      _sphericalB.set(...stateB.spherical);
    } else {
      const positionB = _v3B.set(...stateB.position);
      _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    }
    this._targetEnd.copy(targetA.lerp(targetB, t));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
    return this.lerp({
      position: [positionAX, positionAY, positionAZ],
      target: [targetAX, targetAY, targetAZ]
    }, {
      position: [positionBX, positionBY, positionBZ],
      target: [targetBX, targetBY, targetBZ]
    }, t, enableTransition);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y2, z2, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y2, z2);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position2 = _v3A.set(targetX, targetY, targetZ);
    const distance = position2.distanceTo(this._camera.position);
    const cameraToPoint = position2.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y2, width2, height2) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y2, width2, height2);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width2, height2, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width2 / height2;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height2 : width2 / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = out || new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle (horizontal rotation) between -180 and 180 degrees.
   * @returns This CameraControls instance.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = (this._sphericalEnd.theta % PI_2 + PI_2) % PI_2;
    if (this._sphericalEnd.theta > Math.PI)
      this._sphericalEnd.theta -= PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
    return this;
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd);
    this._target.copy(this._targetEnd);
    this._spherical.copy(this._sphericalEnd);
    this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position2 = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position2.x, position2.y, position2.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position2 = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position2.x, position2.y, position2.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      this._camera.matrix.compose(this._camera.position, this._camera.quaternion, this._camera.scale);
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
      this._camera.updateMatrixWorld();
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position2, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position2;
    }
    const newTarget = _v3B.copy(offset).add(position2);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position2.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position2;
    } else if (friction === 0) {
      return position2.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position2.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  _truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {
    let truckX;
    let pedestalY;
    if (isPerspectiveCamera(this._camera)) {
      const offset = _v3A.copy(this._camera.position).sub(this._target);
      const fov = this._camera.getEffectiveFOV() * DEG2RAD;
      const targetDistance = offset.length() * Math.tan(fov * 0.5);
      truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
      pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      truckX = this.truckSpeed * deltaX * (camera.right - camera.left) / camera.zoom / this._elementRect.width;
      pedestalY = this.truckSpeed * deltaY * (camera.top - camera.bottom) / camera.zoom / this._elementRect.height;
    } else {
      return;
    }
    if (screenSpacePanning) {
      dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
      this.forward(-pedestalY, true);
    } else {
      dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
    }
  };
  _rotateInternal = (deltaX, deltaY) => {
    const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
    const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
    this.rotate(theta, phi, true);
  };
  _dollyInternal = (delta, x, y2) => {
    const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
    const lastDistance = this._sphericalEnd.radius;
    const distance = this._sphericalEnd.radius * dollyScale;
    const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
    const overflowedDistance = clampedDistance - distance;
    if (this.infinityDolly && this.dollyToCursor) {
      this._dollyToNoClamp(distance, true);
    } else if (this.infinityDolly && !this.dollyToCursor) {
      this.dollyInFixed(overflowedDistance, true);
      this._dollyToNoClamp(clampedDistance, true);
    } else {
      this._dollyToNoClamp(clampedDistance, true);
    }
    if (this.dollyToCursor) {
      this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
      this._dollyControlCoord.set(x, y2);
    }
    this._lastDollyDirection = Math.sign(-delta);
  };
  _zoomInternal = (delta, x, y2) => {
    const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
    const lastZoom = this._zoom;
    const zoom = this._zoom * zoomScale;
    this.zoomTo(zoom, true);
    if (this.dollyToCursor) {
      this._changedZoom += zoom - lastZoom;
      this._dollyControlCoord.set(x, y2);
    }
  };
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin3 = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster.set(origin3, rayDirection);
      _raycaster.far = this._spherical.radius + 1;
      const intersects = _raycaster.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance) {
        distance = intersects[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d2, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d2.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d2.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      if (!mesh.geometry)
        return;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position2 = bufferGeometry.attributes.position;
      for (let i = 0, l = position2.count; i < l; i++) {
        _v3A.fromBufferAttribute(position2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
};

// node_modules/@threlte/extras/dist/components/CameraControls/CameraControls.svelte
CameraControls_1[FILENAME] = "node_modules/@threlte/extras/dist/components/CameraControls/CameraControls.svelte";
var installed = false;
var install = () => {
  if (installed) {
    return;
  }
  CameraControls.install({
    THREE: {
      Vector2,
      Vector3: Vector34,
      Vector4,
      Quaternion,
      Matrix4: Matrix43,
      Spherical,
      Box3,
      Sphere: Sphere2,
      Raycaster
    }
  });
  installed = true;
};
function CameraControls_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CameraControls_1);
  var $$ownership_validator = create_ownership_validator($$props);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $defaultCamera = () => (validate_store(defaultCamera, "defaultCamera"), store_get(defaultCamera, "$defaultCamera", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  install();
  let ref = prop($$props, "ref", 15), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "camera",
      "children"
    ],
    "rest"
  );
  const { dom, camera: defaultCamera, invalidate } = useThrelte();
  const parent = useParent();
  const camera = tag(
    user_derived(() => {
      if ($$props.camera) {
        return $$props.camera;
      }
      if (isInstanceOf($parent(), "PerspectiveCamera") || isInstanceOf($parent(), "OrthographicCamera")) {
        return $parent();
      }
      return $defaultCamera();
    }),
    "camera"
  );
  const controls = new CameraControls(get(camera), dom);
  user_pre_effect(() => {
    controls.camera = get(camera);
  });
  useTask(
    (delta) => {
      if (controls.update(delta)) {
        invalidate();
      }
    },
    { autoInvalidate: false }
  );
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return controls;
          }
        },
        () => rest,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(CameraControls_1, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: controls })), "render", CameraControls_1, 88, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      CameraControls_1,
      83,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  CameraControls_1 = hmr(CameraControls_1);
  import.meta.hot.accept((module) => {
    CameraControls_1[HMR].update(module.default);
  });
}
var CameraControls_default = CameraControls_1;

// node_modules/@threlte/extras/dist/components/Edges/Edges.svelte
import { LineSegments } from "three";
Edges[FILENAME] = "node_modules/@threlte/extras/dist/components/Edges/Edges.svelte";
var root_12 = add_locations(from_html(`<!> <!> <!>`, 1), Edges[FILENAME], []);
function Edges($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Edges);
  var $$ownership_validator = create_ownership_validator($$props);
  let thresholdAngle = prop($$props, "thresholdAngle", 3, 1), color = prop($$props, "color", 3, "#ffffff"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "thresholdAngle",
      "color",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = fromStore(useParent());
  const geometry = tag(
    user_derived(() => {
      if (!isInstanceOf(parent.current, "Mesh")) {
        throw new Error("Edges: component must be a child of a Mesh");
      }
      return parent.current.geometry;
    }),
    "geometry"
  );
  const segments = new LineSegments();
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return segments;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Edges, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_12();
            var node_1 = first_child(fragment_1);
            {
              let $0 = user_derived(() => [get(geometry), thresholdAngle()]);
              add_svelte_meta(
                () => component(node_1, () => T.EdgesGeometry, ($$anchor3, T_EdgesGeometry) => {
                  T_EdgesGeometry($$anchor3, {
                    get args() {
                      return get($0);
                    }
                  });
                }),
                "component",
                Edges,
                32,
                2,
                { componentTag: "T.EdgesGeometry" }
              );
            }
            var node_2 = sibling(node_1, 2);
            add_svelte_meta(
              () => component(node_2, () => T.LineBasicMaterial, ($$anchor3, T_LineBasicMaterial) => {
                T_LineBasicMaterial($$anchor3, {
                  get color() {
                    return color();
                  }
                });
              }),
              "component",
              Edges,
              33,
              2,
              { componentTag: "T.LineBasicMaterial" }
            );
            var node_3 = sibling(node_2, 2);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => ({ ref: segments })), "render", Edges, 34, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Edges,
      27,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Edges = hmr(Edges);
  import.meta.hot.accept((module) => {
    Edges[HMR].update(module.default);
  });
}
var Edges_default = Edges;

// node_modules/@threlte/extras/dist/components/HTML/HTML.svelte
import {
  DoubleSide as DoubleSide2,
  Group,
  Matrix4 as Matrix45,
  Mesh as Mesh2,
  Object3D as Object3D3,
  OrthographicCamera as OrthographicCamera2,
  PerspectiveCamera as PerspectiveCamera2,
  Raycaster as Raycaster3,
  Vector3 as Vector36
} from "three";

// node_modules/@threlte/extras/dist/components/HTML/shaders.js
var logVertex = `
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`;
var logFragment = `
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
}`;
var spriteVertex = `
#include <common>
#include <logdepthbuf_pars_vertex>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;
  
  // This is somewhat arbitrary, but it seems to work well
  // Need to figure out how to derive this dynamically if it even matters
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale = vec2(
    length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) ),
    length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) )
  );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
  #include <logdepthbuf_vertex>
}`;

// node_modules/@threlte/extras/dist/components/HTML/utils.js
import { Camera as Camera2, Matrix4 as Matrix44, Object3D as Object3D2, OrthographicCamera, PerspectiveCamera, Raycaster as Raycaster2, Vector2 as Vector22, Vector3 as Vector35 } from "three";
var v1 = new Vector35();
var v2 = new Vector35();
var v3 = new Vector35();
var vec2 = new Vector22();
var defaultCalculatePosition = (obj, camera, size) => {
  const objectPos = v1.setFromMatrixPosition(obj.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
};
var isObjectBehindCamera = (el2, camera) => {
  const objectPos = v1.setFromMatrixPosition(el2.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
};
var isObjectVisible = (el2, camera, raycaster, occlude) => {
  const elPos = v1.setFromMatrixPosition(el2.matrixWorld);
  const screenPos = v2.copy(v1);
  screenPos.project(camera);
  raycaster.setFromCamera(vec2.set(screenPos.x, screenPos.y), camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
};
var objectScale = (el2, camera) => {
  if (isInstanceOf(camera, "OrthographicCamera")) {
    return camera.zoom;
  } else if (isInstanceOf(camera, "PerspectiveCamera")) {
    const objectPos = v1.setFromMatrixPosition(el2.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
};
var objectZIndex = (el2, camera, zIndexRange) => {
  const objectPos = v1.setFromMatrixPosition(el2.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const dist = objectPos.distanceTo(cameraPos);
  const A2 = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
  const B2 = zIndexRange[1] - A2 * camera.far;
  return Math.round(A2 * dist + B2);
};
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
var getCSSMatrix = (mat4, m2, prepend = "") => {
  const { elements: e } = mat4;
  return `${prepend}matrix3d(
    ${epsilon(m2[0] * e[0])},${epsilon(m2[1] * e[1])},${epsilon(m2[2] * e[2])},${epsilon(m2[3] * e[3])},
    ${epsilon(m2[4] * e[4])},${epsilon(m2[5] * e[5])},${epsilon(m2[6] * e[6])},${epsilon(m2[7] * e[7])},
    ${epsilon(m2[8] * e[8])},${epsilon(m2[9] * e[9])},${epsilon(m2[10] * e[10])},${epsilon(m2[11] * e[11])},
    ${epsilon(m2[12] * e[12])},${epsilon(m2[13] * e[13])},${epsilon(m2[14] * e[14])},${epsilon(m2[15] * e[15])}
  )`;
};
var getCameraCSSMatrix = /* @__PURE__ */ ((multipliers) => {
  return (matrix2) => getCSSMatrix(matrix2, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = /* @__PURE__ */ ((scaleMultipliers) => {
  return (matrix2, factor) => getCSSMatrix(matrix2, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [
  1 / f,
  1 / f,
  1 / f,
  1,
  -1 / f,
  -1 / f,
  -1 / f,
  -1,
  1 / f,
  1 / f,
  1 / f,
  1,
  1,
  1,
  1,
  1
]);
var getViewportFactor = (camera, target, size) => {
  if (isInstanceOf(camera, "OrthographicCamera")) {
    return 1;
  }
  if (isInstanceOf(camera, "PerspectiveCamera")) {
    const { width: width2, height: height2 } = size;
    const distance = camera.getWorldPosition(v1).distanceTo(target);
    const fov = camera.fov * Math.PI / 180;
    const h = 2 * Math.tan(fov / 2) * distance;
    const w = h * (width2 / height2);
    return width2 / w;
  }
  throw new Error("getViewportFactor needs a Perspective or Orthographic Camera");
};

// node_modules/@threlte/extras/dist/components/HTML/HTML.svelte
HTML[FILENAME] = "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte";
var canvasModified = false;
var activeOccludeInstances = 0;
var oldZIndex = "";
var oldPosition = "";
var oldPointerEvents = "";
var modifyCanvas = (canvas, zIndexRange) => {
  if (strict_equals(activeOccludeInstances, 1) && !canvasModified) {
    oldZIndex = canvas.style.zIndex;
    oldPosition = canvas.style.position;
    oldPointerEvents = canvas.style.pointerEvents;
    canvas.style.zIndex = `${Math.floor(zIndexRange / 2)}`;
    canvas.style.position = "absolute";
    canvas.style.pointerEvents = "none";
    canvasModified = true;
  } else if (strict_equals(activeOccludeInstances, 0) && canvasModified) {
    canvas.style.zIndex = oldZIndex;
    canvas.style.position = oldPosition;
    canvas.style.pointerEvents = oldPointerEvents;
    canvasModified = false;
  }
};
var root_3 = add_locations(from_html(`<!> <!>`, 1), HTML[FILENAME], []);
var root_11 = add_locations(from_html(`<div><div><div><!></div></div></div>`), HTML[FILENAME], [[346, 4, [[356, 6, [[361, 8]]]]]]);
var root_122 = add_locations(from_html(`<div><!></div>`), HTML[FILENAME], [[370, 4]]);
var root = add_locations(from_html(`<!> <!>`, 1), HTML[FILENAME], []);
function HTML($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HTML);
  var $$ownership_validator = create_ownership_validator($$props);
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  const $suspended = () => (validate_store(suspended, "suspended"), store_get(suspended, "$suspended", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let autoRender = prop($$props, "autoRender", 3, true), eps = prop($$props, "eps", 3, 1e-3), center = prop($$props, "center", 3, false), fullscreen = prop($$props, "fullscreen", 3, false), sprite = prop($$props, "sprite", 3, false), transform = prop($$props, "transform", 3, false), occlude = prop($$props, "occlude", 3, false), castShadow = prop($$props, "castShadow", 3, false), receiveShadow = prop($$props, "receiveShadow", 3, false), zIndexRange = prop($$props, "zIndexRange", 19, () => [16777271, 0]), calculatePosition = prop($$props, "calculatePosition", 3, defaultCalculatePosition), as = prop($$props, "as", 3, "div"), pointerEvents = prop($$props, "pointerEvents", 3, "auto"), ref = prop($$props, "ref", 15), visible = prop($$props, "visible", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoRender",
      "eps",
      "center",
      "fullscreen",
      "portal",
      "distanceFactor",
      "sprite",
      "transform",
      "occlude",
      "castShadow",
      "receiveShadow",
      "material",
      "geometry",
      "zIndexRange",
      "calculatePosition",
      "as",
      "wrapperClass",
      "pointerEvents",
      "ref",
      "visible",
      "children"
    ],
    "props"
  );
  visible(true);
  const { camera, scene, size, dom, canvas, renderStage } = useThrelte();
  const group = new Group();
  let element2 = document.createElement(as());
  let oldZoom = 0;
  let oldPosition2 = [0, 0];
  let transformOuterRef = tag(state(void 0), "transformOuterRef");
  let transformInnerRef = tag(state(void 0), "transformInnerRef");
  let isMeshSizeSet = false;
  const occlusionMesh = new Mesh2();
  const raycaster = new Raycaster3();
  let isRayCastOcclusion = tag(user_derived(() => occlude() && strict_equals(occlude(), "blending", false) || Array.isArray(occlude()) && occlude().length > 0), "isRayCastOcclusion");
  let matrix2 = new Matrix45();
  let width2 = tag(user_derived(() => $size().width), "width");
  let height2 = tag(user_derived(() => $size().height), "height");
  let halfWidth = tag(user_derived(() => get(width2) / 2), "halfWidth");
  let halfHeight = tag(user_derived(() => get(height2) / 2), "halfHeight");
  let fov = tag(user_derived(() => $camera().projectionMatrix.elements[5] * get(halfHeight)), "fov");
  let viewportFactor = tag(user_derived(() => getViewportFactor($camera(), new Vector36(), $size())), "viewportFactor");
  user_pre_effect(() => {
    if ($$props.wrapperClass) element2.className = $$props.wrapperClass;
  });
  user_pre_effect(() => {
    if (strict_equals(occlude(), "blending")) {
      activeOccludeInstances += 1;
      modifyCanvas(canvas, zIndexRange()[0]);
    }
    return () => {
      activeOccludeInstances -= 1;
      modifyCanvas(canvas, zIndexRange()[0]);
    };
  });
  const render = () => {
    camera.current.updateMatrixWorld();
    group.updateWorldMatrix(true, false);
    const vec = transform() ? oldPosition2 : calculatePosition()(group, camera.current, $size());
    if (transform() || Math.abs(oldZoom - camera.current.zoom) > eps() || Math.abs(oldPosition2[0] - vec[0]) > eps() || Math.abs(oldPosition2[1] - vec[1]) > eps()) {
      const isBehindCamera = isObjectBehindCamera(group, camera.current);
      let raytraceTarget = false;
      if (get(isRayCastOcclusion)) {
        if (Array.isArray(occlude())) {
          raytraceTarget = occlude();
        } else if (strict_equals(occlude(), "blending", false)) {
          raytraceTarget = [scene];
        }
      }
      const previouslyVisible = visible();
      if (raytraceTarget) {
        const isvisible = isObjectVisible(group, camera.current, raycaster, raytraceTarget);
        visible(isvisible && !isBehindCamera);
      } else {
        visible(!isBehindCamera);
      }
      if (strict_equals(previouslyVisible, visible(), false)) {
        if ($$props.onvisibilitychange) {
          $$props.onvisibilitychange(visible());
        } else {
          element2.style.display = visible() ? "block" : "none";
        }
      }
      const halfRange = Math.floor(zIndexRange()[0] / 2);
      const zRange = occlude() ? get(
        isRayCastOcclusion
        //
      ) ? [zIndexRange()[0], halfRange] : [halfRange - 1, 0] : zIndexRange();
      element2.style.zIndex = `${objectZIndex(group, camera.current, zRange)}`;
      if (transform() && get(transformOuterRef) && get(transformInnerRef)) {
        const { isOrthographicCamera: isOrthographicCamera2, top, left, bottom, right } = camera.current;
        const cameraMatrix = getCameraCSSMatrix(camera.current.matrixWorldInverse);
        const cameraTransform = isOrthographicCamera2 ? `scale(${get(fov)})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${get(fov)}px)`;
        if (sprite()) {
          matrix2.copy(camera.current.matrixWorldInverse).transpose().copyPosition(matrix2).scale(group.scale);
          matrix2.elements[3] = assign(matrix2.elements, 7, assign(matrix2.elements, 11, 0, "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte:192:52"), "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte:192:31");
          matrix2.elements[15] = 1;
        } else {
          matrix2.copy(group.matrixWorld);
        }
        element2.style.width = `${get(width2)}px`;
        element2.style.height = `${get(height2)}px`;
        element2.style.perspective = isOrthographicCamera2 ? "" : `${get(fov)}px`;
        get(transformOuterRef).style.transform = `${cameraTransform}${cameraMatrix}translate(${get(halfWidth)}px,${get(halfHeight)}px)`;
        get(transformInnerRef).style.transform = getObjectCSSMatrix(matrix2, 1 / (($$props.distanceFactor || 10) / 400));
      } else {
        const scale = strict_equals($$props.distanceFactor, void 0) ? 1 : objectScale(group, camera.current) * $$props.distanceFactor;
        element2.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;
      }
      oldPosition2 = vec;
      oldZoom = camera.current.zoom;
    }
    if (!get(isRayCastOcclusion) && !isMeshSizeSet) {
      if (transform() && get(transformOuterRef)) {
        const el2 = get(transformOuterRef).children[0];
        if (el2?.clientWidth && el2?.clientHeight) {
          const { isOrthographicCamera: isOrthographicCamera2 } = camera.current;
          if (isOrthographicCamera2 || $$props.geometry) {
            const { scale } = props;
            if (scale) {
              if (!Array.isArray(scale)) {
                occlusionMesh.scale.setScalar(1 / scale);
              } else {
                occlusionMesh.scale.set(1 / scale[0], 1 / scale[1], 1 / scale[2]);
              }
            }
          } else {
            const ratio = ($$props.distanceFactor ?? 10) / 400;
            const w = el2.clientWidth * ratio;
            const h = el2.clientHeight * ratio;
            occlusionMesh.scale.set(w, h, 1);
          }
          isMeshSizeSet = true;
        }
      } else {
        const el2 = element2.children[0];
        if (el2?.clientWidth && el2?.clientHeight) {
          const ratio = 1 / get(viewportFactor);
          const w = el2.clientWidth * ratio;
          const h = el2.clientHeight * ratio;
          occlusionMesh.scale.set(w, h, 1);
          isMeshSizeSet = true;
        }
        occlusionMesh.lookAt(camera.current.position);
      }
    }
  };
  const { start: startRendering, stop: stopRendering } = useTask(render, { autoStart: false, autoInvalidate: false, stage: renderStage });
  user_effect(() => {
    if (!autoRender()) {
      return;
    }
    startRendering();
    return () => {
      stopRendering();
    };
  });
  let pos = tag(
    user_derived(() => {
      scene.updateMatrixWorld();
      return calculatePosition()(group, $camera(), $size());
    }),
    "pos"
  );
  const portalAction = (el2) => {
    const target = $$props.portal ?? dom;
    if (!target) {
      console.warn("<HTML>: target is undefined.");
      return;
    }
    target.append(el2);
    return { destroy: () => el2.remove() };
  };
  const { suspended } = useSuspense();
  var $$exports = {
    get render() {
      return render;
    },
    get startRendering() {
      return startRendering;
    },
    get stopRendering() {
      return stopRendering;
    },
    ...legacy_api()
  };
  var fragment2 = root();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return group;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(HTML, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            {
              var consequent_3 = ($$anchor3) => {
                var fragment_2 = comment();
                var node_2 = first_child(fragment_2);
                add_svelte_meta(
                  () => T(node_2, {
                    get is() {
                      return occlusionMesh;
                    },
                    get castShadow() {
                      return castShadow();
                    },
                    get receiveShadow() {
                      return receiveShadow();
                    },
                    children: wrap_snippet(HTML, ($$anchor4, $$slotProps2) => {
                      var fragment_3 = root_3();
                      var node_3 = first_child(fragment_3);
                      {
                        var consequent = ($$anchor5) => {
                          var fragment_4 = comment();
                          var node_4 = first_child(fragment_4);
                          add_svelte_meta(
                            () => T(node_4, {
                              get is() {
                                return $$props.geometry;
                              }
                            }),
                            "component",
                            HTML,
                            308,
                            8,
                            { componentTag: "T" }
                          );
                          append($$anchor5, fragment_4);
                        };
                        var alternate = ($$anchor5) => {
                          var fragment_5 = comment();
                          var node_5 = first_child(fragment_5);
                          add_svelte_meta(
                            () => component(node_5, () => T.PlaneGeometry, ($$anchor6, T_PlaneGeometry) => {
                              T_PlaneGeometry($$anchor6, {});
                            }),
                            "component",
                            HTML,
                            310,
                            8,
                            { componentTag: "T.PlaneGeometry" }
                          );
                          append($$anchor5, fragment_5);
                        };
                        add_svelte_meta(
                          () => if_block(node_3, ($$render) => {
                            if ($$props.geometry) $$render(consequent);
                            else $$render(alternate, false);
                          }),
                          "if",
                          HTML,
                          307,
                          6
                        );
                      }
                      var node_6 = sibling(node_3, 2);
                      {
                        var consequent_1 = ($$anchor5) => {
                          var fragment_6 = comment();
                          var node_7 = first_child(fragment_6);
                          add_svelte_meta(
                            () => T(node_7, {
                              get is() {
                                return $$props.material;
                              }
                            }),
                            "component",
                            HTML,
                            314,
                            8,
                            { componentTag: "T" }
                          );
                          append($$anchor5, fragment_6);
                        };
                        var alternate_2 = ($$anchor5) => {
                          var fragment_7 = comment();
                          var node_8 = first_child(fragment_7);
                          {
                            var consequent_2 = ($$anchor6) => {
                              var fragment_8 = comment();
                              var node_9 = first_child(fragment_8);
                              add_svelte_meta(
                                () => component(node_9, () => T.ShaderMaterial, ($$anchor7, T_ShaderMaterial) => {
                                  T_ShaderMaterial($$anchor7, {
                                    get side() {
                                      return DoubleSide2;
                                    },
                                    get vertexShader() {
                                      return spriteVertex;
                                    },
                                    get fragmentShader() {
                                      return logFragment;
                                    }
                                  });
                                }),
                                "component",
                                HTML,
                                316,
                                8,
                                { componentTag: "T.ShaderMaterial" }
                              );
                              append($$anchor6, fragment_8);
                            };
                            var alternate_1 = ($$anchor6) => {
                              var fragment_9 = comment();
                              var node_10 = first_child(fragment_9);
                              add_svelte_meta(
                                () => component(node_10, () => T.ShaderMaterial, ($$anchor7, T_ShaderMaterial_1) => {
                                  T_ShaderMaterial_1($$anchor7, {
                                    get side() {
                                      return DoubleSide2;
                                    },
                                    get vertexShader() {
                                      return logVertex;
                                    },
                                    get fragmentShader() {
                                      return logFragment;
                                    }
                                  });
                                }),
                                "component",
                                HTML,
                                322,
                                8,
                                { componentTag: "T.ShaderMaterial" }
                              );
                              append($$anchor6, fragment_9);
                            };
                            add_svelte_meta(
                              () => if_block(
                                node_8,
                                ($$render) => {
                                  if (!transform()) $$render(consequent_2);
                                  else $$render(alternate_1, false);
                                },
                                true
                              ),
                              "if",
                              HTML,
                              315,
                              6
                            );
                          }
                          append($$anchor5, fragment_7);
                        };
                        add_svelte_meta(
                          () => if_block(node_6, ($$render) => {
                            if ($$props.material) $$render(consequent_1);
                            else $$render(alternate_2, false);
                          }),
                          "if",
                          HTML,
                          313,
                          6
                        );
                      }
                      append($$anchor4, fragment_3);
                    }),
                    $$slots: { default: true }
                  }),
                  "component",
                  HTML,
                  302,
                  4,
                  { componentTag: "T" }
                );
                append($$anchor3, fragment_2);
              };
              add_svelte_meta(
                () => if_block(node_1, ($$render) => {
                  if (occlude() && !get(isRayCastOcclusion)) $$render(consequent_3);
                }),
                "if",
                HTML,
                301,
                2
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      HTML,
      296,
      0,
      { componentTag: "T" }
    );
  }
  var node_11 = sibling(node, 2);
  {
    validate_void_dynamic_element(as);
    validate_dynamic_element_tag(as);
    element(
      node_11,
      as,
      false,
      ($$element, $$anchor2) => {
        action($$element, ($$node) => portalAction?.($$node));
        bind_this($$element, ($$value) => element2 = $$value, () => element2);
        attribute_effect($$element, () => ({
          style: "",
          [STYLE]: {
            position: "absolute",
            top: "0",
            left: "0",
            "pointer-events": transform() ? "none" : void 0,
            overflow: transform() ? "hidden" : void 0,
            transform: transform() ? void 0 : `translate3d(${get(pos)[0]}px,${get(pos)[1]}px,0)`,
            "transform-origin": transform() ? void 0 : "0 0",
            display: $suspended() ? "none" : void 0
          }
        }));
        var fragment_10 = comment();
        var node_12 = first_child(fragment_10);
        {
          var consequent_4 = ($$anchor3) => {
            var div = root_11();
            let styles;
            var div_1 = child(div);
            let styles_1;
            var div_2 = child(div_1);
            var node_13 = child(div_2);
            add_svelte_meta(() => snippet(node_13, () => $$props.children ?? noop, () => ({ render, startRendering, stopRendering })), "render", HTML, 365, 10);
            reset(div_2);
            reset(div_1);
            bind_this(div_1, ($$value) => set(transformInnerRef, $$value), () => get(transformInnerRef));
            reset(div);
            bind_this(div, ($$value) => set(transformOuterRef, $$value), () => get(transformOuterRef));
            template_effect(() => {
              styles = set_style(div, "", styles, {
                position: "absolute",
                top: "0",
                left: "0",
                "transform-style": "preserve-3d",
                "pointer-events": "none",
                width: `${get(width2)}px`,
                height: `${get(height2)}px`
              });
              styles_1 = set_style(div_1, "", styles_1, { position: "absolute", "pointer-events": pointerEvents() });
              set_class(div_2, 1, clsx($$props.class));
              set_style(div_2, $$props.style);
            });
            append($$anchor3, div);
          };
          var alternate_3 = ($$anchor3) => {
            var div_3 = root_122();
            let styles_2;
            var node_14 = child(div_3);
            add_svelte_meta(() => snippet(node_14, () => $$props.children ?? noop, () => ({ render, startRendering, stopRendering })), "render", HTML, 380, 6);
            reset(div_3);
            template_effect(() => {
              styles_2 = set_style(div_3, $$props.style, styles_2, {
                position: "absolute",
                transform: center() ? "translate3d(-50%,-50%,0)" : "none",
                top: fullscreen() ? `${-get(height2) / 2}px` : void 0,
                left: fullscreen() ? `${-get(width2) / 2}px` : void 0,
                width: fullscreen() ? `${get(width2)}px` : void 0,
                height: fullscreen() ? `${get(height2)}px` : void 0
              });
              set_class(div_3, 1, clsx($$props.class));
            });
            append($$anchor3, div_3);
          };
          add_svelte_meta(
            () => if_block(node_12, ($$render) => {
              if (transform()) $$render(consequent_4);
              else $$render(alternate_3, false);
            }),
            "if",
            HTML,
            345,
            2
          );
        }
        append($$anchor2, fragment_10);
      },
      void 0,
      [332, 0]
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  HTML = hmr(HTML);
  import.meta.hot.accept((module) => {
    HTML[HMR].update(module.default);
  });
}
var HTML_default = HTML;

// node_modules/@threlte/extras/dist/components/HUD/HUD.svelte
HUD[FILENAME] = "node_modules/@threlte/extras/dist/components/HUD/HUD.svelte";
function HUD($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HUD);
  var $$ownership_validator = create_ownership_validator($$props);
  const { renderStage, renderer, toneMapping } = useThrelte();
  let autoRender = prop($$props, "autoRender", 3, true), stage = prop($$props, "stage", 3, renderStage), ref = prop($$props, "ref", 15), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoRender",
      "toneMapping",
      "stage",
      "ref",
      "children"
    ],
    "rest"
  );
  const { scene } = createSceneContext();
  const { camera } = createCameraContext();
  const key2 = /* @__PURE__ */ Symbol("threlte-hud-render-stage");
  user_pre_effect(() => {
    if (!autoRender()) {
      return;
    }
    stage().createTask(key2, () => {
      const { autoClear } = renderer;
      renderer.autoClear = false;
      renderer.toneMapping = $$props.toneMapping ?? toneMapping.current;
      renderer.clearDepth();
      renderer.render(scene, camera.current);
      renderer.autoClear = autoClear;
      renderer.toneMapping = toneMapping.current;
    });
    return () => stage().removeTask(key2);
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return scene;
          },
          attach: false
        },
        () => rest,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(HUD, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: scene })), "render", HUD, 49, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      HUD,
      43,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  HUD = hmr(HUD);
  import.meta.hot.accept((module) => {
    HUD[HMR].update(module.default);
  });
}
var HUD_default = HUD;

// node_modules/@threlte/extras/dist/components/Float/Float.svelte
import { MathUtils, Group as Group2 } from "three";
Float[FILENAME] = "node_modules/@threlte/extras/dist/components/Float/Float.svelte";
function Float($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Float);
  var $$ownership_validator = create_ownership_validator($$props);
  let speed = prop($$props, "speed", 3, 1), floatIntensity = prop($$props, "floatIntensity", 3, 1), floatingRange = prop($$props, "floatingRange", 19, () => [-0.1, 0.1]), rotationSpeed = prop($$props, "rotationSpeed", 3, 0), rotationIntensity = prop($$props, "rotationIntensity", 3, 0), seed = prop($$props, "seed", 19, () => 1e4 * Math.random()), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "speed",
      "floatIntensity",
      "floatingRange",
      "rotationSpeed",
      "rotationIntensity",
      "seed",
      "ref",
      "children"
    ],
    "props"
  );
  const outerGroup = new Group2();
  const group = new Group2();
  let t = seed();
  const map = MathUtils.mapLinear;
  let fSpeed = tag(user_derived(() => Array.isArray(speed()) ? speed() : [speed(), speed(), speed()]), "fSpeed");
  let fIntensity = tag(
    user_derived(() => Array.isArray(floatIntensity()) ? floatIntensity() : [floatIntensity(), floatIntensity(), floatIntensity()]),
    "fIntensity"
  );
  let fRange = tag(user_derived(() => strict_equals(floatingRange().length, 3) ? floatingRange() : [[0, 0], floatingRange(), [0, 0]]), "fRange");
  let rSpeed = tag(
    user_derived(() => Array.isArray(rotationSpeed()) ? rotationSpeed() : [rotationSpeed(), rotationSpeed(), rotationSpeed()]),
    "rSpeed"
  );
  let rIntensity = tag(
    user_derived(() => Array.isArray(rotationIntensity()) ? rotationIntensity() : [
      rotationIntensity(),
      rotationIntensity(),
      rotationIntensity()
    ]),
    "rIntensity"
  );
  useTask((delta) => {
    t += delta;
    group.position.x = map(Math.sin(t / 4 * get(fSpeed)[0]) / 10, -0.1, 0.1, ...get(fRange)[0]) * get(fIntensity)[0];
    group.position.y = map(Math.sin(t / 4 * get(fSpeed)[1]) / 10, -0.1, 0.1, ...get(fRange)[1]) * get(fIntensity)[1];
    group.position.z = map(Math.sin(t / 4 * get(fSpeed)[2]) / 10, -0.1, 0.1, ...get(fRange)[2]) * get(fIntensity)[2];
    group.rotation.x = Math.cos(t / 4 * get(rSpeed)[0]) / 8 * get(rIntensity)[0];
    group.rotation.y = Math.sin(t / 4 * get(rSpeed)[1]) / 8 * get(rIntensity)[1];
    group.rotation.z = Math.sin(t / 4 * get(rSpeed)[2]) / 20 * get(rIntensity)[2];
    group.updateMatrix();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return outerGroup;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Float, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => T(node_1, {
                get is() {
                  return group;
                },
                matrixAutoUpdate: false,
                children: wrap_snippet(Float, ($$anchor3, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_2 = first_child(fragment_2);
                  add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: group })), "render", Float, 71, 4);
                  append($$anchor3, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              Float,
              67,
              2,
              { componentTag: "T" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Float,
      62,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Float = hmr(Float);
  import.meta.hot.accept((module) => {
    Float[HMR].update(module.default);
  });
}
var Float_default = Float;

// node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte
GLTF[FILENAME] = "node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte";
function GLTF($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GLTF);
  let gltf = prop($$props, "gltf", 15), scene = prop($$props, "scene", 15), animations = prop($$props, "animations", 15), asset = prop($$props, "asset", 15), cameras = prop($$props, "cameras", 15), scenes = prop($$props, "scenes", 15), userData = prop($$props, "userData", 15), parser = prop($$props, "parser", 15), materials = prop($$props, "materials", 15), nodes = prop($$props, "nodes", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "url",
      "dracoLoader",
      "meshoptDecoder",
      "ktx2Loader",
      "gltf",
      "scene",
      "animations",
      "asset",
      "cameras",
      "scenes",
      "userData",
      "parser",
      "materials",
      "nodes",
      "onload",
      "onunload",
      "onerror",
      "children"
    ],
    "props"
  );
  const loader = useGltf({
    dracoLoader: $$props.dracoLoader,
    meshoptDecoder: $$props.meshoptDecoder,
    ktx2Loader: $$props.ktx2Loader
  });
  const onLoad2 = (data) => {
    if (gltf()) $$props.onunload?.();
    gltf(data);
    scene(data.scene);
    animations(data.animations);
    asset(data.asset);
    cameras(data.cameras);
    scenes(data.scenes);
    userData(data.userData);
    parser(data.parser);
    materials(data.materials);
    nodes(data.nodes);
    $$props.onload?.(gltf());
  };
  const onError2 = (error) => {
    gltf(void 0);
    scene(void 0);
    animations(void 0);
    asset(void 0);
    cameras(void 0);
    scenes(void 0);
    userData(void 0);
    parser(void 0);
    nodes(void 0);
    materials(void 0);
    $$props.onerror?.(error);
  };
  const suspend = useSuspense();
  const loadGltf = async (url) => {
    try {
      const model = (await track_reactivity_loss(suspend(loader.load(url))))();
      onLoad2(model);
    } catch (error) {
      onError2(error);
    }
  };
  user_pre_effect(() => {
    loadGltf($$props.url);
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => T(node_1, spread_props(
          {
            get is() {
              return scene();
            }
          },
          () => props,
          {
            children: wrap_snippet(GLTF, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: scene() })), "render", GLTF, 91, 4);
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }
        )),
        "component",
        GLTF,
        87,
        2,
        { componentTag: "T" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (scene()) $$render(consequent);
      }),
      "if",
      GLTF,
      86,
      0
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  GLTF = hmr(GLTF);
  import.meta.hot.accept((module) => {
    GLTF[HMR].update(module.default);
  });
}
var GLTF_default = GLTF;

// node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte
import { NoToneMapping, Vector4 as Vector42 } from "three";

// node_modules/three-viewport-gizmo/dist/three-viewport-gizmo.js
import { Vector3 as U, Vector2 as Q, Raycaster as ae, Object3D as ft, Color as Vt, CanvasTexture as ce, RepeatWrapping as zt, SRGBColorSpace as le, BufferGeometry as Xt, BufferAttribute as nt, Sprite as bt, SpriteMaterial as St, Mesh as V, MeshBasicMaterial as at, BackSide as de, SphereGeometry as ue, InstancedBufferGeometry as he, Float32BufferAttribute as Bt, InstancedInterleavedBuffer as pt, InterleavedBufferAttribute as N, WireframeGeometry as fe, Box3 as xt, Sphere as Zt, ShaderMaterial as pe, ShaderLib as it, UniformsUtils as $t, UniformsLib as st, Vector4 as X, Line3 as me, Matrix4 as Yt, MathUtils as ge, Clock as ye, Quaternion as ct, Scene as _e, OrthographicCamera as ve, PerspectiveCamera as we, Spherical as be } from "three";
var oe = Object.defineProperty;
var re = (s, e, t) => e in s ? oe(s, e, { enumerable: true, configurable: true, writable: true, value: t }) : s[e] = t;
var m = (s, e, t) => re(s, typeof e != "symbol" ? e + "" : e, t);
var Qt = (s, e) => {
  const [t, n] = e.split("-");
  return Object.assign(s.style, {
    left: n === "left" ? "0" : n === "center" ? "50%" : "",
    right: n === "right" ? "0" : "",
    top: t === "top" ? "0" : t === "bottom" ? "" : "50%",
    bottom: t === "bottom" ? "0" : "",
    transform: `${n === "center" ? "translateX(-50%)" : ""} ${t === "center" ? "translateY(-50%)" : ""}`
  }), e;
};
var Se = ({
  placement: s,
  size: e,
  offset: t,
  id: n,
  className: i
}) => {
  const o = document.createElement("div"), { top: a, left: l, right: d, bottom: h } = t;
  return Object.assign(o.style, {
    id: n,
    position: "absolute",
    zIndex: "1000",
    height: `${e}px`,
    width: `${e}px`,
    margin: `${a}px ${d}px ${h}px ${l}px`,
    borderRadius: "100%"
  }), Qt(o, s), n && (o.id = n), i && (o.className = i), o;
};
var xe = (s) => {
  const e = typeof s == "string" ? document.querySelector(s) : s;
  if (!e) throw Error("Invalid DOM element");
  return e;
};
function mt(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
var Ee = [
  ["x", 0, 3],
  ["y", 1, 4],
  ["z", 2, 5]
];
var Ct = new U();
function Ot({ isSphere: s }, e, t) {
  s && (Ct.set(0, 0, 1).applyQuaternion(t.quaternion), Ee.forEach(([n, i, o]) => {
    const a = Ct[n];
    let l = e[i], d = l.userData.opacity;
    l.material.opacity = mt(a >= 0 ? d : d / 2, 0, 1), l = e[o], d = l.userData.opacity, l.material.opacity = mt(a >= 0 ? d / 2 : d, 0, 1);
  }));
}
var Ae = (s, e, t = 10) => Math.abs(s.clientX - e.x) < t && Math.abs(s.clientY - e.y) < t;
var Dt = new ae();
var Pt = new Q();
var Gt = (s, e, t, n) => {
  Pt.set(
    (s.clientX - e.left) / e.width * 2 - 1,
    -((s.clientY - e.top) / e.height) * 2 + 1
  ), Dt.setFromCamera(Pt, t);
  const i = Dt.intersectObjects(
    n,
    false
  ), o = i.length ? i[0] : null;
  return !o || !o.object.visible ? null : o;
};
var lt = 1e-6;
var Me = 2 * Math.PI;
var Jt = ["x", "y", "z"];
var Y = [...Jt, "nx", "ny", "nz"];
var Te = ["x", "z", "y", "nx", "nz", "ny"];
var Ue = ["z", "x", "y", "nz", "nx", "ny"];
var gt = "Right";
var ot = "Top";
var yt = "Front";
var _t = "Left";
var rt = "Bottom";
var vt = "Back";
var Le = [
  gt,
  ot,
  yt,
  _t,
  rt,
  vt
].map((s) => s.toLocaleLowerCase());
var Kt = 1.3;
var Rt = (s, e = true) => {
  const { material: t, userData: n } = s, { color: i, opacity: o } = e ? n.hover : n;
  t.color.set(i), t.opacity = o;
};
var k = (s) => JSON.parse(JSON.stringify(s));
var ze = (s) => {
  const e = s.type || "sphere", t = e === "sphere", n = s.resolution || t ? 64 : 128, i = ft.DEFAULT_UP, o = i.z === 1, a = i.x === 1, { container: l } = s;
  s.container = void 0, s = JSON.parse(JSON.stringify(s)), s.container = l;
  const d = o ? Te : a ? Ue : Y;
  Le.forEach((c, f) => {
    s[c] && (s[d[f]] = s[c]);
  });
  const h = {
    enabled: true,
    color: 16777215,
    opacity: 1,
    scale: 0.7,
    labelColor: 2236962,
    line: false,
    border: {
      size: 0,
      color: 14540253
    },
    hover: {
      color: t ? 16777215 : 9688043,
      labelColor: 2236962,
      opacity: 1,
      scale: 0.7,
      border: {
        size: 0,
        color: 14540253
      }
    }
  }, r = {
    line: false,
    scale: t ? 0.45 : 0.7,
    hover: {
      scale: t ? 0.5 : 0.7
    }
  }, u = {
    type: e,
    container: document.body,
    size: 128,
    placement: "top-right",
    resolution: n,
    lineWidth: 4,
    radius: t ? 1 : 0.2,
    smoothness: 18,
    animated: true,
    speed: 1,
    background: {
      enabled: true,
      color: t ? 16777215 : 14739180,
      opacity: t ? 0 : 1,
      hover: {
        color: t ? 16777215 : 14739180,
        opacity: t ? 0.2 : 1
      }
    },
    font: {
      family: "sans-serif",
      weight: 900
    },
    offset: {
      top: 10,
      left: 10,
      bottom: 10,
      right: 10
    },
    corners: {
      enabled: !t,
      color: t ? 15915362 : 16777215,
      opacity: 1,
      scale: t ? 0.15 : 0.2,
      radius: 1,
      smoothness: 18,
      hover: {
        color: t ? 16777215 : 9688043,
        opacity: 1,
        scale: t ? 0.2 : 0.225
      }
    },
    edges: {
      enabled: !t,
      color: t ? 15915362 : 16777215,
      opacity: t ? 1 : 0,
      radius: t ? 1 : 0.125,
      smoothness: 18,
      scale: t ? 0.15 : 1,
      hover: {
        color: t ? 16777215 : 9688043,
        opacity: 1,
        scale: t ? 0.2 : 1
      }
    },
    x: {
      ...k(h),
      ...t ? { label: "X", color: 16725587, line: true } : { label: a ? ot : gt }
    },
    y: {
      ...k(h),
      ...t ? { label: "Y", color: 9100032, line: true } : { label: o || a ? yt : ot }
    },
    z: {
      ...k(h),
      ...t ? { label: "Z", color: 2920447, line: true } : {
        label: o ? ot : a ? gt : yt
      }
    },
    nx: {
      ...k(r),
      label: t ? "" : a ? rt : _t
    },
    ny: {
      ...k(r),
      label: t ? "" : o || a ? vt : rt
    },
    nz: {
      ...k(r),
      label: t ? "" : o ? rt : a ? _t : vt
    }
  };
  return wt(s, u), Jt.forEach(
    (c) => wt(
      s[`n${c}`],
      k(s[c])
    )
  ), { ...s, isSphere: t };
};
function wt(s, ...e) {
  if (s instanceof HTMLElement || typeof s != "object" || s === null)
    return s;
  for (const t of e)
    for (const n in t)
      n !== "container" && n in t && (s[n] === void 0 ? s[n] = t[n] : typeof t[n] == "object" && !Array.isArray(t[n]) && (s[n] = wt(
        s[n] || {},
        t[n]
      )));
  return s;
}
var Be = (s, e = 2) => {
  const t = new Vt(), n = e * 2, { isSphere: i, resolution: o, radius: a, font: l, corners: d, edges: h } = s, r = Y.map((p) => ({ ...s[p], radius: a }));
  i && d.enabled && r.push(d), i && h.enabled && r.push(h);
  const u = document.createElement("canvas"), c = u.getContext("2d");
  u.width = o * 2 + n * 2, u.height = o * r.length + n * r.length;
  const [f, y2] = Z2(r, o, l);
  r.forEach(
    ({
      radius: p,
      label: x,
      color: I2,
      labelColor: _,
      border: b2,
      hover: {
        color: F2,
        labelColor: B2,
        border: C2
      }
    }, G2) => {
      const R2 = o * G2 + G2 * n + e;
      L2(
        e,
        R2,
        e,
        o,
        p,
        x,
        b2,
        I2,
        _
      ), L2(
        o + e * 3,
        R2,
        e,
        o,
        p,
        x,
        C2 ?? b2,
        F2 ?? I2,
        B2 ?? _
      );
    }
  );
  const v4 = r.length, g = e / (o * 2), S = e / (o * 6), w = 1 / v4, E2 = new ce(u);
  return E2.repeat.set(0.5 - 2 * g, w - 2 * S), E2.offset.set(g, 1 - S), Object.assign(E2, {
    colorSpace: le,
    wrapS: zt,
    wrapT: zt,
    userData: {
      offsetX: g,
      offsetY: S,
      cellHeight: w
    }
  }), E2;
  function L2(p, x, I2, _, b2, F2, B2, C2, G2) {
    if (b2 = b2 * (_ / 2), C2 != null && C2 !== "" && (R2(), c.fillStyle = t.set(C2).getStyle(), c.fill()), B2 && B2.size) {
      const W2 = B2.size * _ / 2;
      p += W2, x += W2, _ -= B2.size * _, b2 = Math.max(0, b2 - W2), R2(), c.strokeStyle = t.set(B2.color).getStyle(), c.lineWidth = B2.size * _, c.stroke();
    }
    F2 && z2(
      c,
      p + _ / 2,
      x + (_ + I2) / 2,
      F2,
      t.set(G2).getStyle()
    );
    function R2() {
      c.beginPath(), c.moveTo(p + b2, x), c.lineTo(p + _ - b2, x), c.arcTo(p + _, x, p + _, x + b2, b2), c.lineTo(p + _, x + _ - b2), c.arcTo(p + _, x + _, p + _ - b2, x + _, b2), c.lineTo(p + b2, x + _), c.arcTo(p, x + _, p, x + _ - b2, b2), c.lineTo(p, x + b2), c.arcTo(p, x, p + b2, x, b2), c.closePath();
    }
  }
  function Z2(p, x, I2) {
    const b2 = [...p].sort((J2, se2) => {
      var Ut2, Lt2;
      return (((Ut2 = J2.label) == null ? void 0 : Ut2.length) || 0) - (((Lt2 = se2.label) == null ? void 0 : Lt2.length) || 0);
    }).pop().label, { family: F2, weight: B2 } = I2, C2 = i ? Math.sqrt(Math.pow(x * 0.7, 2) / 2) : x;
    let G2 = C2, R2 = 0, W2 = 0;
    do {
      c.font = `${B2} ${G2}px ${F2}`;
      const J2 = c.measureText(b2);
      R2 = J2.width, W2 = J2.fontBoundingBoxDescent, G2--;
    } while (R2 > C2 && G2 > 0);
    const Tt2 = C2 / W2, ne2 = Math.min(C2 / R2, Tt2), ie2 = Math.floor(G2 * ne2);
    return [`${B2} ${ie2}px ${F2}`, Tt2];
  }
  function z2(p, x, I2, _, b2) {
    p.font = f, p.textAlign = "center", p.textBaseline = "middle", p.fillStyle = b2, p.fillText(_, x, I2 + (i ? y2 : 0));
  }
};
var Ce = (s, e) => s.offset.x = (e ? 0.5 : 0) + s.userData.offsetX;
var Et = (s, e) => {
  const {
    offset: t,
    userData: { offsetY: n, cellHeight: i }
  } = s;
  t.y = 1 - (e + 1) * i + n;
};
function At(s, e, t = 2, n = 2) {
  const i = t / 2 - s, o = n / 2 - s, a = s / t, l = (t - s) / t, d = s / n, h = (n - s) / n, r = [i, o, 0, -i, o, 0, -i, -o, 0, i, -o, 0], u = [l, h, a, h, a, d, l, d], c = [
    3 * (e + 1) + 3,
    3 * (e + 1) + 4,
    e + 4,
    e + 5,
    2 * (e + 1) + 4,
    2,
    1,
    2 * (e + 1) + 3,
    3,
    4 * (e + 1) + 3,
    4,
    0
  ], f = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(
    (z2) => c[z2]
  );
  let y2, v4, g, S, w, E2, L2, Z2;
  for (let z2 = 0; z2 < 4; z2++) {
    S = z2 < 1 || z2 > 2 ? i : -i, w = z2 < 2 ? o : -o, E2 = z2 < 1 || z2 > 2 ? l : a, L2 = z2 < 2 ? h : d;
    for (let p = 0; p <= e; p++)
      y2 = Math.PI / 2 * (z2 + p / e), v4 = Math.cos(y2), g = Math.sin(y2), r.push(S + s * v4, w + s * g, 0), u.push(E2 + a * v4, L2 + d * g), p < e && (Z2 = (e + 1) * z2 + p + 4, f.push(z2, Z2, Z2 + 1));
  }
  return new Xt().setIndex(new nt(new Uint32Array(f), 1)).setAttribute(
    "position",
    new nt(new Float32Array(r), 3)
  ).setAttribute("uv", new nt(new Float32Array(u), 2));
}
var Oe = (s, e) => {
  const t = new U(), { isSphere: n, radius: i, smoothness: o } = s, a = At(i, o);
  return Y.map((l, d) => {
    const h = d < 3, r = Y[d], u = d ? e.clone() : e;
    Et(u, d);
    const { enabled: c, scale: f, opacity: y2, hover: v4 } = s[r], g = {
      map: u,
      opacity: y2,
      transparent: true
    }, S = n ? new bt(new St(g)) : new V(a, new at(g)), w = h ? r : r[1];
    return S.position[w] = (h ? 1 : -1) * (n ? Kt : 1), n || S.lookAt(t.copy(S.position).multiplyScalar(1.7)), S.scale.setScalar(f), S.renderOrder = 1, S.visible = c, S.userData = {
      scale: f,
      opacity: y2,
      hover: v4
    }, S;
  });
};
var De = (s, e) => {
  const { isSphere: t, corners: n } = s;
  if (!n.enabled) return [];
  const { color: i, opacity: o, scale: a, radius: l, smoothness: d, hover: h } = n, r = t ? null : At(l, d), u = {
    transparent: true,
    opacity: o
  }, c = [
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1
  ].map((y2) => y2 * 0.85), f = new U();
  return Array(c.length / 3).fill(0).map((y2, v4) => {
    if (t) {
      const w = e.clone();
      Et(w, 6), u.map = w;
    } else
      u.color = i;
    const g = t ? new bt(new St(u)) : new V(r, new at(u)), S = v4 * 3;
    return g.position.set(c[S], c[S + 1], c[S + 2]), t && g.position.normalize().multiplyScalar(1.7), g.scale.setScalar(a), g.lookAt(f.copy(g.position).multiplyScalar(2)), g.renderOrder = 1, g.userData = {
      color: i,
      opacity: o,
      scale: a,
      hover: h
    }, g;
  });
};
var Pe = (s, e, t) => {
  const { isSphere: n, edges: i } = s;
  if (!i.enabled) return [];
  const { color: o, opacity: a, scale: l, hover: d, radius: h, smoothness: r } = i, u = n ? null : At(h, r, 1.2, 0.25), c = {
    transparent: true,
    opacity: a
  }, f = [
    0,
    1,
    1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    0,
    1,
    -1,
    0,
    -1,
    1,
    0,
    -1,
    -1,
    0
  ].map((g) => g * 0.925), y2 = new U(), v4 = new U(0, 1, 0);
  return Array(f.length / 3).fill(0).map((g, S) => {
    if (n) {
      const L2 = e.clone();
      Et(L2, t), c.map = L2;
    } else
      c.color = o;
    const w = n ? new bt(new St(c)) : new V(u, new at(c)), E2 = S * 3;
    return w.position.set(f[E2], f[E2 + 1], f[E2 + 2]), n && w.position.normalize().multiplyScalar(1.7), w.scale.setScalar(l), w.up.copy(v4), w.lookAt(y2.copy(w.position).multiplyScalar(2)), !n && !w.position.y && (w.rotation.z = Math.PI / 2), w.renderOrder = 1, w.userData = {
      color: o,
      opacity: a,
      scale: l,
      hover: d
    }, w;
  });
};
function Ge(s, e = false) {
  const t = s[0].index !== null, n = new Set(Object.keys(s[0].attributes)), i = new Set(Object.keys(s[0].morphAttributes)), o = {}, a = {}, l = s[0].morphTargetsRelative, d = new Xt();
  let h = 0;
  for (let r = 0; r < s.length; ++r) {
    const u = s[r];
    let c = 0;
    if (t !== (u.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const f in u.attributes) {
      if (!n.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
      o[f] === void 0 && (o[f] = []), o[f].push(u.attributes[f]), c++;
    }
    if (c !== n.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". Make sure all geometries have the same number of attributes."), null;
    if (l !== u.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const f in u.morphAttributes) {
      if (!i.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ".  .morphAttributes must be consistent throughout all geometries."), null;
      a[f] === void 0 && (a[f] = []), a[f].push(u.morphAttributes[f]);
    }
    if (e) {
      let f;
      if (t)
        f = u.index.count;
      else if (u.attributes.position !== void 0)
        f = u.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". The geometry must have either an index or a position attribute"), null;
      d.addGroup(h, f, r), h += f;
    }
  }
  if (t) {
    let r = 0;
    const u = [];
    for (let c = 0; c < s.length; ++c) {
      const f = s[c].index;
      for (let y2 = 0; y2 < f.count; ++y2)
        u.push(f.getX(y2) + r);
      r += s[c].attributes.position.count;
    }
    d.setIndex(u);
  }
  for (const r in o) {
    const u = It(o[r]);
    if (!u)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + r + " attribute."), null;
    d.setAttribute(r, u);
  }
  for (const r in a) {
    const u = a[r][0].length;
    if (u === 0) break;
    d.morphAttributes = d.morphAttributes || {}, d.morphAttributes[r] = [];
    for (let c = 0; c < u; ++c) {
      const f = [];
      for (let v4 = 0; v4 < a[r].length; ++v4)
        f.push(a[r][v4][c]);
      const y2 = It(f);
      if (!y2)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + r + " morphAttribute."), null;
      d.morphAttributes[r].push(y2);
    }
  }
  return d;
}
function It(s) {
  let e, t, n, i = -1, o = 0;
  for (let h = 0; h < s.length; ++h) {
    const r = s[h];
    if (e === void 0 && (e = r.array.constructor), e !== r.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = r.itemSize), t !== r.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (n === void 0 && (n = r.normalized), n !== r.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (i === -1 && (i = r.gpuType), i !== r.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    o += r.count * t;
  }
  const a = new e(o), l = new nt(a, t, n);
  let d = 0;
  for (let h = 0; h < s.length; ++h) {
    const r = s[h];
    if (r.isInterleavedBufferAttribute) {
      const u = d / t;
      for (let c = 0, f = r.count; c < f; c++)
        for (let y2 = 0; y2 < t; y2++) {
          const v4 = r.getComponent(c, y2);
          l.setComponent(c + u, y2, v4);
        }
    } else
      a.set(r.array, d);
    d += r.count * t;
  }
  return i !== void 0 && (l.gpuType = i), l;
}
var Re = (s, e) => {
  const {
    isSphere: t,
    background: { enabled: n, color: i, opacity: o, hover: a }
  } = e;
  let l;
  const d = new at({
    color: i,
    side: de,
    opacity: o,
    transparent: true,
    depthWrite: false
  });
  if (!n) return null;
  if (t)
    l = new V(
      new ue(1.8, 64, 64),
      d
    );
  else {
    let h;
    s.forEach((r) => {
      const u = r.scale.x;
      r.scale.setScalar(0.9), r.updateMatrix();
      const c = r.geometry.clone();
      c.applyMatrix4(r.matrix), h = h ? Ge([h, c]) : c, r.scale.setScalar(u);
    }), l = new V(h, d);
  }
  return l.userData = {
    color: i,
    opacity: o,
    hover: a
  }, l;
};
var Ft = new xt();
var K = new U();
var te = class extends he {
  constructor() {
    super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new Bt(e, 3)), this.setAttribute("uv", new Bt(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new pt(t, 6, 1);
    return this.setAttribute("instanceStart", new N(n, 3, 0)), this.setAttribute("instanceEnd", new N(n, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new pt(t, 6, 1);
    return this.setAttribute("instanceColorStart", new N(n, 3, 0)), this.setAttribute("instanceColorEnd", new N(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new fe(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new xt());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Ft.setFromBufferAttribute(t), this.boundingBox.union(Ft));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Zt()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let i = 0;
      for (let o = 0, a = e.count; o < a; o++)
        K.fromBufferAttribute(e, o), i = Math.max(i, n.distanceToSquared(K)), K.fromBufferAttribute(t, o), i = Math.max(i, n.distanceToSquared(K));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
};
st.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Q(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
it.line = {
  uniforms: $t.merge([
    st.common,
    st.fog,
    st.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var Mt = class extends pe {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: $t.clone(it.line.uniforms),
      vertexShader: it.line.vertexShader,
      fragmentShader: it.line.fragmentShader,
      clipping: true
      // required for clipping support
    }), this.isLineMaterial = true, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === true ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === true !== this.dashed && (this.needsUpdate = true), e === true ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === true !== this.alphaToCoverage && (this.needsUpdate = true), e === true ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
};
var dt = new X();
var kt = new U();
var Ht = new U();
var A = new X();
var M = new X();
var O = new X();
var ut = new U();
var ht = new Yt();
var T2 = new me();
var jt = new U();
var tt = new xt();
var et = new Zt();
var D = new X();
var P;
var j;
function Wt(s, e, t) {
  return D.set(0, 0, -e, 1).applyMatrix4(s.projectionMatrix), D.multiplyScalar(1 / D.w), D.x = j / t.width, D.y = j / t.height, D.applyMatrix4(s.projectionMatrixInverse), D.multiplyScalar(1 / D.w), Math.abs(Math.max(D.x, D.y));
}
function Ie(s, e) {
  const t = s.matrixWorld, n = s.geometry, i = n.attributes.instanceStart, o = n.attributes.instanceEnd, a = Math.min(n.instanceCount, i.count);
  for (let l = 0, d = a; l < d; l++) {
    T2.start.fromBufferAttribute(i, l), T2.end.fromBufferAttribute(o, l), T2.applyMatrix4(t);
    const h = new U(), r = new U();
    P.distanceSqToSegment(T2.start, T2.end, r, h), r.distanceTo(h) < j * 0.5 && e.push({
      point: r,
      pointOnLine: h,
      distance: P.origin.distanceTo(r),
      object: s,
      face: null,
      faceIndex: l,
      uv: null,
      uv1: null
    });
  }
}
function Fe(s, e, t) {
  const n = e.projectionMatrix, o = s.material.resolution, a = s.matrixWorld, l = s.geometry, d = l.attributes.instanceStart, h = l.attributes.instanceEnd, r = Math.min(l.instanceCount, d.count), u = -e.near;
  P.at(1, O), O.w = 1, O.applyMatrix4(e.matrixWorldInverse), O.applyMatrix4(n), O.multiplyScalar(1 / O.w), O.x *= o.x / 2, O.y *= o.y / 2, O.z = 0, ut.copy(O), ht.multiplyMatrices(e.matrixWorldInverse, a);
  for (let c = 0, f = r; c < f; c++) {
    if (A.fromBufferAttribute(d, c), M.fromBufferAttribute(h, c), A.w = 1, M.w = 1, A.applyMatrix4(ht), M.applyMatrix4(ht), A.z > u && M.z > u)
      continue;
    if (A.z > u) {
      const E2 = A.z - M.z, L2 = (A.z - u) / E2;
      A.lerp(M, L2);
    } else if (M.z > u) {
      const E2 = M.z - A.z, L2 = (M.z - u) / E2;
      M.lerp(A, L2);
    }
    A.applyMatrix4(n), M.applyMatrix4(n), A.multiplyScalar(1 / A.w), M.multiplyScalar(1 / M.w), A.x *= o.x / 2, A.y *= o.y / 2, M.x *= o.x / 2, M.y *= o.y / 2, T2.start.copy(A), T2.start.z = 0, T2.end.copy(M), T2.end.z = 0;
    const v4 = T2.closestPointToPointParameter(ut, true);
    T2.at(v4, jt);
    const g = ge.lerp(A.z, M.z, v4), S = g >= -1 && g <= 1, w = ut.distanceTo(jt) < j * 0.5;
    if (S && w) {
      T2.start.fromBufferAttribute(d, c), T2.end.fromBufferAttribute(h, c), T2.start.applyMatrix4(a), T2.end.applyMatrix4(a);
      const E2 = new U(), L2 = new U();
      P.distanceSqToSegment(T2.start, T2.end, L2, E2), t.push({
        point: L2,
        pointOnLine: E2,
        distance: P.origin.distanceTo(L2),
        object: s,
        face: null,
        faceIndex: c,
        uv: null,
        uv1: null
      });
    }
  }
}
var ke = class extends V {
  constructor(e = new te(), t = new Mt({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = true, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, i = new Float32Array(2 * t.count);
    for (let a = 0, l = 0, d = t.count; a < d; a++, l += 2)
      kt.fromBufferAttribute(t, a), Ht.fromBufferAttribute(n, a), i[l] = l === 0 ? 0 : i[l - 1], i[l + 1] = i[l] + kt.distanceTo(Ht);
    const o = new pt(i, 2, 1);
    return e.setAttribute("instanceDistanceStart", new N(o, 1, 0)), e.setAttribute("instanceDistanceEnd", new N(o, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, i = e.camera;
    i === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const o = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    P = e.ray;
    const a = this.matrixWorld, l = this.geometry, d = this.material;
    j = d.linewidth + o, l.boundingSphere === null && l.computeBoundingSphere(), et.copy(l.boundingSphere).applyMatrix4(a);
    let h;
    if (n)
      h = j * 0.5;
    else {
      const u = Math.max(i.near, et.distanceToPoint(P.origin));
      h = Wt(i, u, d.resolution);
    }
    if (et.radius += h, P.intersectsSphere(et) === false)
      return;
    l.boundingBox === null && l.computeBoundingBox(), tt.copy(l.boundingBox).applyMatrix4(a);
    let r;
    if (n)
      r = j * 0.5;
    else {
      const u = Math.max(i.near, tt.distanceToPoint(P.origin));
      r = Wt(i, u, d.resolution);
    }
    tt.expandByScalar(r), P.intersectsBox(tt) !== false && (n ? Ie(this, t) : Fe(this, i, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(dt), this.material.uniforms.resolution.value.set(dt.z, dt.w));
  }
};
var ee = class extends te {
  constructor() {
    super(), this.isLineGeometry = true, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      n[2 * i] = e[i], n[2 * i + 1] = e[i + 1], n[2 * i + 2] = e[i + 2], n[2 * i + 3] = e[i + 3], n[2 * i + 4] = e[i + 4], n[2 * i + 5] = e[i + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      n[2 * i] = e[i], n[2 * i + 1] = e[i + 1], n[2 * i + 2] = e[i + 2], n[2 * i + 3] = e[i + 3], n[2 * i + 4] = e[i + 4], n[2 * i + 5] = e[i + 5];
    return super.setColors(n), this;
  }
  setFromPoints(e) {
    const t = e.length - 1, n = new Float32Array(6 * t);
    for (let i = 0; i < t; i++)
      n[6 * i] = e[i].x, n[6 * i + 1] = e[i].y, n[6 * i + 2] = e[i].z || 0, n[6 * i + 3] = e[i + 1].x, n[6 * i + 4] = e[i + 1].y, n[6 * i + 5] = e[i + 1].z || 0;
    return super.setPositions(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
};
var He = class extends ke {
  constructor(e = new ee(), t = new Mt({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = true, this.type = "Line2";
  }
};
var je = (s) => {
  const e = new Vt(), t = [], n = [], { isSphere: i } = s;
  if (Y.forEach((l, d) => {
    const { enabled: h, line: r, scale: u, color: c } = s[l];
    if (!h || !r) return;
    const f = d < 3 ? 1 : -1, v4 = (i ? Kt - u / 2 : 0.975) * f;
    t.push(
      l.includes("x") ? v4 : 0,
      l.includes("y") ? v4 : 0,
      l.includes("z") ? v4 : 0,
      0,
      0,
      0
    );
    const g = e.set(c).toArray();
    n.push(...g, ...g);
  }), !t.length) return null;
  const o = new ee().setPositions(t).setColors(n), a = new Mt({
    linewidth: s.lineWidth,
    vertexColors: true,
    resolution: new Q(window.innerWidth, window.innerHeight)
  });
  return new He(o, a).computeLineDistances();
};
var We = (s) => {
  const { corners: e, edges: t } = s, n = [], i = Be(s), o = Oe(s, i);
  n.push(...o), e.enabled && n.push(...De(s, i)), t.enabled && n.push(...Pe(s, i, e.enabled ? 7 : 6));
  const a = Re(o, s), l = je(s);
  return [n, a, l];
};
var $ = (s, e = true) => {
  const { material: t, userData: n } = s, { opacity: i, color: o, scale: a } = e ? n.hover : n;
  s.scale.setScalar(a), t.opacity = i, t.map ? Ce(t.map, e) : t.color.set(o);
};
var q = new Yt();
var qt = new be();
var qe = new Q();
var H = new U();
var Nt = new X();
var Xe = class extends ft {
  /**
   * Creates a new ViewportGizmo instance.
   *
   * @param camera - The camera to be controlled by this gizmo
   * @param renderer - The WebGL renderer used to render the scene
   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.
   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string
   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'
   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128
   * @param options.placement - Position of the gizmo in the viewport
   *    Options include:
   *    - `"top-left"`
   *    - `"top-center"`
   *    - `"top-right"`
   *    - `"center-left"`
   *    - `"center-center"`
   *    - `"center-right"`
   *    - `"bottom-left"`
   *    - `"bottom-center"`
   *    - `"bottom-right"`
   * @param options.offset - Offset of the gizmo from container edges in pixels
   * @param options.offset.left - Offset from the left edge
   * @param options.offset.top - Offset from the top edge
   * @param options.offset.right - Offset from the right edge
   * @param options.offset.bottom - Offset from the bottom edge
   * @param options.animated - Whether view changes should be animated. Defaults to true
   * @param options.speed - Animation speed multiplier. Defaults to 1
   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube
   * @param options.lineWidth - Width of the axes lines in pixels
   * @param options.id - HTML `id` attribute for the gizmo container
   * @param options.className - HTML `class` attribute for the gizmo container
   * @param options.font - Font configuration for axis labels
   * @param options.font.family - Font family for axis labels
   * @param options.font.weight - Font weight for axis labels
   * @param options.background - Configuration for the background sphere/cube
   * @param options.background.enabled - Whether to display the background
   * @param options.background.color - Color of the background in normal state
   * @param options.background.opacity - Opacity of the background in normal state
   * @param options.background.hover.color - Color of the background when hovered
   * @param options.background.hover.opacity - Opacity of the background when hovered
   * @param options.corners - Configuration for corner indicators
   * @param options.corners.enabled - Whether to display corner indicators
   * @param options.corners.color - Base color of corner indicators
   * @param options.corners.opacity - Opacity of corner indicators
   * @param options.corners.scale - Scale multiplier for corner indicators
   * @param options.corners.radius - Radius of corner indicators
   * @param options.corners.smoothness - Smoothness of corner indicators
   * @param options.corners.hover.color - Color of corner indicators when hovered
   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered
   * @param options.corners.hover.scale - Scale of corner indicators when hovered
   * @param options.edges - Configuration for edge indicators
   * @param options.edges.enabled - Whether to display edge indicators
   * @param options.edges.color - Base color of edge indicators
   * @param options.edges.opacity - Opacity of edge indicators
   * @param options.edges.scale - Scale multiplier for edge indicators
   * @param options.edges.radius - Radius of edge indicators
   * @param options.edges.smoothness - Smoothness of edge indicators
   * @param options.edges.hover.color - Color of edge indicators when hovered
   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered
   * @param options.edges.hover.scale - Scale of edge indicators when hovered
   * @param options.x - Configuration for positive X axis/face
   * @param options.y - Configuration for positive Y axis/face
   * @param options.z - Configuration for positive Z axis/face
   * @param options.nx - Configuration for negative X axis/face
   * @param options.ny - Configuration for negative Y axis/face
   * @param options.nz - Configuration for negative Z axis/face
   *
   * @remarks Axis-specific configuration can also use alias names for cube mode:
   * - `right` (same as `x`)
   * - `left` (same as `nx`)
   * - `top` (same as `y`)
   * - `bottom` (same as `ny`)
   * - `front` (same as `z`)
   * - `back` (same as `nz`)
   *
   * For each axis/face configuration, the following options are available:
   * @param options.AXIS.enabled - Whether to draw the axis
   * @param options.AXIS.label - Custom text label for the axis
   * @param options.AXIS.opacity - Axis opacity
   * @param options.AXIS.scale - Scale multiplier for indicator size
   * @param options.AXIS.line - Whether to draw the axis line
   * @param options.AXIS.color - Axis indicator background color
   * @param options.AXIS.labelColor - Axis label color
   * @param options.AXIS.border.size - Border size around the axis indicator
   * @param options.AXIS.border.color - Border color around the axis indicator
   * @param options.AXIS.hover.color - Fill color on hover
   * @param options.AXIS.hover.labelColor - Label text color on hover
   * @param options.AXIS.hover.opacity - Opacity when hovered
   * @param options.AXIS.hover.scale - Indicator scale when hovered
   * @param options.AXIS.hover.border.size - Hover border size
   * @param options.AXIS.hover.border.color - Hover border color
   */
  constructor(t, n, i = {}) {
    super();
    m(this, "enabled", true);
    m(this, "camera");
    m(this, "renderer");
    m(this, "options");
    m(this, "target", new U());
    m(this, "animated", true);
    m(this, "speed", 1);
    m(this, "animating", false);
    m(this, "_options");
    m(this, "_intersections");
    m(this, "_background", null);
    m(this, "_viewport", [0, 0, 0, 0]);
    m(this, "_originalViewport", [0, 0, 0, 0]);
    m(this, "_originalScissor", [0, 0, 0, 0]);
    m(this, "_scene");
    m(this, "_camera");
    m(this, "_container");
    m(this, "_domElement");
    m(this, "_domRect");
    m(this, "_dragging", false);
    m(this, "_distance", 0);
    m(this, "_clock", new ye());
    m(this, "_targetQuaternion", new ct());
    m(this, "_quaternionStart", new ct());
    m(this, "_quaternionEnd", new ct());
    m(this, "_pointerStart", new Q());
    m(this, "_focus", null);
    m(this, "_placement");
    m(this, "_controls");
    m(this, "_controlsListeners");
    this.camera = t, this.renderer = n, this._scene = new _e().add(this), this.set(i);
  }
  /** Gets the current placement of the gizmo relative to its container. */
  get placement() {
    return this._placement;
  }
  /**
   * Sets and update the placement of the gizmo relative to its container.
   *
   * @param placement - The new placement position
   */
  set placement(t) {
    this._placement = Qt(this._domElement, t), this.domUpdate();
  }
  /**
   * Regenerates the gizmo with the new options.
   *
   * @remarks
   * - Not recommended for use in real-time rendering or animation loops
   * - Provides a way to completely rebuild the gizmo with new options
   * - Can be computationally expensive, so use sparingly
   */
  set(t = {}) {
    this.dispose(), this.options = t, this._options = ze(t), this._camera = this._options.isSphere ? new ve(-1.8, 1.8, 1.8, -1.8, 5, 10) : new we(26, 1, 5, 10), this._camera.position.set(0, 0, 7);
    const [n, i, o] = We(this._options);
    i && this.add(i), o && this.add(o), this.add(...n), this._background = i, this._intersections = n;
    const { container: a, animated: l, speed: d } = this._options;
    return this.animated = l, this.speed = d, this._container = a ? xe(a) : document.body, this._domElement = Se(this._options), this._domElement.onpointerdown = (h) => this._onPointerDown(h), this._domElement.onpointermove = (h) => this._onPointerMove(h), this._domElement.onpointerleave = () => this._onPointerLeave(), this._container.appendChild(this._domElement), this._controls && this.attachControls(this._controls), this.update(), this._updateOrientation(true), this;
  }
  /**
   * Renders the gizmo to the screen.
   * This method handles viewport and scissor management to ensure the gizmo
   * renders correctly without affecting the main scene rendering.
   *
   * @returns The gizmo instance for method chaining
   */
  render() {
    this.animating && this._animate();
    const { renderer: t, _viewport: n } = this, i = t.getScissorTest(), o = t.autoClear;
    return t.autoClear = false, t.setViewport(...n), i && t.setScissor(...n), t.clear(false, true, false), t.render(this._scene, this._camera), t.setViewport(...this._originalViewport), i && t.setScissor(...this._originalScissor), t.autoClear = o, this;
  }
  /**
   * Updates the gizmo's DOM-related properties based on its current position
   * and size in the document.
   *
   * @returns The gizmo instance for method chaining
   */
  domUpdate() {
    this._domRect = this._domElement.getBoundingClientRect();
    const t = this.renderer, n = this._domRect, i = t.domElement.getBoundingClientRect();
    return this._viewport.splice(
      0,
      4,
      n.left - i.left,
      t.domElement.clientHeight - (n.top - i.top + n.height),
      n.width,
      n.height
    ), t.getViewport(Nt).toArray(this._originalViewport), t.getScissorTest() && t.getScissor(Nt).toArray(this._originalScissor), this;
  }
  /**
   * Updates the gizmo's orientation to match the current camera orientation.
   *
   * @returns The gizmo instance for method chaining
   */
  cameraUpdate() {
    return this._updateOrientation(), this;
  }
  /**
   * Performs a complete update of the gizmo, including both DOM and camera-related updates.
   *
   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.
   *
   * @returns The gizmo instance for method chaining
   */
  update(t = true) {
    return t && this._controls && this._controls.update(), this.domUpdate().cameraUpdate();
  }
  /**
   * Connects OrbitControls with the gizmo, handling interaction states and updates.
   * Automatically detaches any previously attached controls.
   *
   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}
   */
  attachControls(t) {
    return this.detachControls(), this.target = t.target, this._controlsListeners = {
      start: () => t.enabled = false,
      end: () => t.enabled = true,
      change: () => this.update(false)
    }, this.addEventListener("start", this._controlsListeners.start), this.addEventListener("end", this._controlsListeners.end), t.addEventListener("change", this._controlsListeners.change), this._controls = t, this;
  }
  /** Removes all control event listeners and references. Safe to call multiple times. */
  detachControls() {
    if (!(!this._controlsListeners || !this._controls))
      return this.target = new U().copy(this._controls.target), this.removeEventListener("start", this._controlsListeners.start), this.removeEventListener("end", this._controlsListeners.end), this._controls.removeEventListener(
        "change",
        this._controlsListeners.change
      ), this._controlsListeners = void 0, this._controls = void 0, this;
  }
  /** Cleans up all resources including geometries, materials, textures, and event listeners. */
  dispose() {
    var t;
    this.detachControls(), this.children.forEach((n) => {
      var o, a, l, d;
      this.remove(n);
      const i = n;
      (o = i.material) == null || o.dispose(), (l = (a = i.material) == null ? void 0 : a.map) == null || l.dispose(), (d = i.geometry) == null || d.dispose();
    }), (t = this._domElement) == null || t.remove();
  }
  /**
   * Updates the gizmo's orientation either based on the camera or internal state.
   *
   * @private
   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)
   */
  _updateOrientation(t = true) {
    t && (this.quaternion.copy(this.camera.quaternion).invert(), this.updateMatrixWorld()), Ot(this._options, this._intersections, this.camera);
  }
  /**
   * Handles the animation of camera position and orientation changes.
   *
   * @private
   */
  _animate() {
    const { position: t, quaternion: n } = this.camera;
    if (t.set(0, 0, 1), !this.animated) {
      t.applyQuaternion(this._quaternionEnd).multiplyScalar(this._distance).add(this.target), n.copy(this._targetQuaternion), this._updateOrientation(), this.animating = false, this.dispatchEvent({ type: "change" }), this.dispatchEvent({ type: "end" });
      return;
    }
    this._controls && (this._controls.enabled = false);
    const o = this._clock.getDelta() * Me * this.speed;
    this._quaternionStart.rotateTowards(this._quaternionEnd, o), t.applyQuaternion(this._quaternionStart).multiplyScalar(this._distance).add(this.target), n.rotateTowards(this._targetQuaternion, o), this._updateOrientation(), requestAnimationFrame(() => this.dispatchEvent({ type: "change" })), this._quaternionStart.angleTo(this._quaternionEnd) < lt && (this._controls && (this._controls.enabled = true), this.animating = false, this.dispatchEvent({ type: "end" }));
  }
  /**
   * Sets the camera orientation to look at the target from a specific axis.
   *
   * @private
   * @param position - The axis point position
   */
  _setOrientation(t) {
    const n = this.camera, i = this.target;
    H.copy(t).multiplyScalar(this._distance), q.setPosition(H).lookAt(H, this.position, this.up), this._targetQuaternion.setFromRotationMatrix(q), H.add(i), q.lookAt(H, i, this.up), this._quaternionEnd.setFromRotationMatrix(q), q.setPosition(n.position).lookAt(n.position, i, this.up), this._quaternionStart.setFromRotationMatrix(q), this.animating = true, this._clock.start(), this.dispatchEvent({ type: "start" });
  }
  /**
   * Handles the pointer down event for starting drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerDown(t) {
    if (!this.enabled) return;
    const n = (h) => {
      if (!this._dragging) {
        if (Ae(h, this._pointerStart)) return;
        this._dragging = true;
      }
      const r = qe.set(h.clientX, h.clientY).sub(this._pointerStart).multiplyScalar(1 / this._domRect.width * Math.PI), u = this.coordinateConversion(
        H.subVectors(this.camera.position, this.target)
      ), c = qt.setFromVector3(u);
      c.theta = l - r.x, c.phi = mt(
        d - r.y,
        lt,
        Math.PI - lt
      ), this.coordinateConversion(
        this.camera.position.setFromSpherical(c),
        true
      ).add(this.target), this.camera.lookAt(this.target), this.quaternion.copy(this.camera.quaternion).invert(), this._updateOrientation(false), this.dispatchEvent({ type: "change" });
    }, i = () => {
      if (document.removeEventListener("pointermove", n, false), document.removeEventListener("pointerup", i, false), !this._dragging) return this._handleClick(t);
      this._focus && ($(this._focus, false), this._focus = null), this._dragging = false, this.dispatchEvent({ type: "end" });
    };
    if (this.animating) return;
    t.preventDefault(), this._pointerStart.set(t.clientX, t.clientY);
    const o = this.coordinateConversion(
      H.subVectors(this.camera.position, this.target)
    ), a = qt.setFromVector3(o), l = a.theta, d = a.phi;
    this._distance = a.radius, document.addEventListener("pointermove", n, false), document.addEventListener("pointerup", i, false), this.dispatchEvent({ type: "start" });
  }
  /**
   * Converts the input-coordinates from the standard Y-axis up to what is set in Object3D.DEFAULT_UP.
   *
   * @private
   * @param target      - The target Vector3 to be converted
   * @param isSpherical - Whether or not the coordinates are for a sphere
   * @returns The converted coordinates
   */
  coordinateConversion(t, n = false) {
    const { x: i, y: o, z: a } = t, l = ft.DEFAULT_UP;
    return l.x === 1 ? n ? t.set(o, a, i) : t.set(a, i, o) : l.z === 1 ? n ? t.set(a, i, o) : t.set(o, a, i) : t;
  }
  /**
   * Handles pointer move events for hover effects and drag operations.
   *
   * @private
   * @param e - The pointer event
   */
  _onPointerMove(t) {
    !this.enabled || this._dragging || (this._background && Rt(this._background, true), this._handleHover(t));
  }
  /**
   * Handles pointer leave events to reset hover states.
   *
   * @private
   */
  _onPointerLeave() {
    !this.enabled || this._dragging || (this._background && Rt(this._background, false), this._focus && $(this._focus, false), this._domElement.style.cursor = "");
  }
  /**
   * Handles click events for axis selection.
   *
   * @private
   * @param e - The pointer event
   */
  _handleClick(t) {
    const n = Gt(
      t,
      this._domRect,
      this._camera,
      this._intersections
    );
    this._focus && ($(this._focus, false), this._focus = null), n && (this._setOrientation(n.object.position), this.dispatchEvent({ type: "change" }));
  }
  /**
   * Handles hover effects for interactive elements.
   *
   * @private
   * @param e - The pointer event
   */
  _handleHover(t) {
    const n = Gt(
      t,
      this._domRect,
      this._camera,
      this._intersections
    ), i = (n == null ? void 0 : n.object) || null;
    this._focus !== i && (this._domElement.style.cursor = i ? "pointer" : "", this._focus && $(this._focus, false), (this._focus = i) ? $(i, true) : Ot(this._options, this._intersections, this.camera));
  }
};

// node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { TrackballControls } from "three/examples/jsm/controls/TrackballControls.js";
Gizmo[FILENAME] = "node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte";
function Gizmo($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Gizmo);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let ref = prop($$props, "ref", 15), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "controls",
      "renderTask",
      "ref",
      "onstart",
      "onchange",
      "onend"
    ],
    "rest"
  );
  const parent = useParent();
  const {
    camera,
    renderer,
    dom,
    autoRenderTask,
    shouldRender,
    size,
    invalidate
  } = useThrelte();
  const gizmo = tag(
    user_derived(() => {
      invalidate();
      return new Xe(camera.current, renderer, { container: dom, placement: "bottom-left", size: 86, ...rest });
    }),
    "gizmo"
  );
  user_pre_effect(() => {
    if (strict_equals(ref(), get(gizmo), false)) {
      ref(get(gizmo));
    }
  });
  const viewport = new Vector42();
  const cameraControls = tag(user_derived(() => $$props.controls ?? $parent()), "cameraControls");
  useTask(
    $$props.renderTask?.key ?? /* @__PURE__ */ Symbol("threlte-extras-gizmo-render"),
    () => {
      if (shouldRender()) {
        const toneMapping = renderer.toneMapping;
        renderer.getViewport(viewport);
        renderer.toneMapping = NoToneMapping;
        get(gizmo).render();
        renderer.setViewport(viewport);
        renderer.toneMapping = toneMapping;
      }
    },
    {
      autoInvalidate: false,
      ...$$props.renderTask ?? { after: autoRenderTask }
    }
  );
  user_pre_effect(() => {
    get(gizmo).camera = $camera();
  });
  user_pre_effect(() => {
    if (!get(cameraControls)) return;
    if (get(cameraControls) instanceof OrbitControls || get(cameraControls) instanceof TrackballControls) {
      get(gizmo).target = get(cameraControls).target;
      const handleChange2 = () => {
        get(gizmo).update(false);
      };
      get(cameraControls).addEventListener("change", handleChange2);
      return () => get(cameraControls).removeEventListener("change", handleChange2);
    } else {
      const handleUpdate = () => {
        if ("getTarget" in get(cameraControls) && equals(typeof get(cameraControls).getTarget, "function")) {
          get(cameraControls).getTarget(get(gizmo).target);
          get(gizmo).update();
        }
      };
      const handleChange2 = () => {
        get(cameraControls).setPosition(...camera.current.position.toArray());
      };
      get(gizmo).addEventListener("change", handleChange2);
      get(cameraControls).addEventListener("update", handleUpdate);
      return () => {
        get(gizmo).removeEventListener("change", handleChange2);
        get(cameraControls).removeEventListener("update", handleUpdate);
      };
    }
  });
  const handleStart = (event) => {
    get(cameraControls).enabled = false;
    $$props.onstart?.(event);
  };
  const handleChange = (event) => {
    invalidate();
    $$props.onchange?.(event);
  };
  const handleEnd = (event) => {
    get(cameraControls).enabled = true;
    $$props.onend?.(event);
  };
  user_pre_effect(() => {
    get(gizmo).addEventListener("start", handleStart);
    get(gizmo).addEventListener("change", handleChange);
    get(gizmo).addEventListener("end", handleEnd);
    return () => {
      get(gizmo).removeEventListener("start", handleStart);
      get(gizmo).removeEventListener("change", handleChange);
      get(gizmo).removeEventListener("end", handleEnd);
    };
  });
  observe.pre(() => [size], () => {
    get(gizmo).update();
    invalidate();
  });
  user_pre_effect(() => {
    return () => get(gizmo).dispose();
  });
  var $$exports = { ...legacy_api() };
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Gizmo = hmr(Gizmo);
  import.meta.hot.accept((module) => {
    Gizmo[HMR].update(module.default);
  });
}
var Gizmo_default = Gizmo;

// node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte
import {
  Color,
  Group as Group3,
  Mesh as Mesh3,
  MeshBasicMaterial as MeshBasicMaterial2,
  MeshDepthMaterial,
  OrthographicCamera as OrthographicCamera3,
  PlaneGeometry,
  ShaderMaterial,
  WebGLRenderTarget as WebGLRenderTarget2
} from "three";
import { HorizontalBlurShader } from "three/examples/jsm/shaders/HorizontalBlurShader.js";
import { VerticalBlurShader } from "three/examples/jsm/shaders/VerticalBlurShader.js";
ContactShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte";
var root_22 = add_locations(from_html(`<!> <!> <!>`, 1), ContactShadows[FILENAME], []);
function ContactShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ContactShadows);
  var $$ownership_validator = create_ownership_validator($$props);
  let opacity = prop($$props, "opacity", 3, 1), width2 = prop($$props, "width", 3, 1), height2 = prop($$props, "height", 3, 1), blur = prop($$props, "blur", 3, 1), far = prop($$props, "far", 3, 10), smooth = prop($$props, "smooth", 3, true), resolution = prop($$props, "resolution", 3, 512), frames = prop($$props, "frames", 3, Infinity), scale = prop($$props, "scale", 3, 10), color = prop($$props, "color", 3, "#000000"), depthWrite = prop($$props, "depthWrite", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "opacity",
      "width",
      "height",
      "blur",
      "far",
      "smooth",
      "resolution",
      "frames",
      "scale",
      "color",
      "depthWrite",
      "ref",
      "children"
    ],
    "props"
  );
  const { scene, renderer } = useThrelte();
  const group = new Group3();
  const scaledWidth = tag(user_derived(() => width2() * (Array.isArray(scale()) ? scale()[0] : scale() || 1)), "scaledWidth");
  const scaledHeight = tag(user_derived(() => height2() * (Array.isArray(scale()) ? scale()[1] : scale() || 1)), "scaledHeight");
  const renderTarget = tag(
    user_derived(() => {
      const rt3 = new WebGLRenderTarget2(resolution(), resolution());
      rt3.texture.generateMipmaps = false;
      rt3.texture.colorSpace = renderer.outputColorSpace;
      return rt3;
    }),
    "renderTarget"
  );
  const renderTargetBlur = tag(
    user_derived(() => {
      const rt3 = new WebGLRenderTarget2(resolution(), resolution());
      rt3.texture.generateMipmaps = false;
      return rt3;
    }),
    "renderTargetBlur"
  );
  const planeGeometry = tag(user_derived(() => new PlaneGeometry(get(scaledWidth), get(scaledHeight)).rotateX(Math.PI / 2)), "planeGeometry");
  const blurPlane = tag(user_derived(() => new Mesh3(get(planeGeometry))), "blurPlane");
  const depthMaterial = tag(
    user_derived(() => {
      const dm = new MeshDepthMaterial({ depthTest: false, depthWrite: false });
      dm.onBeforeCompile = (shader) => {
        shader.uniforms = {
          ...shader.uniforms,
          uColor: { value: new Color(color()).convertSRGBToLinear() }
        };
        shader.fragmentShader = `uniform vec3 uColor;
${shader.fragmentShader}`;
        shader.fragmentShader = shader.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );");
        shader.fragmentShader = shader.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
      };
      return dm;
    }),
    "depthMaterial"
  );
  const horizontalBlurMaterial = new ShaderMaterial({ ...HorizontalBlurShader, depthTest: false });
  const verticalBlurMaterial = new ShaderMaterial({ ...VerticalBlurShader, depthTest: false });
  const shadowCamera = tag(user_derived(() => new OrthographicCamera3(-get(scaledWidth) / 2, get(scaledWidth) / 2, get(scaledHeight) / 2, -get(scaledHeight) / 2, 0, far())), "shadowCamera");
  user_pre_effect(() => get(shadowCamera).updateProjectionMatrix());
  const shadowMaterial = tag(
    user_derived(() => new MeshBasicMaterial2({
      map: get(renderTarget).texture,
      transparent: true,
      opacity: opacity(),
      depthWrite: depthWrite()
    })),
    "shadowMaterial"
  );
  const blurShadows = (blur2) => {
    get(blurPlane).visible = true;
    get(blurPlane).material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = get(renderTarget).texture;
    horizontalBlurMaterial.uniforms.h.value = blur2 * 1 / 256;
    renderer.setRenderTarget(get(renderTargetBlur));
    renderer.render(get(blurPlane), get(shadowCamera));
    get(blurPlane).material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = get(renderTargetBlur).texture;
    verticalBlurMaterial.uniforms.v.value = blur2 * 1 / 256;
    renderer.setRenderTarget(get(renderTarget));
    renderer.render(get(blurPlane), get(shadowCamera));
    get(blurPlane).visible = false;
  };
  const renderShadows = () => {
    const initialBackground = scene.background;
    scene.background = null;
    const initialOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = get(depthMaterial);
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    renderer.setRenderTarget(get(renderTarget));
    renderer.render(scene, get(shadowCamera));
    scene.overrideMaterial = initialOverrideMaterial;
    blurShadows(blur());
    if (smooth()) blurShadows(blur() * 0.4);
    renderer.setRenderTarget(null);
    scene.background = initialBackground;
    renderer.setClearAlpha(initialClearAlpha);
  };
  const refresh = () => {
    renderShadows();
  };
  const task = useTask(
    () => {
      renderShadows();
    },
    { autoStart: false }
  );
  let count = 0;
  const countTask = useTask(
    () => {
      renderShadows();
      count += 1;
      if (count >= frames()) countTask.stop();
    },
    { autoStart: false }
  );
  user_pre_effect(() => {
    if (strict_equals(frames(), Number.POSITIVE_INFINITY)) {
      task.start();
    } else if (count < frames()) {
      countTask.start();
    }
  });
  onDestroy(() => {
    get(renderTarget).dispose();
    get(renderTargetBlur).dispose();
    get(planeGeometry).dispose();
    get(depthMaterial).dispose();
    horizontalBlurMaterial.dispose();
    verticalBlurMaterial.dispose();
    get(shadowMaterial).dispose();
  });
  var $$exports = {
    get refresh() {
      return refresh;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return group;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(ContactShadows, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => component(node_1, () => T.Group, ($$anchor3, T_Group) => {
                T_Group($$anchor3, {
                  "rotation.x": Math.PI / 2,
                  children: wrap_snippet(ContactShadows, ($$anchor4, $$slotProps2) => {
                    var fragment_2 = root_22();
                    var node_2 = first_child(fragment_2);
                    add_svelte_meta(
                      () => component(node_2, () => T.Mesh, ($$anchor5, T_Mesh) => {
                        T_Mesh($$anchor5, {
                          "scale.y": -1,
                          "rotation.x": -Math.PI / 2,
                          get material() {
                            return get(shadowMaterial);
                          },
                          get geometry() {
                            return get(planeGeometry);
                          }
                        });
                      }),
                      "component",
                      ContactShadows,
                      218,
                      4,
                      { componentTag: "T.Mesh" }
                    );
                    var node_3 = sibling(node_2, 2);
                    add_svelte_meta(
                      () => T(node_3, {
                        get is() {
                          return get(shadowCamera);
                        },
                        manual: true
                      }),
                      "component",
                      ContactShadows,
                      224,
                      4,
                      { componentTag: "T" }
                    );
                    var node_4 = sibling(node_3, 2);
                    add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group })), "render", ContactShadows, 228, 4);
                    append($$anchor4, fragment_2);
                  }),
                  $$slots: { default: true }
                });
              }),
              "component",
              ContactShadows,
              217,
              2,
              { componentTag: "T.Group" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      ContactShadows,
      212,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  ContactShadows = hmr(ContactShadows);
  import.meta.hot.accept((module) => {
    ContactShadows[HMR].update(module.default);
  });
}
var ContactShadows_default = ContactShadows;

// node_modules/@threlte/extras/dist/components/environment/CubeEnvironment/CubeEnvironment.svelte
import { CubeTextureLoader } from "three";
import { HDRCubeTextureLoader } from "three/examples/jsm/loaders/HDRCubeTextureLoader.js";

// node_modules/@threlte/extras/dist/components/environment/utils/useEnvironment.svelte.js
var useEnvironment = (options) => {
  const { invalidate } = useThrelte();
  observe(() => [options.scene], ([scene]) => {
    const { background: background2, environment: environment2 } = scene;
    return () => {
      scene.background = background2;
      scene.environment = environment2;
    };
  });
  let background = tag(state(void 0), "background");
  let environment = tag(state(void 0), "environment");
  observe(() => [options.scene], ([scene]) => {
    set(background, scene.background, true);
    set(environment, scene.environment, true);
  });
  user_effect(() => {
    if (strict_equals(options.texture, void 0) || !options.isBackground) {
      return;
    }
    options.scene.background = options.texture;
    invalidate();
    return () => {
      if (strict_equals(get(background), void 0, false)) {
        options.scene.background = get(background);
        invalidate();
      }
    };
  });
  user_effect(() => {
    if (strict_equals(options.texture, void 0)) {
      return;
    }
    options.scene.environment = options.texture;
    invalidate();
    return () => {
      if (strict_equals(get(environment), void 0, false)) {
        options.scene.environment = get(environment);
        invalidate();
      }
    };
  });
};

// node_modules/@threlte/extras/dist/components/environment/CubeEnvironment/CubeEnvironment.svelte
CubeEnvironment[FILENAME] = "node_modules/@threlte/extras/dist/components/environment/CubeEnvironment/CubeEnvironment.svelte";
var loaders = {};
function CubeEnvironment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CubeEnvironment);
  const ctx = useThrelte();
  let isBackground = prop($$props, "isBackground", 3, false), scene = prop($$props, "scene", 19, () => ctx.scene), texture = prop($$props, "texture", 15);
  const cache = useCache();
  const suspend = useSuspense();
  useEnvironment({
    get scene() {
      return scene();
    },
    get isBackground() {
      return isBackground();
    },
    get texture() {
      return texture();
    }
  });
  const first2 = tag(user_derived(() => $$props.urls?.[0]), "first");
  const firstIsHDR = tag(user_derived(() => get(first2)?.endsWith("hdr") ?? false), "firstIsHDR");
  const loader = tag(
    user_derived(() => {
      if (strict_equals($$props.urls, void 0)) return;
      if (get(firstIsHDR)) {
        loaders.hdr ??= new HDRCubeTextureLoader();
        return loaders.hdr;
      }
      loaders.tex ??= new CubeTextureLoader();
      return loaders.tex;
    }),
    "loader"
  );
  user_effect(() => {
    if (strict_equals($$props.urls, void 0) || strict_equals(get(loader), void 0)) {
      return;
    }
    const suspendedTexture = suspend(cache.remember(
      () => {
        return get(loader).loadAsync($$props.urls);
      },
      $$props.urls
    ));
    suspendedTexture.then((t) => {
      texture(t);
    });
    return () => {
      suspendedTexture.then((texture2) => {
        texture2.dispose();
      });
    };
  });
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  CubeEnvironment = hmr(CubeEnvironment);
  import.meta.hot.accept((module) => {
    CubeEnvironment[HMR].update(module.default);
  });
}
var CubeEnvironment_default = CubeEnvironment;

// node_modules/@threlte/extras/dist/components/environment/Environment/Environment.svelte
import { EquirectangularReflectionMapping, TextureLoader as TextureLoader2 } from "three";
import { EXRLoader } from "three/examples/jsm/loaders/EXRLoader.js";
import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader.js";
import { GroundedSkybox } from "three/examples/jsm/objects/GroundedSkybox.js";
Environment[FILENAME] = "node_modules/@threlte/extras/dist/components/environment/Environment/Environment.svelte";
var loaders2 = {};
function Environment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Environment);
  var $$ownership_validator = create_ownership_validator($$props);
  const ctx = useThrelte();
  let skybox = prop($$props, "skybox", 15), texture = prop($$props, "texture", 15), ground = prop($$props, "ground", 3, false), isBackground = prop($$props, "isBackground", 3, false), scene = prop($$props, "scene", 19, () => ctx.scene);
  const suspend = useSuspense();
  const cache = useCache();
  useEnvironment({
    get scene() {
      return scene();
    },
    get isBackground() {
      return isBackground();
    },
    get texture() {
      return texture();
    }
  });
  const isEXR = tag(user_derived(() => $$props.url?.endsWith("exr") ?? false), "isEXR");
  const isHDR = tag(user_derived(() => $$props.url?.endsWith("hdr") ?? false), "isHDR");
  const loader = tag(
    user_derived(() => {
      if (strict_equals($$props.url, void 0)) return;
      if (get(isEXR)) {
        loaders2.exr ??= new EXRLoader();
        return loaders2.exr;
      } else if (get(isHDR)) {
        loaders2.hdr ??= new RGBELoader();
        return loaders2.hdr;
      }
      loaders2.tex ??= new TextureLoader2();
      return loaders2.tex;
    }),
    "loader"
  );
  user_pre_effect(() => {
    if (strict_equals($$props.url, void 0) || strict_equals(get(loader), void 0)) {
      return;
    }
    const suspendedTexture = suspend(cache.remember(
      () => {
        return get(loader).loadAsync($$props.url);
      },
      [$$props.url]
    ));
    suspendedTexture.then((t) => {
      t.mapping = EquirectangularReflectionMapping;
      texture(t);
    });
    return () => {
      suspendedTexture.then((texture2) => {
        texture2.dispose();
      });
    };
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent_1 = ($$anchor2) => {
      const options = tag(user_derived(() => strict_equals(ground(), true) ? {} : ground()), "options");
      get(options);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            let $0 = user_derived(() => [
              texture(),
              get(options).height ?? 1,
              get(options).radius ?? 1,
              get(options).resolution ?? 128
            ]);
            $$ownership_validator.binding("skybox", T, skybox);
            add_svelte_meta(
              () => T(node_2, {
                get is() {
                  return GroundedSkybox;
                },
                get args() {
                  return get($0);
                },
                get ref() {
                  return skybox();
                },
                set ref($$value) {
                  skybox($$value);
                }
              }),
              "component",
              Environment,
              92,
              4,
              { componentTag: "T" }
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (texture()) $$render(consequent);
          }),
          "if",
          Environment,
          91,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (ground()) $$render(consequent_1);
      }),
      "if",
      Environment,
      89,
      0
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Environment = hmr(Environment);
  import.meta.hot.accept((module) => {
    Environment[HMR].update(module.default);
  });
}
var Environment_default = Environment;

// node_modules/@threlte/extras/dist/hooks/useCubeCamera.svelte.js
import { CubeCamera, WebGLCubeRenderTarget } from "three";
var DEFAULT_NEAR = 1;
var DEFAULT_FAR = 1e3;
var DEFAULT_RESOLUTION = 256;
var useCubeCamera = (near = () => DEFAULT_FAR, far = () => DEFAULT_FAR, resolution = () => DEFAULT_RESOLUTION) => {
  const renderTarget = new WebGLCubeRenderTarget(resolution());
  const camera = new CubeCamera(DEFAULT_NEAR, DEFAULT_FAR, renderTarget);
  user_effect(() => {
    const _resolution = resolution();
    renderTarget.setSize(_resolution, _resolution);
  });
  user_effect(() => {
    const _near = near();
    for (const child2 of camera.children) {
      if (isInstanceOf(child2, "PerspectiveCamera")) {
        child2.near = _near;
        child2.updateProjectionMatrix();
      }
    }
  });
  user_effect(() => {
    const _far = far();
    for (const child2 of camera.children) {
      if (isInstanceOf(child2, "PerspectiveCamera")) {
        child2.far = _far;
        child2.updateProjectionMatrix();
      }
    }
  });
  user_effect(() => {
    return () => {
      renderTarget.dispose();
    };
  });
  return { camera, renderTarget };
};

// node_modules/@threlte/extras/dist/components/environment/VirtualEnvironment/VirtualEnvironment.svelte
VirtualEnvironment[FILENAME] = "node_modules/@threlte/extras/dist/components/environment/VirtualEnvironment/VirtualEnvironment.svelte";
var root_13 = add_locations(from_html(`<!> <!>`, 1), VirtualEnvironment[FILENAME], []);
function VirtualEnvironment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, VirtualEnvironment);
  const $started = () => (validate_store(started, "started"), store_get(started, "$started", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  const ctx = useThrelte();
  let far = prop($$props, "far", 3, 1e3), frames = prop($$props, "frames", 3, Infinity), isBackground = prop($$props, "isBackground", 3, false), near = prop($$props, "near", 3, 0.1), resolution = prop($$props, "resolution", 3, 256), parentScene = prop($$props, "scene", 19, () => ctx.scene);
  const { scene } = createSceneContext();
  const { camera, renderTarget } = useCubeCamera(() => near(), () => far(), () => resolution());
  useEnvironment({
    texture: renderTarget.texture,
    get scene() {
      return parentScene();
    },
    get isBackground() {
      return isBackground();
    }
  });
  const update = () => {
    camera.update(ctx.renderer, scene);
  };
  let count = 0;
  const { start, stop, started } = useTask(
    () => {
      if (count < frames()) {
        update();
        count += 1;
      } else {
        stop();
        $$props.onupdatestop?.();
      }
    },
    { autoStart: false }
  );
  const restart = () => {
    if ($started()) {
      stop();
      $$props.onupdatestop?.();
    }
    count = 0;
    start();
    $$props.onupdatestart?.();
  };
  observe(() => [far(), near(), frames(), resolution()], restart);
  var $$exports = {
    get camera() {
      return camera;
    },
    get renderTarget() {
      return renderTarget;
    },
    get update() {
      return update;
    },
    get restart() {
      return restart;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    let $0 = user_derived(() => $$props.visible ? void 0 : false);
    add_svelte_meta(
      () => T(node, {
        get is() {
          return scene;
        },
        get attach() {
          return get($0);
        },
        children: wrap_snippet(VirtualEnvironment, ($$anchor2, $$slotProps) => {
          var fragment_1 = root_13();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(
            () => T(node_1, {
              get is() {
                return camera;
              }
            }),
            "component",
            VirtualEnvironment,
            78,
            2,
            { componentTag: "T" }
          );
          var node_2 = sibling(node_1, 2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ camera, renderTarget, restart, update })), "render", VirtualEnvironment, 79, 2);
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      VirtualEnvironment,
      74,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  VirtualEnvironment = hmr(VirtualEnvironment);
  import.meta.hot.accept((module) => {
    VirtualEnvironment[HMR].update(module.default);
  });
}
var VirtualEnvironment_default = VirtualEnvironment;

// node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte
import { Color as Color2, ShaderMaterial as ShaderMaterial2, Vector2 as Vector23, Vector3 as Vector37 } from "three";

// node_modules/@threlte/extras/dist/components/ImageMaterial/shaders.js
var vertexShader = (
  /* glsl */
  `
varying vec2 vUv;
varying vec2 vPos;
void main () {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
  vUv = uv;
  vPos = position.xy;
}
`
);
var fragmentShader = (
  /* glsl */
  `
// Majority from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
varying vec2 vUv;
varying vec2 vPos;
uniform vec2 scale;
uniform vec2 imageBounds;
uniform float resolution;
uniform vec3 color;
uniform sampler2D map;
uniform sampler2D colorProccessingTexture;
uniform float radius;
uniform float zoom;
uniform float alphaThreshold;
uniform float alphaSmoothing;
uniform float brightness;
uniform float contrast;
uniform float monochromeStrength;
uniform vec3 monochromeColor;
uniform float negative;
uniform vec3 hsl;
uniform float grayscale;
uniform float opacity;
uniform int colorProcessingEnabled;
uniform int colorProcessingTextureOverride;

#define PI 3.14159265;

vec2 aspect(vec2 size) {
  return size / min(size.x, size.y);
}

// from https://iquilezles.org/articles/distfunctions
float udRoundBox(vec2 p, vec2 b, float r) {
  return length(max(abs(p) - b + r, 0.0)) - r;
}

float hueToRgb(float p, float q, float t) {
  if (t < 0.0f)
    t += 1.0f;
  if (t > 1.0f)
    t -= 1.0f;
  if (t < 1.0f / 6.0f)
    return p + (q - p) * 6.0f * t;
  if (t < 1.0f / 2.0f)
    return q;
  if (t < 2.0f / 3.0f)
    return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
  return p;
}

vec3 rgbToHsl(vec3 color) {
  float max = max(max(color.r, color.g), color.b);
  float min = min(min(color.r, color.g), color.b);
  float h, s, l = (max + min) / 2.0f;

  if (max == min) {
    h = s = 0.0f;
  } else {
    float d = max - min;
    s = l > 0.5f ? d / (2.0f - max - min) : d / (max + min);
    if (max == color.r) {
      h = (color.g - color.b) / d + (color.g < color.b ? 6.0f : 0.0f);
    } else if (max == color.g) {
      h = (color.b - color.r) / d + 2.0f;
    } else if (max == color.b) {
      h = (color.r - color.g) / d + 4.0f;
    }
    h /= 6.0f;
  }

  return vec3(h, s, l);
}

vec3 hslToRgb(vec3 hsl) {
  float h = hsl.x;
  float s = hsl.y;
  float l = hsl.z;

  float r, g, b;

  if (s == 0.0f) {
    r = g = b = l;
  } else {
    float q = l < 0.5f ? l * (1.0f + s) : l + s - l * s;
    float p = 2.0f * l - q;
    r = hueToRgb(p, q, h + 1.0f / 3.0f);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1.0f / 3.0f);
  }

  return vec3(r, g, b);
}

vec3 monochrome(float x, vec3 col) {
  return col * exp(4.0 * x - 1.0);
}

void processColors (inout vec4 colors) {
	vec4 strength = vec4(1.0);

	if (colorProcessingTextureOverride == 1) {
		strength = texture2D(colorProccessingTexture, vUv);

		float smoothedAlpha = smoothstep(1.0 - alphaThreshold - alphaSmoothing, 1.0 - alphaThreshold, strength.a + 0.0001);
		colors.a *= smoothedAlpha;

		if (gl_FragColor.a == 0.0) {
			discard;
			return;
		}
	}

	// BRIGHTNESS
	colors.rgb = max(colors.rgb + brightness, 0.0);

	// CONTRAST
  colors.rgb = max(((colors.rgb - 0.5) * max(contrast + 1.0, 0.0)) + 0.5, 0.0);

	// HSL
	vec3 hslColor = rgbToHsl(colors.rgb);
	hslColor.x = mod(hslColor.x + hsl.x * strength.r ,1.0);
	hslColor.y *= (1.0 + hsl.y * strength.g);
	hslColor.z += hsl.z * strength.b;
	colors.rgb = max(hslToRgb(hslColor), vec3(0.0));

	// MONOCHROME
	colors.rgb = mix(colors.rgb, monochrome(hslColor.z, monochromeColor), monochromeStrength);
}

void main() {
  vec2 s = aspect(scale);
  vec2 i = aspect(imageBounds);
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vUv * s / new + offset;
  vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

  vec2 res = vec2(scale * resolution);
  vec2 halfRes = 0.5 * res;
  float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
  vec3 a = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 1.0, b));

	gl_FragColor = texture2D(map, zUv) * vec4(color, opacity * a);

	if (colorProcessingEnabled == 1) {
	  processColors(gl_FragColor);
	}

	if (gl_FragColor.a == 0.0) {
	  discard;
	}

  #include <tonemapping_fragment>
  #include <colorspace_fragment>
	gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0) - gl_FragColor.rgb, negative);
}
`
);

// node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte
ImageMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte";
function ImageMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ImageMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  const $textureStore = () => (validate_store(get(textureStore), "textureStore"), store_get(get(textureStore), "$textureStore", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let color = prop($$props, "color", 3, "white"), zoom = prop($$props, "zoom", 3, 1), radius = prop($$props, "radius", 3, 0), alphaThreshold = prop($$props, "alphaThreshold", 3, 0), alphaSmoothing = prop($$props, "alphaSmoothing", 3, 0.1), brightness = prop($$props, "brightness", 3, 0), contrast = prop($$props, "contrast", 3, 0), hue = prop($$props, "hue", 3, 0), saturation = prop($$props, "saturation", 3, 0), lightness = prop($$props, "lightness", 3, 0), negative = prop($$props, "negative", 3, false), opacity = prop($$props, "opacity", 3, 1), toneMapped = prop($$props, "toneMapped", 3, true), transparent = prop($$props, "transparent", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "color",
      "zoom",
      "radius",
      "alphaThreshold",
      "alphaSmoothing",
      "brightness",
      "contrast",
      "hue",
      "saturation",
      "lightness",
      "negative",
      "opacity",
      "toneMapped",
      "transparent",
      "texture",
      "monochromeColor",
      "monochromeStrength",
      "colorProcessingTexture",
      "side",
      "url",
      "ref",
      "children"
    ],
    "props"
  );
  const material2 = new ShaderMaterial2();
  user_pre_effect(() => {
    if ($$props.side) material2.side = $$props.side;
  });
  const suspend = useSuspense();
  const textureStore = tag(
    user_derived(() => suspend($$props.url ? useTexture($$props.url) : asyncWritable(Promise.resolve($$props.texture)))),
    "textureStore"
  );
  let { size } = useThrelte();
  const parent = useParent();
  const uniforms = {
    color: { value: new Color2(color()) },
    scale: { value: new Vector23() },
    imageBounds: { value: new Vector23(1, 1) },
    resolution: { value: 1024 },
    map: { value: null },
    zoom: { value: zoom() },
    radius: { value: radius() },
    alphaThreshold: { value: alphaThreshold() },
    alphaSmoothing: { value: alphaSmoothing() },
    brightness: { value: brightness() },
    contrast: { value: contrast() },
    monochromeColor: { value: new Color2($$props.monochromeColor) },
    monochromeStrength: { value: $$props.monochromeStrength ?? 0 },
    negative: { value: negative() ? 1 : 0 },
    opacity: { value: opacity() },
    hsl: { value: new Vector37(0, 0, 0) },
    colorProccessingTexture: { value: null },
    colorProcessingTextureOverride: { value: 0 },
    colorProcessingEnabled: { value: 1 }
  };
  user_pre_effect(() => {
    uniforms.color.value.set(color());
  });
  user_pre_effect(() => {
    uniforms.imageBounds.value.set($textureStore()?.image.width ?? 0, $textureStore()?.image.height ?? 0);
  });
  user_pre_effect(() => {
    uniforms.resolution.value = Math.max($size().width, $size().height);
  });
  user_pre_effect(() => {
    uniforms.zoom.value = zoom();
  });
  user_pre_effect(() => {
    uniforms.radius.value = radius();
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
  });
  user_pre_effect(() => {
    uniforms.alphaThreshold.value = alphaThreshold();
  });
  user_pre_effect(() => {
    uniforms.alphaSmoothing.value = alphaSmoothing();
  });
  user_pre_effect(() => {
    uniforms.brightness.value = brightness();
  });
  user_pre_effect(() => {
    uniforms.contrast.value = contrast();
  });
  user_pre_effect(() => {
    uniforms.hsl.value.x = hue();
  });
  user_pre_effect(() => {
    uniforms.hsl.value.z = lightness();
  });
  user_pre_effect(() => {
    uniforms.negative.value = negative() ? 1 : 0;
  });
  user_pre_effect(() => {
    uniforms.map.value = $textureStore() ?? null;
  });
  user_pre_effect(() => {
    uniforms.colorProccessingTexture.value = $$props.colorProcessingTexture ?? null;
  });
  user_pre_effect(() => {
    uniforms.colorProcessingTextureOverride.value = $$props.colorProcessingTexture ? 1 : 0;
  });
  user_pre_effect(() => {
    if (strict_equals($$props.monochromeColor, void 0, false)) {
      uniforms.monochromeColor.value.set($$props.monochromeColor);
      uniforms.monochromeStrength.value = $$props.monochromeStrength ?? 1;
    } else {
      uniforms.monochromeStrength.value = 0;
    }
  });
  user_pre_effect(() => {
    let colorProcessingEnabled = 0;
    const monochromeCheck = ($$props.monochromeColor ? 1 : 0) * (strict_equals($$props.monochromeStrength, void 0) ? 1 : $$props.monochromeStrength);
    for (const value of [
      brightness(),
      contrast(),
      hue(),
      saturation(),
      lightness(),
      monochromeCheck,
      $$props.colorProcessingTexture ? 1 : 0
    ]) {
      if (strict_equals(value, 0, false)) {
        colorProcessingEnabled = 1;
        break;
      }
    }
    uniforms.colorProcessingEnabled.value = colorProcessingEnabled;
  });
  useTask(() => {
    const mesh = parent.current;
    if (!isInstanceOf(mesh, "Mesh")) return;
    uniforms.scale.value.set(mesh.scale.x, mesh.scale.y);
    const geometry = mesh.geometry;
    if (strict_equals(geometry, void 0, false) && "parameters" in geometry) {
      const { width: width2, height: height2 } = geometry.parameters;
      uniforms.scale.value.set(uniforms.scale.value.x * width2, uniforms.scale.value.y * height2);
    }
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return material2;
          },
          get uniforms() {
            return uniforms;
          },
          get toneMapped() {
            return toneMapped();
          },
          get transparent() {
            return transparent();
          },
          get vertexShader() {
            return vertexShader;
          },
          get fragmentShader() {
            return fragmentShader;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(ImageMaterial, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material2 })), "render", ImageMaterial, 182, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      ImageMaterial,
      172,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ImageMaterial = hmr(ImageMaterial);
  import.meta.hot.accept((module) => {
    ImageMaterial[HMR].update(module.default);
  });
}
var ImageMaterial_default = ImageMaterial;

// node_modules/@threlte/extras/dist/components/Grid/Grid.svelte
import { Color as Color3, DoubleSide as DoubleSide3, Plane, Vector3 as Vector38, Mesh as Mesh4 } from "three";

// node_modules/@threlte/extras/dist/components/Grid/gridShaders.js
var vertexShader2 = (
  /*glsl*/
  `
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`
);
var fragmentShader2 = (
  /*glsl*/
  `
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform vec3 fadeOrigin;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(fadeOrigin, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <colorspace_fragment>
	}
`
);

// node_modules/@threlte/extras/dist/components/Grid/Grid.svelte
Grid[FILENAME] = "node_modules/@threlte/extras/dist/components/Grid/Grid.svelte";
var root_14 = add_locations(from_html(`<!> <!>`, 1), Grid[FILENAME], []);
function Grid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Grid);
  var $$ownership_validator = create_ownership_validator($$props);
  let cellColor = prop($$props, "cellColor", 3, "#000000"), sectionColor = prop($$props, "sectionColor", 3, "#0000ee"), cellSize = prop($$props, "cellSize", 3, 1), backgroundColor = prop($$props, "backgroundColor", 3, "#dadada"), backgroundOpacity = prop($$props, "backgroundOpacity", 3, 0), sectionSize = prop($$props, "sectionSize", 3, 10), plane = prop($$props, "plane", 3, "xz"), gridSize = prop($$props, "gridSize", 19, () => [20, 20]), followCamera = prop($$props, "followCamera", 3, false), infiniteGrid = prop($$props, "infiniteGrid", 3, false), fadeDistance = prop($$props, "fadeDistance", 3, 100), fadeStrength = prop($$props, "fadeStrength", 3, 1), fadeOrigin = prop($$props, "fadeOrigin", 3, void 0), cellThickness = prop($$props, "cellThickness", 3, 1), sectionThickness = prop($$props, "sectionThickness", 3, 2), side = prop($$props, "side", 3, DoubleSide3), type = prop($$props, "type", 3, "grid"), axis = prop($$props, "axis", 3, "x"), maxRadius = prop($$props, "maxRadius", 3, 0), cellDividers = prop($$props, "cellDividers", 3, 6), sectionDividers = prop($$props, "sectionDividers", 3, 2), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "cellColor",
      "sectionColor",
      "cellSize",
      "backgroundColor",
      "backgroundOpacity",
      "sectionSize",
      "plane",
      "gridSize",
      "followCamera",
      "infiniteGrid",
      "fadeDistance",
      "fadeStrength",
      "fadeOrigin",
      "cellThickness",
      "sectionThickness",
      "side",
      "type",
      "axis",
      "maxRadius",
      "cellDividers",
      "sectionDividers",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new Mesh4();
  const { invalidate, camera } = useThrelte();
  const gridPlane = new Plane();
  const upVector = new Vector38(0, 1, 0);
  const zeroVector = new Vector38(0, 0, 0);
  const axisToInt = { x: 0, y: 1, z: 2 };
  const planeToAxes = { xz: "xzy", xy: "xyz", zy: "zyx" };
  const gridType = { grid: 0, lines: 1, circular: 2, polar: 3 };
  const uniforms = {
    cellSize: { value: cellSize() },
    sectionSize: { value: sectionSize() },
    cellColor: { value: new Color3(cellColor()) },
    sectionColor: { value: new Color3(sectionColor()) },
    backgroundColor: { value: new Color3(backgroundColor()) },
    backgroundOpacity: { value: backgroundOpacity() },
    fadeDistance: { value: fadeDistance() },
    fadeStrength: { value: fadeStrength() },
    fadeOrigin: { value: new Vector38() },
    cellThickness: { value: cellThickness() },
    sectionThickness: { value: sectionThickness() },
    infiniteGrid: { value: infiniteGrid() },
    followCamera: { value: followCamera() },
    coord0: { value: 0 },
    coord1: { value: 2 },
    coord2: { value: 1 },
    gridType: { value: gridType.grid },
    lineGridCoord: { value: axisToInt[axis()] },
    circleGridMaxRadius: { value: maxRadius() },
    polarCellDividers: { value: cellDividers() },
    polarSectionDividers: { value: sectionDividers() },
    worldCamProjPosition: { value: new Vector38() },
    worldPlanePosition: { value: new Vector38() }
  };
  user_pre_effect(() => {
    const axes = planeToAxes[plane()];
    const c0 = axes.charAt(0);
    const c1 = axes.charAt(1);
    const c2 = axes.charAt(2);
    uniforms.coord0.value = axisToInt[c0];
    uniforms.coord1.value = axisToInt[c1];
    uniforms.coord2.value = axisToInt[c2];
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellSize.value = cellSize();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionSize.value = sectionSize();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellColor.value.set(cellColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionColor.value.set(sectionColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.backgroundColor.value.set(backgroundColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.backgroundOpacity.value = backgroundOpacity();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.fadeDistance.value = fadeDistance();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.fadeStrength.value = fadeStrength();
    invalidate();
  });
  user_pre_effect(() => {
    if (fadeOrigin()) {
      uniforms.fadeOrigin.value = fadeOrigin();
      invalidate();
    }
  });
  user_pre_effect(() => {
    uniforms.cellThickness.value = cellThickness();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionThickness.value = sectionThickness();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.followCamera.value = followCamera();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.infiniteGrid.value = infiniteGrid();
    invalidate();
  });
  user_pre_effect(() => {
    switch (type()) {
      case "grid": {
        uniforms.gridType.value = gridType.grid;
        break;
      }
      case "lines": {
        uniforms.gridType.value = gridType.lines;
        uniforms.lineGridCoord.value = axisToInt[axis()];
        break;
      }
      case "circular": {
        uniforms.gridType.value = gridType.circular;
        uniforms.circleGridMaxRadius.value = maxRadius();
        break;
      }
      case "polar": {
        uniforms.gridType.value = gridType.polar;
        uniforms.circleGridMaxRadius.value = maxRadius();
        uniforms.polarCellDividers.value = cellDividers();
        uniforms.polarSectionDividers.value = sectionDividers();
        break;
      }
    }
    invalidate();
  });
  useTask(
    () => {
      gridPlane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(mesh.matrixWorld);
      const material2 = mesh.material;
      const worldCamProjPosition = material2.uniforms.worldCamProjPosition;
      const worldPlanePosition = material2.uniforms.worldPlanePosition;
      const uFadeOrigin = material2.uniforms.fadeOrigin;
      const projectedPoint = gridPlane.projectPoint(camera.current.position, worldCamProjPosition.value);
      if (!fadeOrigin()) {
        uFadeOrigin.value = projectedPoint;
      }
      worldPlanePosition.value.set(0, 0, 0).applyMatrix4(mesh.matrixWorld);
    },
    { autoInvalidate: false }
  );
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return mesh;
          },
          frustumCulled: false
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Grid, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_14();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => component(node_1, () => T.ShaderMaterial, ($$anchor3, T_ShaderMaterial) => {
                T_ShaderMaterial($$anchor3, {
                  get fragmentShader() {
                    return fragmentShader2;
                  },
                  get vertexShader() {
                    return vertexShader2;
                  },
                  get uniforms() {
                    return uniforms;
                  },
                  transparent: true,
                  get side() {
                    return side();
                  }
                });
              }),
              "component",
              Grid,
              256,
              2,
              { componentTag: "T.ShaderMaterial" }
            );
            var node_2 = sibling(node_1, 2);
            {
              var consequent = ($$anchor3) => {
                var fragment_2 = comment();
                var node_3 = first_child(fragment_2);
                add_svelte_meta(() => snippet(node_3, () => $$props.children, () => ({ ref: mesh })), "render", Grid, 264, 4);
                append($$anchor3, fragment_2);
              };
              var alternate = ($$anchor3) => {
                var fragment_3 = comment();
                var node_4 = first_child(fragment_3);
                {
                  let $0 = user_derived(() => equals(typeof gridSize(), "number") ? [gridSize(), gridSize()] : gridSize());
                  add_svelte_meta(
                    () => component(node_4, () => T.PlaneGeometry, ($$anchor4, T_PlaneGeometry) => {
                      T_PlaneGeometry($$anchor4, {
                        get args() {
                          return get($0);
                        }
                      });
                    }),
                    "component",
                    Grid,
                    266,
                    4,
                    { componentTag: "T.PlaneGeometry" }
                  );
                }
                append($$anchor3, fragment_3);
              };
              add_svelte_meta(
                () => if_block(node_2, ($$render) => {
                  if ($$props.children) $$render(consequent);
                  else $$render(alternate, false);
                }),
                "if",
                Grid,
                263,
                2
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Grid,
      250,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Grid = hmr(Grid);
  import.meta.hot.accept((module) => {
    Grid[HMR].update(module.default);
  });
}
var Grid_default = Grid;

// node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte
import { ExtrudeGeometry, Shape } from "three";
import { toCreasedNormals } from "three/examples/jsm/utils/BufferGeometryUtils.js";
RoundedBoxGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte";
function RoundedBoxGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RoundedBoxGeometry);
  var $$ownership_validator = create_ownership_validator($$props);
  let args = prop($$props, "args", 19, () => []), radius = prop($$props, "radius", 3, 0.05), smoothness = prop($$props, "smoothness", 3, 4), creaseAngle = prop($$props, "creaseAngle", 3, 0.4), steps = prop($$props, "steps", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "args",
      "radius",
      "smoothness",
      "creaseAngle",
      "steps",
      "ref",
      "children"
    ],
    "props"
  );
  const eps = 1e-5;
  const createShape = (width3, height3, radius0) => {
    const shape2 = new Shape();
    const radius2 = radius0 - eps;
    shape2.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
    shape2.absarc(eps, height3 - radius2 * 2, eps, Math.PI, Math.PI / 2, true);
    shape2.absarc(width3 - radius2 * 2, height3 - radius2 * 2, eps, Math.PI / 2, 0, true);
    shape2.absarc(width3 - radius2 * 2, eps, eps, 0, -Math.PI / 2, true);
    return shape2;
  };
  let width2 = tag(user_derived(() => args()[0] ?? 1), "width");
  let height2 = tag(user_derived(() => args()[1] ?? 1), "height");
  let depth = tag(user_derived(() => args()[2] ?? 1), "depth");
  let shape = tag(user_derived(() => createShape(get(width2), get(height2), radius())), "shape");
  let params = tag(
    user_derived(() => ({
      depth: get(depth) - radius() * 2,
      bevelEnabled: true,
      bevelSegments: smoothness() * 2,
      steps: steps(),
      bevelSize: radius() - eps,
      bevelThickness: radius(),
      curveSegments: smoothness()
    })),
    "params"
  );
  let geometry = tag(user_derived(() => new ExtrudeGeometry(get(shape), get(params))), "geometry");
  user_pre_effect(() => {
    get(geometry).center();
    toCreasedNormals(get(geometry), creaseAngle());
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return get(geometry);
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(RoundedBoxGeometry, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: get(geometry) })), "render", RoundedBoxGeometry, 56, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      RoundedBoxGeometry,
      51,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  RoundedBoxGeometry = hmr(RoundedBoxGeometry);
  import.meta.hot.accept((module) => {
    RoundedBoxGeometry[HMR].update(module.default);
  });
}
var RoundedBoxGeometry_default = RoundedBoxGeometry;

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
import { Group as Group4 } from "three";
import { TransformControls } from "three/examples/jsm/controls/TransformControls.js";

// node_modules/@threlte/extras/dist/components/controls/useControlsContext.js
var useControlsContext = () => {
  return useThrelteUserContext("threlte-controls", {
    orbitControls: writable(void 0),
    trackballControls: writable(void 0)
  });
};

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
TransformControls_1[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte";
var root2 = add_locations(from_html(`<!> <!>`, 1), TransformControls_1[FILENAME], []);
function TransformControls_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TransformControls_1);
  var $$ownership_validator = create_ownership_validator($$props);
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let autoPauseOrbitControls = prop($$props, "autoPauseOrbitControls", 3, true), autoPauseTrackballControls = prop($$props, "autoPauseTrackballControls", 3, true), controls = prop($$props, "controls", 15), group = prop($$props, "group", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoPauseOrbitControls",
      "autoPauseTrackballControls",
      "object",
      "controls",
      "group",
      "children"
    ],
    "props"
  );
  const { camera, dom, invalidate, scene } = useThrelte();
  const { orbitControls, trackballControls } = useControlsContext();
  let isDragging = tag(state(false), "isDragging");
  observe(() => [orbitControls, get(isDragging), autoPauseOrbitControls()], ([orbitControls2, isDragging2, useAutoPauseOrbitControls]) => {
    if (!orbitControls2 || !orbitControls2.enabled && isDragging2) return;
    orbitControls2.enabled = !(isDragging2 && useAutoPauseOrbitControls);
    return () => {
      orbitControls2.enabled = true;
    };
  });
  observe(
    () => [
      trackballControls,
      get(isDragging),
      autoPauseTrackballControls()
    ],
    ([trackballControls2, isDragging2, useAutoPausetrackballControls]) => {
      if (!trackballControls2 || !trackballControls2.enabled && isDragging2) return;
      trackballControls2.enabled = !(isDragging2 && useAutoPausetrackballControls);
      return () => {
        trackballControls2.enabled = true;
      };
    }
  );
  const transformControls = new TransformControls(camera.current, dom);
  const attachGroup = new Group4();
  user_pre_effect(() => {
    transformControls.camera = $camera();
  });
  user_pre_effect(() => {
    transformControls?.attach($$props.object ?? attachGroup);
    return () => transformControls?.detach();
  });
  const transformOnlyPropNames = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible",
    "onmouseDown",
    "onmouseUp",
    "onobjectChange"
  ];
  let transformProps = tag(state(proxy({})), "transformProps");
  let objectProps = tag(state(proxy({})), "objectProps");
  user_pre_effect(() => {
    set(transformProps, {}, true);
    set(objectProps, {}, true);
    Object.keys(props).forEach((key2) => {
      user_pre_effect(() => {
        if (transformOnlyPropNames.includes(key2)) {
          get(transformProps)[key2] = props[key2];
        } else {
          get(objectProps)[key2] = props[key2];
        }
      });
    });
  });
  const onchange = (event) => {
    invalidate();
    if (transformControls.dragging && !get(isDragging)) {
      set(isDragging, true);
    } else if (!transformControls.dragging && get(isDragging)) {
      set(isDragging, false);
    }
    $$props.onchange?.(event);
  };
  var $$exports = { ...legacy_api() };
  var fragment2 = root2();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("controls", T, controls);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return transformControls;
          },
          onchange
        },
        () => get(transformProps),
        {
          attach: ({ ref }) => {
            const helper = ref.getHelper();
            scene.add(helper);
            return () => {
              scene.remove(helper);
            };
          },
          dispose: false,
          oncreate: (ref) => {
            return () => ref.dispose();
          },
          get ref() {
            return controls();
          },
          set ref($$value) {
            controls($$value);
          }
        }
      )),
      "component",
      TransformControls_1,
      121,
      0,
      { componentTag: "T" }
    );
  }
  var node_1 = sibling(node, 2);
  {
    $$ownership_validator.binding("group", T, group);
    add_svelte_meta(
      () => T(node_1, spread_props(
        {
          get is() {
            return attachGroup;
          }
        },
        () => get(objectProps),
        {
          get ref() {
            return group();
          },
          set ref($$value) {
            group($$value);
          },
          children: wrap_snippet(TransformControls_1, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_2 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: attachGroup })), "render", TransformControls_1, 144, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      TransformControls_1,
      139,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TransformControls_1 = hmr(TransformControls_1);
  import.meta.hot.accept((module) => {
    TransformControls_1[HMR].update(module.default);
  });
}
var TransformControls_default = TransformControls_1;

// node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte
import { OrbitControls as ThreeOrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
OrbitControls2[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte";
function OrbitControls2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, OrbitControls2);
  var $$ownership_validator = create_ownership_validator($$props);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let ref = prop($$props, "ref", 15), props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "children"], "props");
  const parent = useParent();
  const { dom, invalidate } = useThrelte();
  if (!isInstanceOf($parent(), "Camera")) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const controls = new ThreeOrbitControls($parent(), dom);
  const { orbitControls } = useControlsContext();
  const { start, stop } = useTask(
    () => {
      controls.update();
    },
    { autoStart: false, autoInvalidate: false }
  );
  user_pre_effect(() => {
    if ($$props.autoRotate || $$props.enableDamping) {
      start();
    } else {
      stop();
    }
  });
  user_pre_effect(() => {
    const handleChange = (event) => {
      invalidate();
      $$props.onchange?.(event);
    };
    orbitControls.set(controls);
    controls.addEventListener("change", handleChange);
    return () => {
      orbitControls.set(void 0);
      controls.removeEventListener("change", handleChange);
    };
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return controls;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(OrbitControls2, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: controls })), "render", OrbitControls2, 60, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      OrbitControls2,
      55,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  OrbitControls2 = hmr(OrbitControls2);
  import.meta.hot.accept((module) => {
    OrbitControls2[HMR].update(module.default);
  });
}
var OrbitControls_default = OrbitControls2;

// node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte
import { TrackballControls as ThreeTrackballControls } from "three/examples/jsm/controls/TrackballControls.js";
TrackballControls2[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte";
function TrackballControls2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TrackballControls2);
  var $$ownership_validator = create_ownership_validator($$props);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "onchange",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = useParent();
  const { dom, invalidate, size } = useThrelte();
  if (!isInstanceOf($parent(), "Camera")) {
    throw new Error("Parent missing: <TrackballControls> need to be a child of a <Camera>");
  }
  const controls = tag(user_derived(() => new ThreeTrackballControls($parent())), "controls");
  useTask(
    () => {
      get(controls).update();
    },
    { autoInvalidate: false }
  );
  user_effect(() => {
    get(controls).connect(dom);
    return () => get(controls).disconnect();
  });
  user_effect(() => {
    $size();
    get(controls).handleResize();
  });
  const { trackballControls } = useControlsContext();
  user_pre_effect(() => {
    const handleChange = (event) => {
      invalidate();
      $$props.onchange?.(event);
    };
    const currentControls = get(controls);
    trackballControls.set(get(controls));
    currentControls.addEventListener("change", handleChange);
    return () => {
      trackballControls.set(void 0);
      currentControls.removeEventListener("change", handleChange);
    };
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return get(controls);
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(TrackballControls2, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: get(controls) })), "render", TrackballControls2, 98, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      TrackballControls2,
      93,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  TrackballControls2 = hmr(TrackballControls2);
  import.meta.hot.accept((module) => {
    TrackballControls2[HMR].update(module.default);
  });
}
var TrackballControls_default = TrackballControls2;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte
import { InstancedMesh } from "three";

// node_modules/@threlte/extras/dist/components/Instancing/Api.svelte
import { DynamicDrawUsage, Matrix4 as Matrix46, Quaternion as Quaternion2, Vector3 as Vector39 } from "three";

// node_modules/@threlte/extras/dist/components/Instancing/api.js
var getContextId = (instancedMeshId) => `threlte-instanced-mesh-${instancedMeshId}`;
var createApi = (instancedMesh, instancedMeshId) => {
  const api = {
    instancedMesh: currentWritable(instancedMesh),
    addInstance(instance) {
      api.instances.update((arr) => {
        arr.push(instance);
        return arr;
      });
    },
    removeInstance(instance) {
      api.instances.update((arr) => {
        const index = arr.indexOf(instance);
        if (index > -1)
          arr.splice(index, 1);
        return arr;
      });
    },
    instances: currentWritable([])
  };
  setContext(getContextId(instancedMeshId), api);
  return api;
};
var useApi = (instancedMeshId) => {
  const context = getContext(getContextId(instancedMeshId));
  if (!context)
    throw new Error(`No <InstancedMesh> component found for id ${instancedMeshId}`);
  return context;
};

// node_modules/@threlte/extras/dist/components/Instancing/Api.svelte
Api[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/Api.svelte";
var root3 = add_locations(from_html(`<!> <!> <!>`, 1), Api[FILENAME], []);
function Api($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Api);
  var $$ownership_validator = create_ownership_validator($$props);
  const $instances = () => (validate_store(instances, "instances"), store_get(instances, "$instances", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let instancedMesh = prop($$props, "instancedMesh", 7);
  const { instances } = createApi(instancedMesh(), $$props.id);
  const tempMatrix3 = new Matrix46();
  const matrices = new Float32Array($$props.limit * 16);
  for (let i = 0; i < $$props.limit; i++) tempMatrix3.identity().toArray(matrices, i * 16);
  const colors = new Float32Array($$props.limit * 3).fill(1);
  const parentMatrix = new Matrix46();
  const instanceMatrix = new Matrix46();
  const translation = new Vector39();
  const rotation = new Quaternion2();
  const scale = new Vector39();
  let initialUpdateDone = false;
  useTask(() => {
    instancedMesh().updateMatrix();
    if ($$props.update || !initialUpdateDone) {
      instancedMesh().updateMatrixWorld();
      parentMatrix.copy(instancedMesh().matrixWorld).invert();
      if (instancedMesh().instanceColor) {
        $$ownership_validator.mutation("instancedMesh", ["instancedMesh", "instanceColor", "needsUpdate"], instancedMesh().instanceColor.needsUpdate = true, 45, 8);
      }
      $$ownership_validator.mutation("instancedMesh", ["instancedMesh", "instanceMatrix", "needsUpdate"], instancedMesh().instanceMatrix.needsUpdate = true, 47, 6);
      for (let i = 0, l = instances.current.length; i < l; i++) {
        const instance = instances.current[i];
        instance.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);
        instanceMatrix.toArray(matrices, i * 16);
        instance.color.toArray(colors, i * 3);
      }
      initialUpdateDone = true;
    }
  });
  user_pre_effect(() => {
    const updateRange = Math.min($$props.limit, strict_equals($$props.range, void 0, false) ? $$props.range : $$props.limit, $instances().length);
    $$ownership_validator.mutation("instancedMesh", ["instancedMesh", "count"], instancedMesh().count = updateRange, 65, 4);
    instancedMesh().instanceMatrix.clearUpdateRanges();
    instancedMesh().instanceMatrix.addUpdateRange(0, updateRange * 16);
    if (instancedMesh().instanceColor) {
      instancedMesh().instanceColor.clearUpdateRanges();
      instancedMesh().instanceColor.addUpdateRange(0, updateRange * 3);
    }
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = root3();
  var node = first_child(fragment2);
  {
    let $0 = user_derived(() => matrices.length / 16);
    add_svelte_meta(
      () => component(node, () => T.InstancedBufferAttribute, ($$anchor2, T_InstancedBufferAttribute) => {
        T_InstancedBufferAttribute($$anchor2, {
          attach: "instanceMatrix",
          get count() {
            return get($0);
          },
          get array() {
            return matrices;
          },
          itemSize: 16,
          get usage() {
            return DynamicDrawUsage;
          }
        });
      }),
      "component",
      Api,
      77,
      0,
      { componentTag: "T.InstancedBufferAttribute" }
    );
  }
  var node_1 = sibling(node, 2);
  {
    let $0 = user_derived(() => colors.length / 3);
    add_svelte_meta(
      () => component(node_1, () => T.InstancedBufferAttribute, ($$anchor2, T_InstancedBufferAttribute_1) => {
        T_InstancedBufferAttribute_1($$anchor2, {
          attach: "instanceColor",
          get count() {
            return get($0);
          },
          get array() {
            return colors;
          },
          itemSize: 3,
          get usage() {
            return DynamicDrawUsage;
          }
        });
      }),
      "component",
      Api,
      85,
      0,
      { componentTag: "T.InstancedBufferAttribute" }
    );
  }
  var node_2 = sibling(node_1, 2);
  add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Api, 93, 0);
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Api = hmr(Api);
  import.meta.hot.accept((module) => {
    Api[HMR].update(module.default);
  });
}
var Api_default = Api;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte
InstancedMesh_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte";
function InstancedMesh_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedMesh_1);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 3, "default"), limit = prop($$props, "limit", 3, 1e3), range = prop($$props, "range", 3, 1e3), update = prop($$props, "update", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "limit",
      "range",
      "update",
      "ref",
      "children"
    ],
    "props"
  );
  const instancedMesh = new InstancedMesh(void 0, void 0, 0);
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return instancedMesh;
          },
          raycast: () => null,
          matrixAutoUpdate: false
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(InstancedMesh_1, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => Api_default(node_1, {
                get instancedMesh() {
                  return instancedMesh;
                },
                get id() {
                  return id();
                },
                get limit() {
                  return limit();
                },
                get range() {
                  return range();
                },
                get update() {
                  return update();
                },
                children: wrap_snippet(InstancedMesh_1, ($$anchor3, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_2 = first_child(fragment_2);
                  add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: instancedMesh })), "render", InstancedMesh_1, 35, 4);
                  append($$anchor3, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              InstancedMesh_1,
              28,
              2,
              { componentTag: "Api" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      InstancedMesh_1,
      21,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  InstancedMesh_1 = hmr(InstancedMesh_1);
  import.meta.hot.accept((module) => {
    InstancedMesh_1[HMR].update(module.default);
  });
}
var InstancedMesh_default = InstancedMesh_1;

// node_modules/@threlte/extras/dist/components/Instancing/PositionMesh.js
import { BufferGeometry, Color as Color4, FrontSide, Group as Group5, Matrix4 as Matrix47, Mesh as Mesh5, MeshBasicMaterial as MeshBasicMaterial3, Raycaster as Raycaster4 } from "three";
var _instanceLocalMatrix = new Matrix47();
var _instanceWorldMatrix = new Matrix47();
var _instanceIntersects = [];
var _mesh = new Mesh5();
var PositionMesh = class extends Group5 {
  color;
  instancedMesh;
  instances;
  constructor(instancedMesh, instances) {
    super();
    this.color = new Color4("white");
    this.instancedMesh = instancedMesh;
    this.instances = instances;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    return this.instancedMesh.current?.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(raycaster, intersects) {
    const parent = this.instancedMesh.current;
    if (parent === void 0)
      return;
    if (parent.geometry === void 0 || parent.material === void 0)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld2 = parent.matrixWorld;
    const instanceId = this.instances.current.indexOf(this);
    if (instanceId === -1 || instanceId > parent.count)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld2, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    if (isInstanceOf(parent.material, "Material")) {
      _mesh.material.side = parent.material.side;
    } else {
      _mesh.material.side = parent.material[0]?.side ?? FrontSide;
    }
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
      const intersect = _instanceIntersects[i];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};

// node_modules/@threlte/extras/dist/components/Instancing/useInstanceId.js
var key = /* @__PURE__ */ Symbol("threlte-instance-id");
var createInstanceIdContext = (uuid) => {
  setContext(key, uuid);
};
var useInstanceId = () => {
  return getContext(key) ?? "default";
};

// node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte
Instance[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte";
function Instance($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Instance);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 19, useInstanceId), ref = prop($$props, "ref", 15), props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"], "props");
  const { addInstance, removeInstance, instancedMesh, instances } = useApi(id());
  const mesh = new PositionMesh(instancedMesh, instances);
  addInstance(mesh);
  onDestroy(() => {
    removeInstance(mesh);
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return mesh;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Instance, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: mesh })), "render", Instance, 27, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Instance,
      22,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Instance = hmr(Instance);
  import.meta.hot.accept((module) => {
    Instance[HMR].update(module.default);
  });
}
var Instance_default = Instance;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte
InnerInstancedMeshes[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte";
function InnerInstancedMeshes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InnerInstancedMeshes);
  let index = prop($$props, "index", 19, () => $$props.meshes.length - 1), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "meshes",
      "index",
      "children"
    ],
    "props"
  );
  const mesh = $$props.meshes[index()];
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => InstancedMesh_default(node_1, spread_props(
          {
            get geometry() {
              return mesh.geometry;
            },
            get material() {
              return mesh.material;
            },
            get id() {
              return mesh.uuid;
            }
          },
          () => props,
          {
            children: wrap_snippet(InnerInstancedMeshes, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              {
                let $0 = user_derived(() => index() - 1);
                add_svelte_meta(
                  () => InnerInstancedMeshes_default(node_2, spread_props(
                    {
                      get meshes() {
                        return $$props.meshes;
                      },
                      get index() {
                        return get($0);
                      }
                    },
                    () => props,
                    {
                      children: wrap_snippet(InnerInstancedMeshes, ($$anchor4, $$slotProps2) => {
                        var fragment_3 = comment();
                        var node_3 = first_child(fragment_3);
                        add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", InnerInstancedMeshes, 29, 6);
                        append($$anchor4, fragment_3);
                      }),
                      $$slots: { default: true }
                    }
                  )),
                  "component",
                  InnerInstancedMeshes,
                  24,
                  4,
                  { componentTag: "Self" }
                );
              }
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }
        )),
        "component",
        InnerInstancedMeshes,
        18,
        2,
        { componentTag: "InstancedMesh" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_4 = comment();
      var node_4 = first_child(fragment_4);
      add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", InnerInstancedMeshes, 33, 2);
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (index() > -1) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      InnerInstancedMeshes,
      17,
      0
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  InnerInstancedMeshes = hmr(InnerInstancedMeshes);
  import.meta.hot.accept((module) => {
    InnerInstancedMeshes[HMR].update(module.default);
  });
}
var InnerInstancedMeshes_default = InnerInstancedMeshes;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte
InstancedMeshes[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte";
function InstancedMeshes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedMeshes);
  let props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "meshes", "children"], "props");
  const getInstance = (id) => {
    return (...args) => {
      createInstanceIdContext(id);
      return Instance_default(...args);
    };
  };
  const getInstanceComponentsArray = (meshes) => {
    return meshes.filter((mesh) => mesh.isMesh).map((mesh) => getInstance(mesh.uuid));
  };
  const getInstanceComponentsObject = (meshes) => {
    return Object.entries(meshes).reduce(
      (acc, [id, mesh]) => {
        if (!mesh.isMesh) return acc;
        acc[id] = getInstance(mesh.uuid);
        return acc;
      },
      {}
    );
  };
  let components = tag(
    user_derived(() => Array.isArray($$props.meshes) ? getInstanceComponentsArray($$props.meshes) : getInstanceComponentsObject($$props.meshes)),
    "components"
  );
  let meshesArray = tag(user_derived(() => Array.isArray($$props.meshes) ? $$props.meshes : Object.values($$props.meshes)), "meshesArray");
  let filteredMeshesArray = tag(user_derived(() => get(meshesArray).filter((mesh) => mesh.isMesh)), "filteredMeshesArray");
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(
    () => InnerInstancedMeshes_default(node, spread_props(
      {
        get meshes() {
          return get(filteredMeshesArray);
        }
      },
      () => props,
      {
        children: wrap_snippet(InstancedMeshes, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ components: get(components) })), "render", InstancedMeshes, 52, 2);
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    )),
    "component",
    InstancedMeshes,
    48,
    0,
    { componentTag: "InnerInstancedMeshes" }
  );
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  InstancedMeshes = hmr(InstancedMeshes);
  import.meta.hot.accept((module) => {
    InstancedMeshes[HMR].update(module.default);
  });
}
var InstancedMeshes_default = InstancedMeshes;

// node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte
import { ShaderChunk } from "three";
SoftShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte";
function SoftShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SoftShadows);
  const { renderer, camera, scene } = useThrelte();
  let size = prop($$props, "size", 3, 25), focus = prop($$props, "focus", 3, 0), samples = prop($$props, "samples", 3, 10);
  const original = ShaderChunk.shadowmap_pars_fragment;
  let pcss = tag(
    user_derived(() => `
		#define PENUMBRA_FILTER_SIZE float(${size()})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${focus()});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${samples()}; i ++) {
				offset = (vogelDiskSample(j, ${samples()}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${samples()}; i++) {
				vogelSample = vogelDiskSample(j, ${samples()}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${size()}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${samples()}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`),
    "pcss"
  );
  const recompile = () => {
    scene.traverse((o) => {
      const object = o;
      if (object.material) {
        renderer?.properties.remove(object.material);
        object.material.dispose?.();
      }
    });
    if (renderer?.info.programs) renderer.info.programs.length = 0;
    renderer?.compile(scene, camera.current);
  };
  user_pre_effect(() => {
    ShaderChunk.shadowmap_pars_fragment = original.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
${get(pcss)}`).replace("#if defined( SHADOWMAP_TYPE_PCF )", "\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )");
    recompile();
  });
  onDestroy(() => {
    ShaderChunk.shadowmap_pars_fragment = original;
    recompile();
  });
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  SoftShadows = hmr(SoftShadows);
  import.meta.hot.accept((module) => {
    SoftShadows[HMR].update(module.default);
  });
}
var SoftShadows_default = SoftShadows;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte
import { BufferGeometry as BufferGeometry2, BufferAttribute } from "three";
MeshLineGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte";
function MeshLineGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshLineGeometry);
  var $$ownership_validator = create_ownership_validator($$props);
  let points = prop($$props, "points", 19, () => []), shape = prop($$props, "shape", 3, "none"), shapeFn = prop($$props, "shapeFunction", 3, () => 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "points",
      "shape",
      "shapeFunction",
      "ref",
      "children"
    ],
    "props"
  );
  const pointCount = tag(user_derived(() => points().length), "pointCount");
  const { invalidate } = useThrelte();
  const positions = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 6), 3)), "positions");
  const previous = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 6), 3)), "previous");
  const next = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 6), 3)), "next");
  const counters = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 2), 1)), "counters");
  const side = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 2), 1)), "side");
  const width2 = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 2), 1)), "width");
  const uv = tag(user_derived(() => new BufferAttribute(new Float32Array(get(pointCount) * 4), 2)), "uv");
  const indices = tag(user_derived(() => new BufferAttribute(new Uint16Array(get(pointCount) * 6), 1)), "indices");
  const shapeFunction = tag(user_derived(() => strict_equals(shape(), "taper") ? (p) => 1 * Math.pow(4 * p * (1 - p), 1) : shapeFn()), "shapeFunction");
  const geometry = new BufferGeometry2();
  user_pre_effect(() => {
    for (let i = 0, i2 = 0, i3 = 0; i < get(pointCount); i += 1, i2 += 2, i3 += 6) {
      get(counters).setX(i2, i / points().length);
      get(counters).setX(i2 + 1, i / points().length);
      get(side).setX(i2, 1);
      get(side).setX(i2 + 1, -1);
      const w = strict_equals(shape(), "none") ? 1 : get(shapeFunction)(i / (get(pointCount) - 1));
      get(width2).setX(i2, w);
      get(width2).setX(i2 + 1, w);
      get(uv).setXYZW(i2, i / (get(pointCount) - 1), 0, i / (get(pointCount) - 1), 1);
      if (i < get(pointCount) - 1) {
        const n = i * 2;
        get(indices).setX(i3 + 0, n + 0);
        get(indices).setX(i3 + 1, n + 1);
        get(indices).setX(i3 + 2, n + 2);
        get(indices).setX(i3 + 3, n + 2);
        get(indices).setX(i3 + 4, n + 1);
        get(indices).setX(i3 + 5, n + 3);
      }
    }
    geometry.setAttribute("position", get(positions));
    geometry.setAttribute("previous", get(previous));
    geometry.setAttribute("next", get(next));
    geometry.setAttribute("counters", get(counters));
    geometry.setAttribute("side", get(side));
    geometry.setAttribute("width", get(width2));
    geometry.setAttribute("uv", get(uv));
    geometry.setIndex(get(indices));
  });
  user_pre_effect(() => {
    if (strict_equals(points().length, 0)) return;
    let positionIndex = 0;
    let previousIndex = 0;
    let nextIndex = 0;
    const p1 = points()[0];
    get(previous).setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    get(previous).setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    for (let i = 0; i < get(pointCount); i++) {
      const p = points()[i];
      get(positions).setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      get(positions).setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      if (i < get(pointCount) - 1) {
        get(previous).setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
        get(previous).setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
      }
      if (i > 0 && i + 1 <= get(pointCount)) {
        get(next).setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
        get(next).setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
      }
    }
    const p2 = points()[get(pointCount) - 1];
    get(next).setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    get(next).setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    get(positions).needsUpdate = true;
    get(previous).needsUpdate = true;
    get(next).needsUpdate = true;
    geometry.computeBoundingSphere();
    invalidate();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return geometry;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(MeshLineGeometry, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: geometry })), "render", MeshLineGeometry, 139, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      MeshLineGeometry,
      134,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  MeshLineGeometry = hmr(MeshLineGeometry);
  import.meta.hot.accept((module) => {
    MeshLineGeometry[HMR].update(module.default);
  });
}
var MeshLineGeometry_default = MeshLineGeometry;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte
import { ShaderMaterial as ShaderMaterial3, Color as Color5, Vector2 as Vector24 } from "three";

// node_modules/@threlte/extras/dist/components/MeshLine/fragment.js
var fragmentShader3 = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

vec4 CustomLinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

void main()	{
	#include <logdepthbuf_fragment>
	#include <colorspace_fragment>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = CustomLinearTosRGB(c);
}
`;

// node_modules/@threlte/extras/dist/components/MeshLine/vertex.js
import { ShaderChunk as ShaderChunk2 } from "three";
var vertexShader3 = `
    #include <common>
    ${ShaderChunk2.logdepthbuf_pars_vertex}
    ${ShaderChunk2.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${ShaderChunk2.logdepthbuf_vertex}
        ${ShaderChunk2.fog_vertex}
    }
`;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte
MeshLineMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte";
function MeshLineMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshLineMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let opacity = prop($$props, "opacity", 3, 1), color = prop($$props, "color", 3, "#ffffff"), dashOffset = prop($$props, "dashOffset", 3, 0), dashArray = prop($$props, "dashArray", 3, 0), dashRatio = prop($$props, "dashRatio", 3, 0), attenuate = prop($$props, "attenuate", 3, true), width2 = prop($$props, "width", 3, 1), scaleDown = prop($$props, "scaleDown", 3, 0), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "opacity",
      "color",
      "dashOffset",
      "dashArray",
      "dashRatio",
      "attenuate",
      "width",
      "scaleDown",
      "alphaMap",
      "ref",
      "children"
    ],
    "props"
  );
  let { invalidate, size } = useThrelte();
  const uniforms = {
    lineWidth: { value: width2() },
    color: { value: new Color5(color()) },
    opacity: { value: opacity() },
    resolution: { value: new Vector24(1, 1) },
    sizeAttenuation: { value: attenuate() ? 1 : 0 },
    dashArray: { value: dashArray() },
    useDash: { value: dashArray() > 0 ? 1 : 0 },
    dashOffset: { value: dashOffset() },
    dashRatio: { value: dashRatio() },
    scaleDown: { value: scaleDown() / 10 },
    alphaTest: { value: 0 },
    alphaMap: { value: $$props.alphaMap },
    useAlphaMap: { value: $$props.alphaMap ? 1 : 0 }
  };
  const material2 = new ShaderMaterial3({ uniforms });
  user_pre_effect(() => {
    uniforms.lineWidth.value = width2();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.resolution.value.set($size().width, $size().height);
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sizeAttenuation.value = attenuate() ? 1 : 0;
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.dashArray.value = dashArray();
    uniforms.useDash.value = dashArray() > 0 ? 1 : 0;
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.dashOffset.value = dashOffset();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.dashRatio.value = dashRatio();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.scaleDown.value = scaleDown() / 10;
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.alphaMap.value = $$props.alphaMap;
    uniforms.useAlphaMap.value = $$props.alphaMap ? 1 : 0;
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.color.value.set(color());
    invalidate();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return material2;
          },
          get fragmentShader() {
            return fragmentShader3;
          },
          get vertexShader() {
            return vertexShader3;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(MeshLineMaterial, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material2 })), "render", MeshLineMaterial, 103, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      MeshLineMaterial,
      96,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MeshLineMaterial = hmr(MeshLineMaterial);
  import.meta.hot.accept((module) => {
    MeshLineMaterial[HMR].update(module.default);
  });
}
var MeshLineMaterial_default = MeshLineMaterial;

// node_modules/@threlte/extras/dist/components/PointsMaterial/PointsMaterial.svelte
import { PointsMaterial as ThreePointsMaterial } from "three";
PointsMaterial_1[FILENAME] = "node_modules/@threlte/extras/dist/components/PointsMaterial/PointsMaterial.svelte";
var fragment = `
    #include <opaque_fragment>
    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
    float r = dot(cxy, cxy);
    if (r > 1.0) discard;
    float delta = fwidth(r);     
    float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
    gl_FragColor.a = mask * gl_FragColor.a;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
  `;
var PointsMaterial = class extends ThreePointsMaterial {
  alphaToCoverage = true;
  onBeforeCompile(parameters, _renderer) {
    parameters.fragmentShader = parameters.fragmentShader.replace(`#include <opaque_fragment>`, fragment);
  }
};
function PointsMaterial_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PointsMaterial_1);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), rest = rest_props($$props, ["$$slots", "$$events", "$$legacy", "children", "ref"], "rest");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node = first_child(fragment_1);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return PointsMaterial;
          }
        },
        () => rest,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(PointsMaterial_1, ($$anchor2, $$slotProps) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", PointsMaterial_1, 50, 2);
            append($$anchor2, fragment_2);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      PointsMaterial_1,
      45,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  PointsMaterial_1 = hmr(PointsMaterial_1);
  import.meta.hot.accept((module) => {
    PointsMaterial_1[HMR].update(module.default);
  });
}
var PointsMaterial_default = PointsMaterial_1;

// node_modules/@threlte/extras/dist/components/Sky/Sky.svelte
import {
  CubeCamera as CubeCamera2,
  HalfFloatType,
  LinearMipmapLinearFilter,
  MathUtils as MathUtils2,
  Vector3 as Vector310,
  WebGLCubeRenderTarget as WebGLCubeRenderTarget2
} from "three";
import { Sky } from "three/examples/jsm/objects/Sky.js";
Sky_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Sky/Sky.svelte";
function Sky_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Sky_1);
  var $$ownership_validator = create_ownership_validator($$props);
  let scale = prop($$props, "scale", 3, 1e3), turbidity = prop($$props, "turbidity", 3, 10), rayleigh = prop($$props, "rayleigh", 3, 3), mieCoefficient = prop($$props, "mieCoefficient", 3, 5e-3), mieDirectionalG = prop($$props, "mieDirectionalG", 3, 0.7), elevation = prop($$props, "elevation", 3, 2), azimuth = prop($$props, "azimuth", 3, 180), setEnvironment = prop($$props, "setEnvironment", 3, true), cubeMapSize = prop($$props, "cubeMapSize", 3, 128), webGLRenderTargetOptions = prop($$props, "webGLRenderTargetOptions", 19, () => ({})), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "scale",
      "turbidity",
      "rayleigh",
      "mieCoefficient",
      "mieDirectionalG",
      "elevation",
      "azimuth",
      "setEnvironment",
      "cubeMapSize",
      "webGLRenderTargetOptions",
      "ref",
      "children"
    ],
    "props"
  );
  const sky = new Sky();
  const sunPosition = new Vector310();
  const { uniforms } = sky.material;
  const { renderer, scene, invalidate } = useThrelte();
  let renderTarget = tag(state(void 0), "renderTarget");
  let cubeCamera;
  const init = () => {
    set(
      renderTarget,
      new WebGLCubeRenderTarget2(cubeMapSize(), {
        type: HalfFloatType,
        generateMipmaps: true,
        minFilter: LinearMipmapLinearFilter,
        ...webGLRenderTargetOptions()
      }),
      true
    );
    cubeCamera = new CubeCamera2(1, 1.1, get(renderTarget));
  };
  const originalEnvironment = scene.environment;
  user_pre_effect(() => {
    if (setEnvironment() && get(renderTarget)) {
      scene.environment = get(renderTarget).texture;
      invalidate();
    } else if (!setEnvironment()) {
      scene.environment = originalEnvironment;
      invalidate();
    }
  });
  const { start: scheduleUpdate, stop } = useTask(
    () => {
      sky.scale.setScalar(scale());
      uniforms.turbidity.value = turbidity();
      uniforms.rayleigh.value = rayleigh();
      uniforms.mieCoefficient.value = mieCoefficient();
      uniforms.mieDirectionalG.value = mieDirectionalG();
      const phi = MathUtils2.degToRad(90 - elevation());
      const theta = MathUtils2.degToRad(azimuth());
      sunPosition.setFromSphericalCoords(1, phi, theta);
      uniforms.sunPosition.value.copy(sunPosition);
      if (setEnvironment()) {
        if (!get(renderTarget) || !cubeCamera) init();
        cubeCamera?.update(renderer, sky);
      }
      invalidate();
      stop();
    },
    { autoStart: false, autoInvalidate: false }
  );
  observe.pre(
    () => [
      scale(),
      turbidity(),
      rayleigh(),
      mieCoefficient(),
      mieDirectionalG(),
      elevation(),
      azimuth()
    ],
    () => scheduleUpdate()
  );
  onDestroy(() => {
    sky.material.dispose();
    scene.environment = originalEnvironment;
    try {
      get(renderTarget)?.dispose();
    } catch (error) {
      console.warn(...log_if_contains_state("warn", "Could not dispose renderTarget:", error));
    }
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return sky;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Sky_1, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: sky, sunPosition, renderTarget: get(renderTarget) })), "render", Sky_1, 114, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Sky_1,
      109,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Sky_1 = hmr(Sky_1);
  import.meta.hot.accept((module) => {
    Sky_1[HMR].update(module.default);
  });
}
var Sky_default = Sky_1;

// node_modules/@threlte/extras/dist/components/Align/Align.svelte
import { Box3 as Box32, Group as Group6, Sphere as Sphere3, Vector3 as Vector311 } from "three";

// node_modules/@threlte/extras/dist/components/InjectPlugin/InjectPlugin.svelte
InjectPlugin[FILENAME] = "node_modules/@threlte/extras/dist/components/InjectPlugin/InjectPlugin.svelte";
function InjectPlugin($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InjectPlugin);
  injectPlugin($$props.name, $$props.plugin);
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", InjectPlugin, 22, 0);
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  InjectPlugin = hmr(InjectPlugin);
  import.meta.hot.accept((module) => {
    InjectPlugin[HMR].update(module.default);
  });
}
var InjectPlugin_default = InjectPlugin;

// node_modules/@threlte/extras/dist/components/Align/Align.svelte
Align[FILENAME] = "node_modules/@threlte/extras/dist/components/Align/Align.svelte";
function Align($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Align);
  var $$ownership_validator = create_ownership_validator($$props);
  const { renderStage } = useThrelte();
  let x = prop($$props, "x", 3, 0), y2 = prop($$props, "y", 3, 0), z2 = prop($$props, "z", 3, 0), precise = prop($$props, "precise", 3, false), auto = prop($$props, "auto", 3, false), ref = prop($$props, "ref", 15), stage = prop($$props, "stage", 19, () => useStage("<Align>", { before: renderStage })), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "z",
      "precise",
      "auto",
      "ref",
      "onalign",
      "children",
      "stage"
    ],
    "props"
  );
  const group = new Group6();
  const innerGroup = new Group6();
  const outerGroup = new Group6();
  const calculate = () => {
    if (strict_equals(x(), false) && strict_equals(y2(), false) && strict_equals(z2(), false)) return;
    outerGroup.matrixWorld.identity();
    const box3 = new Box32().setFromObject(innerGroup, precise());
    const align2 = new Vector311();
    const sphere3 = new Sphere3();
    const width2 = box3.max.x - box3.min.x;
    const height2 = box3.max.y - box3.min.y;
    const depth = box3.max.z - box3.min.z;
    box3.getCenter(align2);
    box3.getBoundingSphere(sphere3);
    const vAlign = (y2() || 0) * height2 / 2;
    const hAlign = (x() || 0) * width2 / 2;
    const dAlign = (z2() || 0) * depth / 2;
    outerGroup.position.set(strict_equals(x(), false) ? 0 : -align2.x + hAlign, strict_equals(y2(), false) ? 0 : -align2.y + vAlign, strict_equals(z2(), false) ? 0 : -align2.z + dAlign);
    $$props.onalign?.({
      boundingBox: box3,
      center: outerGroup.position.clone(),
      boundingSphere: sphere3,
      container: group,
      depth,
      depthAlignment: dAlign,
      height: height2,
      verticalAlignment: vAlign,
      width: width2,
      horizontalAlignment: hAlign
    });
  };
  const { start: scheduleAligning, stop } = useTask(
    () => {
      calculate();
      stop();
    },
    { autoStart: false, stage: stage() }
  );
  const align = scheduleAligning;
  observe(() => [x(), y2(), z2(), precise()], scheduleAligning);
  const plugin = (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    observe.pre(() => [args.ref], () => {
      if (auto()) scheduleAligning();
      return () => {
        if (auto()) scheduleAligning();
      };
    });
  };
  var $$exports = {
    get align() {
      return align;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return group;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Align, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => T(node_1, {
                get is() {
                  return outerGroup;
                },
                children: wrap_snippet(Align, ($$anchor3, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_2 = first_child(fragment_2);
                  add_svelte_meta(
                    () => T(node_2, {
                      get is() {
                        return innerGroup;
                      },
                      children: wrap_snippet(Align, ($$anchor4, $$slotProps3) => {
                        var fragment_3 = comment();
                        var node_3 = first_child(fragment_3);
                        add_svelte_meta(
                          () => InjectPlugin_default(node_3, {
                            name: "align",
                            plugin,
                            children: wrap_snippet(Align, ($$anchor5, $$slotProps4) => {
                              var fragment_4 = comment();
                              var node_4 = first_child(fragment_4);
                              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop, () => ({ align: scheduleAligning, ref: group })), "render", Align, 115, 8);
                              append($$anchor5, fragment_4);
                            }),
                            $$slots: { default: true }
                          }),
                          "component",
                          Align,
                          111,
                          6,
                          { componentTag: "InjectPlugin" }
                        );
                        append($$anchor4, fragment_3);
                      }),
                      $$slots: { default: true }
                    }),
                    "component",
                    Align,
                    110,
                    4,
                    { componentTag: "T" }
                  );
                  append($$anchor3, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              Align,
              109,
              2,
              { componentTag: "T" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Align,
      104,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Align = hmr(Align);
  import.meta.hot.accept((module) => {
    Align[HMR].update(module.default);
  });
}
var Align_default = Align;

// node_modules/@threlte/extras/dist/components/CSM/CSM.svelte
import { CSM } from "three/examples/jsm/csm/CSM.js";

// node_modules/@threlte/extras/dist/components/CSM/useMaterials.svelte.js
var useMaterials = () => {
  let setupCallback = void 0;
  const allMaterials = /* @__PURE__ */ new Set();
  const isSupportedMaterial = (material2) => {
    return isInstanceOf(material2, "MeshStandardMaterial") || isInstanceOf(material2, "MeshPhongMaterial");
  };
  const addMaterial = (material2) => {
    if (allMaterials.has(material2)) return;
    allMaterials.add(material2);
    setupCallback?.(material2);
  };
  const extractMaterials = (ref) => {
    if (isSupportedMaterial(ref)) {
      addMaterial(ref);
    } else if (isInstanceOf(ref, "Mesh")) {
      if (Array.isArray(ref.material)) {
        ref.material.forEach((material2) => {
          if (isSupportedMaterial(material2)) {
            addMaterial(material2);
          }
        });
      } else {
        if (isSupportedMaterial(ref.material)) {
          addMaterial(ref.material);
        }
      }
    }
  };
  const onNewMaterial = (callback) => {
    setupCallback = callback;
  };
  injectPlugin("csm", (args) => {
    user_pre_effect(() => {
      extractMaterials(args.ref);
    });
  });
  user_pre_effect(() => {
    return () => setupCallback = void 0;
  });
  return { onNewMaterial, allMaterials };
};

// node_modules/@threlte/extras/dist/components/CSM/CSM.svelte
CSM_1[FILENAME] = "node_modules/@threlte/extras/dist/components/CSM/CSM.svelte";
var root4 = add_locations(from_html(`<!> <!>`, 1), CSM_1[FILENAME], []);
function CSM_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CSM_1);
  const $defaultCamera = () => (validate_store(defaultCamera, "defaultCamera"), store_get(defaultCamera, "$defaultCamera", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let enabled = prop($$props, "enabled", 3, true), args = prop($$props, "args", 19, () => ({})), lightDirection = prop($$props, "lightDirection", 19, () => [1, -1, 1]);
  const { camera: defaultCamera, scene, size } = useThrelte();
  let csm = tag(state(void 0), "csm");
  useTask(() => get(csm)?.update(), { autoInvalidate: false });
  const { onNewMaterial, allMaterials } = useMaterials();
  const disposeCsm = () => {
    get(csm)?.remove();
    get(csm)?.dispose();
    set(csm, void 0);
  };
  observe(() => [enabled()], ([enabled2]) => {
    if (enabled2) {
      const nextCSM = new CSM({
        camera: $$props.camera ?? $defaultCamera(),
        parent: scene,
        ...args()
      });
      $$props.configure?.(nextCSM);
      for (const material2 of allMaterials) {
        nextCSM.setupMaterial(material2);
      }
      onNewMaterial((material2) => nextCSM.setupMaterial(material2));
      set(csm, nextCSM);
    } else {
      onNewMaterial(void 0);
      disposeCsm();
    }
  });
  observe(() => [size, get(csm)], ([, csm2]) => {
    csm2?.updateFrustums();
  });
  observe(() => [defaultCamera, $$props.camera, get(csm)], ([defaultCamera2, camera, csm2]) => {
    if (!csm2) return;
    csm2.camera = camera ?? defaultCamera2;
    if (strict_equals(args().maxFar, void 0, false)) csm2.maxFar = args().maxFar;
    if (strict_equals(args().mode, void 0, false)) csm2.mode = args().mode;
    csm2.updateFrustums();
  });
  observe(() => [get(csm), $$props.lightIntensity, $$props.lightColor], ([csm2, intensity, color]) => {
    csm2?.lights.forEach((light) => {
      if (strict_equals(intensity, void 0, false)) {
        light.intensity = intensity / Math.PI;
      }
      if (strict_equals(color, void 0, false)) {
        light.color.set(color);
      }
    });
  });
  observe(() => [get(csm), lightDirection()], ([csm2, direction2]) => {
    csm2?.lightDirection.set(...direction2).normalize();
  });
  user_pre_effect(() => {
    return disposeCsm;
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = root4();
  var node = first_child(fragment2);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", CSM_1, 130, 0);
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_2, () => $$props.fallback ?? noop), "render", CSM_1, 133, 2);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (!enabled()) $$render(consequent);
      }),
      "if",
      CSM_1,
      132,
      0
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  CSM_1 = hmr(CSM_1);
  import.meta.hot.accept((module) => {
    CSM_1[HMR].update(module.default);
  });
}
var CSM_default = CSM_1;

// node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte
import { Group as Group7, Quaternion as Quaternion3 } from "three";
Billboard[FILENAME] = "node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte";
function Billboard($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Billboard);
  var $$ownership_validator = create_ownership_validator($$props);
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let follow = prop($$props, "follow", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "follow",
      "ref",
      "children"
    ],
    "props"
  );
  const inner = new Group7();
  const localRef = new Group7();
  const { camera, renderStage } = useThrelte();
  const q3 = new Quaternion3();
  let followObject = tag(
    user_derived(() => strict_equals(follow(), true) ? $camera() : strict_equals(follow(), false) ? void 0 : follow()),
    "followObject"
  );
  const stage = useStage("<Billboard>", { before: renderStage });
  const { start, stop } = useTask(
    () => {
      localRef.updateMatrix();
      localRef.updateWorldMatrix(false, false);
      localRef.getWorldQuaternion(q3);
      get(followObject)?.getWorldQuaternion(inner.quaternion).premultiply(q3.invert());
    },
    { autoStart: false, stage }
  );
  user_pre_effect(() => {
    if (follow()) {
      start();
    } else {
      stop();
    }
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return localRef;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Billboard, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => T(node_1, {
                get is() {
                  return inner;
                },
                children: wrap_snippet(Billboard, ($$anchor3, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_2 = first_child(fragment_2);
                  add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: localRef })), "render", Billboard, 45, 4);
                  append($$anchor3, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              Billboard,
              44,
              2,
              { componentTag: "T" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Billboard,
      39,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Billboard = hmr(Billboard);
  import.meta.hot.accept((module) => {
    Billboard[HMR].update(module.default);
  });
}
var Billboard_default = Billboard;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte
import { Color as Color6, AdditiveBlending, ShaderMaterial as ShaderMaterial4 } from "three";

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/fragment.js
import { ShaderChunk as ShaderChunk3 } from "three";
var fragmentShader4 = `
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${ShaderChunk3.tonemapping_fragment}
	${ShaderChunk3.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/vertex.js
var vertexShader4 = `varying vec3 vPosition;
varying vec3 vNormal;

void main() {
	vec4 modelPosition = modelMatrix * vec4(position, 1.0);
	gl_Position = projectionMatrix * viewMatrix * modelPosition;
	vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
	vPosition = modelPosition.xyz;
	vNormal = modelNormal.xyz;
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte
FakeGlowMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte";
function FakeGlowMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, FakeGlowMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  let falloff = prop($$props, "falloff", 3, 0.1), glowInternalRadius = prop($$props, "glowInternalRadius", 3, 6), glowColor = prop($$props, "glowColor", 3, "green"), glowSharpness = prop($$props, "glowSharpness", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "falloff",
      "glowInternalRadius",
      "glowColor",
      "glowSharpness",
      "ref",
      "children"
    ],
    "props"
  );
  const uniforms = {
    falloff: { value: falloff() },
    glowInternalRadius: { value: glowInternalRadius() },
    glowColor: { value: new Color6(glowColor()) },
    glowSharpness: { value: glowSharpness() }
  };
  const material2 = new ShaderMaterial4({
    uniforms,
    fragmentShader: fragmentShader4,
    vertexShader: vertexShader4,
    transparent: true,
    blending: AdditiveBlending,
    depthTest: false
  });
  const { invalidate } = useThrelte();
  user_pre_effect(() => {
    material2.uniforms.falloff.value = falloff();
    invalidate();
  });
  user_pre_effect(() => {
    material2.uniforms.glowInternalRadius.value = glowInternalRadius();
    invalidate();
  });
  user_pre_effect(() => {
    material2.uniforms.glowColor.value.set(glowColor());
    invalidate();
  });
  user_pre_effect(() => {
    material2.uniforms.glowSharpness.value = glowSharpness();
    invalidate();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return material2;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(FakeGlowMaterial, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material2 })), "render", FakeGlowMaterial, 59, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      FakeGlowMaterial,
      54,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  FakeGlowMaterial = hmr(FakeGlowMaterial);
  import.meta.hot.accept((module) => {
    FakeGlowMaterial[HMR].update(module.default);
  });
}
var FakeGlowMaterial_default = FakeGlowMaterial;

// node_modules/@threlte/extras/dist/components/ShadowMaterial/ShadowMaterial.svelte
import { DoubleSide as DoubleSide4, MeshBasicMaterial as MeshBasicMaterial4 } from "three";

// node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte
import { CanvasTexture } from "three";

// node_modules/@threlte/extras/dist/components/GradientTexture/common.js
var addStops = (gradient, stops = []) => {
  for (const { color, offset } of stops) {
    gradient.addColorStop(offset, color);
  }
  return gradient;
};

// node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte
RadialGradientTexture[FILENAME] = "node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte";
function RadialGradientTexture($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RadialGradientTexture);
  var $$ownership_validator = create_ownership_validator($$props);
  let width2 = prop($$props, "width", 3, 1024), height2 = prop($$props, "height", 3, 1024), innerRadius = prop($$props, "innerRadius", 3, 0), outerRadius2 = prop($$props, "outerRadius", 3, "auto"), stops = prop($$props, "stops", 19, () => [{ offset: 0, color: "black" }, { offset: 1, color: "white" }]), attach = prop($$props, "attach", 3, "map"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "innerRadius",
      "outerRadius",
      "stops",
      "attach",
      "children",
      "ref"
    ],
    "props"
  );
  const canvas = new OffscreenCanvas(0, 0);
  const context = canvas.getContext("2d");
  if (strict_equals(context, null)) {
    throw new Error("radial gradient texture context is null");
  }
  const texture = new CanvasTexture(canvas);
  user_pre_effect(() => {
    canvas.width = width2();
  });
  user_pre_effect(() => {
    canvas.height = height2();
  });
  observe(() => [$$props.wrapS, $$props.wrapT], () => {
    texture.needsUpdate = true;
    invalidate();
  });
  const halfWidth = tag(user_derived(() => 0.5 * width2()), "halfWidth");
  const halfHeight = tag(user_derived(() => 0.5 * height2()), "halfHeight");
  const _outerRadius = tag(
    user_derived(() => strict_equals(outerRadius2(), "auto") ? Math.hypot(get(halfWidth), get(halfHeight)) : outerRadius2()),
    "_outerRadius"
  );
  const gradient = tag(
    user_derived(() => {
      const gradient2 = context.createRadialGradient(get(halfWidth), get(halfHeight), innerRadius(), get(halfWidth), get(halfHeight), get(_outerRadius));
      addStops(gradient2, stops());
      return gradient2;
    }),
    "gradient"
  );
  const { invalidate } = useThrelte();
  user_effect(() => {
    context.fillStyle = get(gradient);
    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
    texture.needsUpdate = true;
    invalidate();
    return () => {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    };
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return texture;
          }
        },
        () => props,
        {
          get attach() {
            return attach();
          },
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(RadialGradientTexture, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: texture })), "render", RadialGradientTexture, 89, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      RadialGradientTexture,
      83,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  RadialGradientTexture = hmr(RadialGradientTexture);
  import.meta.hot.accept((module) => {
    RadialGradientTexture[HMR].update(module.default);
  });
}
var RadialGradientTexture_default = RadialGradientTexture;

// node_modules/@threlte/extras/dist/components/ShadowMaterial/ShadowMaterial.svelte
ShadowMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/ShadowMaterial/ShadowMaterial.svelte";
var width = 128;
var height = width;
var outerRadius = 0.5 * width;
var end = { color: "rgba(0,0,0,0)", offset: 1 };
var root_15 = add_locations(from_html(`<!> <!>`, 1), ShadowMaterial[FILENAME], []);
function ShadowMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ShadowMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  let color = prop($$props, "color", 3, "black"), ref = prop($$props, "ref", 15), transparent = prop($$props, "transparent", 3, true), opacity = prop($$props, "opacity", 3, 0.5), depthWrite = prop($$props, "depthWrite", 3, false), side = prop($$props, "side", 3, DoubleSide4), fog = prop($$props, "fog", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "color",
      "ref",
      "transparent",
      "opacity",
      "depthWrite",
      "side",
      "fog"
    ],
    "restProps"
  );
  const start = tag(user_derived(() => ({ color: color(), offset: 0 })), "start");
  const stops = tag(user_derived(() => [get(start), end]), "stops");
  const material2 = new MeshBasicMaterial4();
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return material2;
          },
          get transparent() {
            return transparent();
          },
          get side() {
            return side();
          },
          get depthWrite() {
            return depthWrite();
          },
          get fog() {
            return fog();
          },
          get opacity() {
            return opacity();
          }
        },
        () => restProps,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(ShadowMaterial, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_15();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => RadialGradientTexture_default(node_1, {
                width,
                height,
                outerRadius,
                get stops() {
                  return get(stops);
                }
              }),
              "component",
              ShadowMaterial,
              52,
              2,
              { componentTag: "RadialGradientTexture" }
            );
            var node_2 = sibling(node_1, 2);
            add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: material2 })), "render", ShadowMaterial, 58, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      ShadowMaterial,
      42,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  ShadowMaterial = hmr(ShadowMaterial);
  import.meta.hot.accept((module) => {
    ShadowMaterial[HMR].update(module.default);
  });
}
var ShadowMaterial_default = ShadowMaterial;

// node_modules/@threlte/extras/dist/components/Stars/Stars.svelte
import {
  AdditiveBlending as AdditiveBlending2,
  BufferAttribute as BufferAttribute2,
  BufferGeometry as BufferGeometry3,
  Color as Color7,
  Points,
  ShaderMaterial as ShaderMaterial5,
  Spherical as Spherical2,
  Vector3 as Vector312
} from "three";

// node_modules/@threlte/extras/dist/components/Stars/fragment.js
import { ShaderChunk as ShaderChunk4 } from "three";
var fragmentShader5 = `
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${ShaderChunk4.tonemapping_fragment}
	${ShaderChunk4.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/Stars/vertex.js
var vertexShader5 = `uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`;

// node_modules/@threlte/extras/dist/components/Stars/Stars.svelte
Stars[FILENAME] = "node_modules/@threlte/extras/dist/components/Stars/Stars.svelte";
var root_16 = add_locations(from_html(`<!> <!> <!>`, 1), Stars[FILENAME], []);
function Stars($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Stars);
  var $$ownership_validator = create_ownership_validator($$props);
  let count = prop($$props, "count", 3, 5e3), radius = prop($$props, "radius", 3, 50), depth = prop($$props, "depth", 3, 50), factor = prop($$props, "factor", 3, 6), saturation = prop($$props, "saturation", 3, 1), lightness = prop($$props, "lightness", 3, 0.8), speed = prop($$props, "speed", 3, 1), fade = prop($$props, "fade", 3, true), opacity = prop($$props, "opacity", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "count",
      "radius",
      "depth",
      "factor",
      "saturation",
      "lightness",
      "speed",
      "fade",
      "opacity",
      "ref",
      "children"
    ],
    "props"
  );
  const points = new Points();
  const vec32 = new Vector312();
  const spherical = new Spherical2();
  const color = new Color7();
  const generateStar = (r) => {
    return vec32.setFromSpherical(spherical.set(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
  };
  const geometry = new BufferGeometry3();
  const positions = tag(user_derived(() => new BufferAttribute2(new Float32Array(count() * 3), 3)), "positions");
  const colors = tag(user_derived(() => new BufferAttribute2(new Float32Array(count() * 3), 3)), "colors");
  const sizes = tag(user_derived(() => new BufferAttribute2(new Float32Array(count()), 1)), "sizes");
  user_pre_effect(() => {
    geometry.setAttribute("position", get(positions));
    geometry.setAttribute("color", get(colors));
    geometry.setAttribute("size", get(sizes));
  });
  user_pre_effect(() => {
    const increment = depth() / count();
    let r = radius() + depth();
    for (let i = 0; i < count(); i += 1) {
      r -= increment * Math.random();
      const position2 = generateStar(r);
      get(positions).setXYZ(i, position2.x, position2.y, position2.z);
      color.setHSL(i / count(), saturation(), lightness());
      get(colors).setXYZ(i, color.r, color.g, color.b);
      get(sizes).setX(i, (0.5 + 0.5 * Math.random()) * factor());
    }
  });
  const { stop, start } = useTask(
    (dt3) => {
      uniforms.time.value += dt3 * speed();
    },
    { autoStart: false }
  );
  user_pre_effect(() => strict_equals(speed(), 0) ? stop() : start());
  const uniforms = {
    time: { value: 0 },
    fade: { value: 1 },
    opacity: { value: 1 }
  };
  const material2 = new ShaderMaterial5({ uniforms, vertexShader: vertexShader5, fragmentShader: fragmentShader5 });
  user_pre_effect(() => {
    uniforms.fade.value = fade() ? 1 : 0;
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return points;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Stars, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_16();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => T(node_1, {
                get is() {
                  return geometry;
                }
              }),
              "component",
              Stars,
              107,
              2,
              { componentTag: "T" }
            );
            var node_2 = sibling(node_1, 2);
            add_svelte_meta(
              () => T(node_2, {
                get is() {
                  return material2;
                },
                get blending() {
                  return AdditiveBlending2;
                },
                depthWrite: false,
                transparent: true,
                vertexColors: true
              }),
              "component",
              Stars,
              108,
              2,
              { componentTag: "T" }
            );
            var node_3 = sibling(node_2, 2);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => ({ ref: points })), "render", Stars, 115, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Stars,
      102,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Stars = hmr(Stars);
  import.meta.hot.accept((module) => {
    Stars[HMR].update(module.default);
  });
}
var Stars_default = Stars;

// node_modules/@threlte/extras/dist/components/Svg/Svg.svelte
import { DoubleSide as DoubleSide5 } from "three";
import { SVGLoader } from "three/examples/jsm/loaders/SVGLoader.js";
Svg[FILENAME] = "node_modules/@threlte/extras/dist/components/Svg/Svg.svelte";
var root_6 = add_locations(from_html(`<!> <!>`, 1), Svg[FILENAME], []);
var root_32 = add_locations(from_html(`<!> <!>`, 1), Svg[FILENAME], []);
function Svg($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Svg);
  var $$ownership_validator = create_ownership_validator($$props);
  const $svg = () => (validate_store(get(svg), "svg"), store_get(get(svg), "$svg", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let skipFill = prop($$props, "skipFill", 3, false), skipStrokes = prop($$props, "skipStrokes", 3, false), ref = prop($$props, "ref", 15), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "skipFill",
      "skipStrokes",
      "fillMaterialProps",
      "strokeMaterialProps",
      "fillMeshProps",
      "strokeMeshProps",
      "ref"
    ],
    "rest"
  );
  const suspend = useSuspense();
  const loader = useLoader(SVGLoader);
  const svg = tag(
    user_derived(() => suspend(loader.load($$props.src.startsWith("<svg") ? `data:image/svg+xml;utf8,${$$props.src}` : $$props.src))),
    "svg"
  );
  const paths = tag(user_derived(() => $svg()?.paths ?? []), "paths");
  const strokeGeometries = tag(
    user_derived(() => skipStrokes() ? [] : get(paths).map((path) => strict_equals(path.userData?.style.stroke, void 0) || strict_equals(path.userData.style.stroke, "none") ? null : path.subPaths.map((subPath) => SVGLoader.pointsToStroke(subPath.getPoints(), path.userData?.style)))),
    "strokeGeometries"
  );
  user_pre_effect(() => {
    return () => {
      for (const group of get(strokeGeometries)) {
        if (group) {
          group.map((g) => g.dispose());
        }
      }
    };
  });
  let renderOrder = 0;
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(
    () => component(node, () => T.Group, ($$anchor2, T_Group) => {
      $$ownership_validator.binding("ref", T_Group, ref);
      T_Group($$anchor2, spread_props(() => rest, {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(Svg, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(
            () => component(node_1, () => T.Group, ($$anchor4, T_Group_1) => {
              T_Group_1($$anchor4, {
                "scale.y": -1,
                children: wrap_snippet(Svg, ($$anchor5, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_2 = first_child(fragment_2);
                  validate_each_keys(() => get(paths), (path) => path);
                  add_svelte_meta(
                    () => each(node_2, 18, () => get(paths), (path) => path, ($$anchor6, path, p) => {
                      var fragment_3 = root_32();
                      var node_3 = first_child(fragment_3);
                      {
                        var consequent = ($$anchor7) => {
                          var fragment_4 = comment();
                          var node_4 = first_child(fragment_4);
                          validate_each_keys(() => SVGLoader.createShapes(path), (shape) => shape);
                          add_svelte_meta(
                            () => each(node_4, 16, () => SVGLoader.createShapes(path), (shape) => shape, ($$anchor8, shape) => {
                              var fragment_5 = comment();
                              var node_5 = first_child(fragment_5);
                              {
                                let $0 = user_derived(() => renderOrder++);
                                add_svelte_meta(
                                  () => component(node_5, () => T.Mesh, ($$anchor9, T_Mesh) => {
                                    T_Mesh($$anchor9, spread_props(() => $$props.fillMeshProps, {
                                      get renderOrder() {
                                        return get($0);
                                      },
                                      children: wrap_snippet(Svg, ($$anchor10, $$slotProps3) => {
                                        var fragment_6 = root_6();
                                        var node_6 = first_child(fragment_6);
                                        {
                                          let $02 = user_derived(() => [shape]);
                                          add_svelte_meta(
                                            () => component(node_6, () => T.ShapeGeometry, ($$anchor11, T_ShapeGeometry) => {
                                              T_ShapeGeometry($$anchor11, {
                                                get args() {
                                                  return get($02);
                                                }
                                              });
                                            }),
                                            "component",
                                            Svg,
                                            75,
                                            12,
                                            { componentTag: "T.ShapeGeometry" }
                                          );
                                        }
                                        var node_7 = sibling(node_6, 2);
                                        {
                                          let $02 = user_derived(() => path.userData?.style.fill);
                                          let $1 = user_derived(() => path.userData?.style.fillOpacity);
                                          add_svelte_meta(
                                            () => component(node_7, () => T.MeshBasicMaterial, ($$anchor11, T_MeshBasicMaterial) => {
                                              T_MeshBasicMaterial($$anchor11, spread_props(
                                                {
                                                  get color() {
                                                    return get($02);
                                                  },
                                                  get opacity() {
                                                    return get($1);
                                                  },
                                                  transparent: true,
                                                  get side() {
                                                    return DoubleSide5;
                                                  },
                                                  depthWrite: false
                                                },
                                                () => $$props.fillMaterialProps
                                              ));
                                            }),
                                            "component",
                                            Svg,
                                            76,
                                            12,
                                            { componentTag: "T.MeshBasicMaterial" }
                                          );
                                        }
                                        append($$anchor10, fragment_6);
                                      }),
                                      $$slots: { default: true }
                                    }));
                                  }),
                                  "component",
                                  Svg,
                                  71,
                                  10,
                                  { componentTag: "T.Mesh" }
                                );
                              }
                              append($$anchor8, fragment_5);
                            }),
                            "each",
                            Svg,
                            70,
                            8
                          );
                          append($$anchor7, fragment_4);
                        };
                        add_svelte_meta(
                          () => if_block(node_3, ($$render) => {
                            if (!skipFill() && strict_equals(path.userData?.style.fill, void 0, false) && strict_equals(path.userData.style.fill, "none", false)) $$render(consequent);
                          }),
                          "if",
                          Svg,
                          69,
                          6
                        );
                      }
                      var node_8 = sibling(node_3, 2);
                      {
                        var consequent_2 = ($$anchor7) => {
                          var fragment_7 = comment();
                          var node_9 = first_child(fragment_7);
                          validate_each_keys(() => path.subPaths, (_subPath) => _subPath);
                          add_svelte_meta(
                            () => each(node_9, 18, () => path.subPaths, (_subPath) => _subPath, ($$anchor8, _subPath, s) => {
                              var fragment_8 = comment();
                              var node_10 = first_child(fragment_8);
                              {
                                var consequent_1 = ($$anchor9) => {
                                  var fragment_9 = comment();
                                  var node_11 = first_child(fragment_9);
                                  {
                                    let $0 = user_derived(() => get(strokeGeometries)[get(p)]?.[get(s)]);
                                    let $1 = user_derived(() => renderOrder++);
                                    add_svelte_meta(
                                      () => component(node_11, () => T.Mesh, ($$anchor10, T_Mesh_1) => {
                                        T_Mesh_1($$anchor10, spread_props(
                                          {
                                            get geometry() {
                                              return get($0);
                                            }
                                          },
                                          () => $$props.strokeMeshProps,
                                          {
                                            get renderOrder() {
                                              return get($1);
                                            },
                                            children: wrap_snippet(Svg, ($$anchor11, $$slotProps3) => {
                                              var fragment_10 = comment();
                                              var node_12 = first_child(fragment_10);
                                              {
                                                let $02 = user_derived(() => path.userData?.style.stroke);
                                                let $12 = user_derived(() => path.userData?.style.strokeOpacity);
                                                add_svelte_meta(
                                                  () => component(node_12, () => T.MeshBasicMaterial, ($$anchor12, T_MeshBasicMaterial_1) => {
                                                    T_MeshBasicMaterial_1($$anchor12, spread_props(
                                                      {
                                                        get color() {
                                                          return get($02);
                                                        },
                                                        get opacity() {
                                                          return get($12);
                                                        },
                                                        transparent: true,
                                                        get side() {
                                                          return DoubleSide5;
                                                        },
                                                        depthWrite: false
                                                      },
                                                      () => $$props.strokeMaterialProps
                                                    ));
                                                  }),
                                                  "component",
                                                  Svg,
                                                  96,
                                                  14,
                                                  { componentTag: "T.MeshBasicMaterial" }
                                                );
                                              }
                                              append($$anchor11, fragment_10);
                                            }),
                                            $$slots: { default: true }
                                          }
                                        ));
                                      }),
                                      "component",
                                      Svg,
                                      91,
                                      12,
                                      { componentTag: "T.Mesh" }
                                    );
                                  }
                                  append($$anchor9, fragment_9);
                                };
                                add_svelte_meta(
                                  () => if_block(node_10, ($$render) => {
                                    if (get(strokeGeometries)[get(p)]) $$render(consequent_1);
                                  }),
                                  "if",
                                  Svg,
                                  90,
                                  10
                                );
                              }
                              append($$anchor8, fragment_8);
                            }),
                            "each",
                            Svg,
                            89,
                            8
                          );
                          append($$anchor7, fragment_7);
                        };
                        add_svelte_meta(
                          () => if_block(node_8, ($$render) => {
                            if (!skipStrokes() && strict_equals(path.userData?.style.stroke, void 0, false) && strict_equals(path.userData.style.stroke, "none", false)) $$render(consequent_2);
                          }),
                          "if",
                          Svg,
                          88,
                          6
                        );
                      }
                      append($$anchor6, fragment_3);
                    }),
                    "each",
                    Svg,
                    68,
                    4
                  );
                  append($$anchor5, fragment_2);
                }),
                $$slots: { default: true }
              });
            }),
            "component",
            Svg,
            67,
            2,
            { componentTag: "T.Group" }
          );
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }));
    }),
    "component",
    Svg,
    63,
    0,
    { componentTag: "T.Group" }
  );
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Svg = hmr(Svg);
  import.meta.hot.accept((module) => {
    Svg[HMR].update(module.default);
  });
}
var Svg_default = Svg;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte
import { Color as Color8, Matrix4 as Matrix417, Mesh as Mesh8, ShaderMaterial as ShaderMaterial6, Texture as Texture2, Vector2 as Vector29 } from "three";

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
import { BufferAttribute as BufferAttribute4, Box3 as Box37, FrontSide as FrontSide2 } from "three";

// node_modules/three-mesh-bvh/src/core/Constants.js
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var NOT_INTERSECTED = 0;
var INTERSECTED = 1;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var UINT32_PER_NODE = BYTES_PER_NODE / 4;
var IS_LEAFNODE_FLAG = 65535;
var LEAFNODE_MASK_32 = IS_LEAFNODE_FLAG << 16;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = /* @__PURE__ */ Symbol("SKIP_GENERATION");

// node_modules/three-mesh-bvh/src/core/build/geometryUtils.js
import { BufferAttribute as BufferAttribute3 } from "three";
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute3(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo, range) {
  const triCount = getTriCount(geo);
  const drawRange = range ? range : geo.drawRange;
  const start = drawRange.start / 3;
  const end2 = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end2) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo, range) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo, range);
  }
  const ranges = [];
  const drawRange = range ? range : geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  const triCount = getTriCount(geo);
  const events = [];
  for (const group of geo.groups) {
    const { start, count } = group;
    const groupStart = start / 3;
    const groupCount = isFinite(count) ? count : triCount * 3 - start;
    const groupEnd = (start + groupCount) / 3;
    if (groupStart < drawRangeEnd && groupEnd > drawRangeStart) {
      events.push({ pos: Math.max(drawRangeStart, groupStart), isStart: true });
      events.push({ pos: Math.min(drawRangeEnd, groupEnd), isStart: false });
    }
  }
  events.sort((a, b2) => {
    if (a.pos !== b2.pos) {
      return a.pos - b2.pos;
    } else {
      return a.type === "end" ? -1 : 1;
    }
  });
  let activeGroups = 0;
  let lastPos = null;
  for (const event of events) {
    const newPos = event.pos;
    if (activeGroups !== 0 && newPos !== lastPos) {
      ranges.push({
        offset: lastPos,
        count: newPos - lastPos
      });
    }
    activeGroups += event.isStart ? 1 : -1;
    lastPos = newPos;
  }
  return ranges;
}

// node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js
function getBounds(triangleBounds, offset, count, target, centroidTarget) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const boundsOffset = triangleBounds.offset || 0;
  for (let i = (offset - boundsOffset) * 6, end2 = (offset + count - boundsOffset) * 6; i < end2; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx) minx = lx;
    if (rx > maxx) maxx = rx;
    if (cx < cminx) cminx = cx;
    if (cx > cmaxx) cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny) miny = ly;
    if (ry > maxy) maxy = ry;
    if (cy < cminy) cminy = cy;
    if (cy > cmaxy) cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz) minz = lz;
    if (rz > maxz) maxz = rz;
    if (cz < cminz) cminz = cz;
    if (cz > cmaxz) cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, offset, count = null, indirectBuffer = null, targetBuffer = null) {
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const normalized = posAttr.normalized;
  if (targetBuffer === null) {
    targetBuffer = new Float32Array(count * 6);
    targetBuffer.offset = offset;
  } else {
    if (offset < 0 || count + offset > targetBuffer.length / 6) {
      throw new Error("MeshBVH: compute triangle bounds range is invalid.");
    }
  }
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  const writeOffset = targetBuffer.offset;
  for (let i = offset, l = offset + count; i < l; i++) {
    const tri = indirectBuffer ? indirectBuffer[i] : i;
    const tri3 = tri * 3;
    const boundsIndexOffset = (i - writeOffset) * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el2 = 0; el2 < 3; el2++) {
      let a, b2, c;
      if (normalized) {
        a = posAttr[getters[el2]](ai);
        b2 = posAttr[getters[el2]](bi);
        c = posAttr[getters[el2]](ci);
      } else {
        a = posArr[ai + el2];
        b2 = posArr[bi + el2];
        c = posArr[ci + el2];
      }
      let min = a;
      if (b2 < min) min = b2;
      if (c < min) min = c;
      let max = a;
      if (b2 > max) max = b2;
      if (c > max) max = c;
      const halfExtents = (max - min) / 2;
      const el22 = el2 * 2;
      targetBuffer[boundsIndexOffset + el22 + 0] = min + halfExtents;
      targetBuffer[boundsIndexOffset + el22 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
    }
  }
  return targetBuffer;
}

// node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b2, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b2[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b2[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}

// node_modules/three-mesh-bvh/src/core/build/splitUtils.js
var BIN_COUNT = 32;
var binsSort = (a, b2) => a.candidate - b2.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const boundsOffset = triangleBounds.offset || 0;
    const cStart = (offset - boundsOffset) * 6;
    const cEnd = (offset + count - boundsOffset) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b2 = 0;
        for (let c = cStart; c < cEnd; c += 6, b2++) {
          const bin = truncatedBins[b2];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  const boundsOffset = triangleBounds.offset;
  for (let i = offset, end2 = offset + count; i < end2; i++) {
    avg += triangleBounds[(i - boundsOffset) * 6 + axis * 2];
  }
  return avg / count;
}

// node_modules/three-mesh-bvh/src/core/MeshBVHNode.js
var MeshBVHNode = class {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
};

// node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  const boundsOffset = triangleBounds.offset || 0;
  while (true) {
    while (left <= right && triangleBounds[(left - boundsOffset) * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[(right - boundsOffset) * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        const l = left - boundsOffset;
        const r = right - boundsOffset;
        const tb = triangleBounds[l * 6 + i];
        triangleBounds[l * 6 + i] = triangleBounds[r * 6 + i];
        triangleBounds[r * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  const boundsOffset = triangleBounds.offset || 0;
  while (true) {
    while (left <= right && triangleBounds[(left - boundsOffset) * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[(right - boundsOffset) * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t;
      for (let i = 0; i < 6; i++) {
        const l = left - boundsOffset;
        const r = right - boundsOffset;
        const tb = triangleBounds[l * 6 + i];
        triangleBounds[l * 6 + i] = triangleBounds[r * 6 + i];
        triangleBounds[r * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/buildUtils.js
var float32Array;
var uint32Array;
var uint16Array;
var uint8Array;
var MAX_POINTER = Math.pow(2, 32);
function countNodes(node) {
  if ("count" in node) {
    return 1;
  } else {
    return 1 + countNodes(node.left) + countNodes(node.right);
  }
}
function populateBuffer(byteOffset, node, buffer) {
  float32Array = new Float32Array(buffer);
  uint32Array = new Uint32Array(buffer);
  uint16Array = new Uint16Array(buffer);
  uint8Array = new Uint8Array(buffer);
  return _populateBuffer(byteOffset, node);
}
function _populateBuffer(byteOffset, node) {
  const node32Index = byteOffset / 4;
  const node16Index = byteOffset / 2;
  const isLeaf = "count" in node;
  const boundingData = node.boundingData;
  for (let i = 0; i < 6; i++) {
    float32Array[node32Index + i] = boundingData[i];
  }
  if (isLeaf) {
    if (node.buffer) {
      uint8Array.set(new Uint8Array(node.buffer), byteOffset);
      return byteOffset + node.buffer.byteLength;
    } else {
      uint32Array[node32Index + 6] = node.offset;
      uint16Array[node16Index + 14] = node.count;
      uint16Array[node16Index + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    }
  } else {
    const { left, right, splitAxis } = node;
    const leftByteOffset = byteOffset + BYTES_PER_NODE;
    let rightByteOffset = _populateBuffer(leftByteOffset, left);
    const currentNodeIndex = byteOffset / BYTES_PER_NODE;
    const rightNodeIndex = rightByteOffset / BYTES_PER_NODE;
    const relativeRightIndex = rightNodeIndex - currentNodeIndex;
    if (relativeRightIndex > MAX_POINTER) {
      throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");
    }
    uint32Array[node32Index + 6] = relativeRightIndex;
    uint32Array[node32Index + 7] = splitAxis;
    return _populateBuffer(rightByteOffset, right);
  }
}

// node_modules/three-mesh-bvh/src/core/build/buildTree.js
function generateIndirectBuffer(geometry, useSharedArrayBuffer, ranges) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const length = ranges.reduce((acc, val) => acc + val.count, 0);
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(length * byteCount) : new ArrayBuffer(length * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  let index = 0;
  for (let r = 0; r < ranges.length; r++) {
    const { offset, count } = ranges[r];
    for (let i = 0; i < count; i++) {
      indirectBuffer[index + i] = offset + i;
    }
    index += count;
  }
  return indirectBuffer;
}
function buildTree(bvh2, triangleBounds, offset, count, options) {
  const {
    maxDepth,
    verbose,
    maxLeafTris,
    strategy,
    onProgress,
    indirect
  } = options;
  const indirectBuffer = bvh2._indirectBuffer;
  const geometry = bvh2.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const partionFunc = indirect ? partition_indirect : partition;
  const totalTriangles = getTriCount(geometry);
  const cacheCentroidBoundingData = new Float32Array(6);
  let reachedMaxDepth = false;
  const root6 = new MeshBVHNode();
  getBounds(triangleBounds, offset, count, root6.boundingData, cacheCentroidBoundingData);
  splitNode(root6, offset, count, cacheCentroidBoundingData);
  return root6;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset2, count2, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count2 <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset2, count2, strategy);
    if (split.axis === -1) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset2, count2, split);
    if (splitOffset === offset2 || splitOffset === offset2 + count2) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset2;
      const lcount = splitOffset - offset2;
      node.left = left;
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count2 - lcount;
      node.right = right;
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh2, options) {
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  const geometry = bvh2.geometry;
  let triangleBounds, geometryRanges;
  if (options.indirect) {
    const ranges = getRootIndexRanges(geometry, options.range);
    const indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer, ranges);
    bvh2._indirectBuffer = indirectBuffer;
    triangleBounds = computeTriangleBounds(geometry, 0, indirectBuffer.length, indirectBuffer);
    geometryRanges = [{ offset: 0, count: indirectBuffer.length }];
  } else {
    ensureIndex(geometry, options);
    const fullRange = getFullGeometryRange(geometry, options.range)[0];
    triangleBounds = computeTriangleBounds(geometry, fullRange.offset, fullRange.count);
    geometryRanges = getRootIndexRanges(geometry, options.range);
  }
  bvh2._roots = geometryRanges.map((range) => {
    const root6 = buildTree(bvh2, triangleBounds, range.offset, range.count, options);
    const nodeCount = countNodes(root6);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    populateBuffer(0, root6, buffer);
    return buffer;
  });
}

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
import { Vector3 as Vector316, Matrix4 as Matrix48, Line3 as Line33 } from "three";

// node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js
import { Vector3 as Vector313 } from "three";
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = p[field];
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = (function() {
  const p = new Vector313();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y2 = 0; y2 <= 1; y2++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y2 + boxMax.y * (1 - y2);
          p.z = boxMin.z * z2 + boxMax.z * (1 - z2);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
})();
var areIntersecting = (function() {
  const cacheSatBounds = new SeparatingAxisBounds();
  return function areIntersecting2(shape1, shape2) {
    const points1 = shape1.points;
    const satAxes1 = shape1.satAxes;
    const satBounds1 = shape1.satBounds;
    const points2 = shape2.points;
    const satAxes2 = shape2.satAxes;
    const satBounds2 = shape2.satBounds;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds1[i];
      const sa = satAxes1[i];
      cacheSatBounds.setFromPoints(sa, points2);
      if (sb.isSeparated(cacheSatBounds)) return false;
    }
    for (let i = 0; i < 3; i++) {
      const sb = satBounds2[i];
      const sa = satAxes2[i];
      cacheSatBounds.setFromPoints(sa, points1);
      if (sb.isSeparated(cacheSatBounds)) return false;
    }
  };
})();

// node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js
import { Triangle, Vector3 as Vector315, Vector2 as Vector26, Line3 as Line32, Plane as Plane3 } from "three";

// node_modules/three-mesh-bvh/src/math/MathUtilities.js
import { Vector3 as Vector314, Vector2 as Vector25, Plane as Plane2, Line3 } from "three";
var closestPointLineToLine = (function() {
  const dir1 = new Vector314();
  const dir2 = new Vector314();
  const v02 = new Vector314();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v22 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v22);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
})();
var closestPointsSegmentToSegment = (function() {
  const paramResult = new Vector25();
  const temp14 = new Vector314();
  const temp23 = new Vector314();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp14;
      const closestPoint2 = temp23;
      l1.closestPointToPoint(p2, true, temp14);
      l2.closestPointToPoint(p, true, temp23);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
})();
var sphereIntersectTriangle = (function() {
  const closestPointTemp = new Vector314();
  const projectedPointTemp = new Vector314();
  const planeTemp = new Plane2();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere3, triangle4) {
    const { radius, center } = sphere3;
    const { a, b: b2, c } = triangle4;
    lineTemp.start = a;
    lineTemp.end = b2;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius) return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius) return true;
    lineTemp.start = b2;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius) return true;
    const plane = triangle4.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle4.containsPoint(pp);
      if (cp) return true;
    }
    return false;
  };
})();

// node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js
var componentKeys = ["x", "y", "z"];
var ZERO_EPSILON = 1e-15;
var ZERO_EPSILON_SQR = ZERO_EPSILON * ZERO_EPSILON;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector315());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.plane = new Plane3();
    this.isDegenerateIntoSegment = false;
    this.isDegenerateIntoPoint = false;
    this.degenerateSegment = new Line32();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere3) {
    return sphereIntersectTriangle(sphere3, this);
  }
  update() {
    const a = this.a;
    const b2 = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b2);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b2, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    const lengthAB = axis1.length();
    const lengthBC = axis2.length();
    const lengthCA = axis3.length();
    this.isDegenerateIntoPoint = false;
    this.isDegenerateIntoSegment = false;
    if (lengthAB < ZERO_EPSILON) {
      if (lengthBC < ZERO_EPSILON || lengthCA < ZERO_EPSILON) {
        this.isDegenerateIntoPoint = true;
      } else {
        this.isDegenerateIntoSegment = true;
        this.degenerateSegment.start.copy(a);
        this.degenerateSegment.end.copy(c);
      }
    } else if (lengthBC < ZERO_EPSILON) {
      if (lengthCA < ZERO_EPSILON) {
        this.isDegenerateIntoPoint = true;
      } else {
        this.isDegenerateIntoSegment = true;
        this.degenerateSegment.start.copy(b2);
        this.degenerateSegment.end.copy(a);
      }
    } else if (lengthCA < ZERO_EPSILON) {
      this.isDegenerateIntoSegment = true;
      this.degenerateSegment.start.copy(c);
      this.degenerateSegment.end.copy(b2);
    }
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = (function() {
  const point1 = new Vector315();
  const point2 = new Vector315();
  const edge = new Line32();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end: end2 } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1) target1.copy(point1);
        if (target2) target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1) target1.copy(point1);
      if (target2) target2.copy(start);
    }
    this.closestPointToPoint(end2, point1);
    distSq = end2.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1) target1.copy(point1);
      if (target2) target2.copy(end2);
    }
    return Math.sqrt(closestDistanceSq);
  };
})();
ExtendedTriangle.prototype.intersectsTriangle = (function() {
  const saTri2 = new ExtendedTriangle();
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const tmpVec = new Vector315();
  const dir1 = new Vector315();
  const dir2 = new Vector315();
  const tempDir = new Vector315();
  const edge1 = new Line32();
  const edge2 = new Line32();
  const tempPoint = new Vector315();
  const bounds1 = new Vector26();
  const bounds2 = new Vector26();
  function coplanarIntersectsTriangle(self2, other, target, suppressLog) {
    const planeNormal = tmpVec;
    if (!self2.isDegenerateIntoPoint && !self2.isDegenerateIntoSegment) {
      planeNormal.copy(self2.plane.normal);
    } else {
      planeNormal.copy(other.plane.normal);
    }
    const satBounds1 = self2.satBounds;
    const satAxes1 = self2.satAxes;
    for (let i = 1; i < 4; i++) {
      const sb = satBounds1[i];
      const sa = satAxes1[i];
      cachedSatBounds.setFromPoints(sa, other.points);
      if (sb.isSeparated(cachedSatBounds)) return false;
      tempDir.copy(planeNormal).cross(sa);
      cachedSatBounds.setFromPoints(tempDir, self2.points);
      cachedSatBounds2.setFromPoints(tempDir, other.points);
      if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
    }
    const satBounds2 = other.satBounds;
    const satAxes2 = other.satAxes;
    for (let i = 1; i < 4; i++) {
      const sb = satBounds2[i];
      const sa = satAxes2[i];
      cachedSatBounds.setFromPoints(sa, self2.points);
      if (sb.isSeparated(cachedSatBounds)) return false;
      tempDir.crossVectors(planeNormal, sa);
      cachedSatBounds.setFromPoints(tempDir, self2.points);
      cachedSatBounds2.setFromPoints(tempDir, other.points);
      if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
    }
    if (target) {
      if (!suppressLog) {
        console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
      }
      target.start.set(0, 0, 0);
      target.end.set(0, 0, 0);
    }
    return true;
  }
  function findSingleBounds(a, b2, c, aProj, bProj, cProj, aDist, bDist, cDist, bounds, edge) {
    let t = aDist / (aDist - bDist);
    bounds.x = aProj + (bProj - aProj) * t;
    edge.start.subVectors(b2, a).multiplyScalar(t).add(a);
    t = aDist / (aDist - cDist);
    bounds.y = aProj + (cProj - aProj) * t;
    edge.end.subVectors(c, a).multiplyScalar(t).add(a);
  }
  function findIntersectionLineBounds(self2, aProj, bProj, cProj, abDist, acDist, aDist, bDist, cDist, bounds, edge) {
    if (abDist > 0) {
      findSingleBounds(self2.c, self2.a, self2.b, cProj, aProj, bProj, cDist, aDist, bDist, bounds, edge);
    } else if (acDist > 0) {
      findSingleBounds(self2.b, self2.a, self2.c, bProj, aProj, cProj, bDist, aDist, cDist, bounds, edge);
    } else if (bDist * cDist > 0 || aDist != 0) {
      findSingleBounds(self2.a, self2.b, self2.c, aProj, bProj, cProj, aDist, bDist, cDist, bounds, edge);
    } else if (bDist != 0) {
      findSingleBounds(self2.b, self2.a, self2.c, bProj, aProj, cProj, bDist, aDist, cDist, bounds, edge);
    } else if (cDist != 0) {
      findSingleBounds(self2.c, self2.a, self2.b, cProj, aProj, bProj, cDist, aDist, bDist, bounds, edge);
    } else {
      return true;
    }
    return false;
  }
  function intersectTriangleSegment(triangle4, degenerateTriangle, target, suppressLog) {
    const segment = degenerateTriangle.degenerateSegment;
    const startDist = triangle4.plane.distanceToPoint(segment.start);
    const endDist = triangle4.plane.distanceToPoint(segment.end);
    if (isNearZero(startDist)) {
      if (isNearZero(endDist)) {
        return coplanarIntersectsTriangle(triangle4, degenerateTriangle, target, suppressLog);
      } else {
        if (target) {
          target.start.copy(segment.start);
          target.end.copy(segment.start);
        }
        return triangle4.containsPoint(segment.start);
      }
    } else if (isNearZero(endDist)) {
      if (target) {
        target.start.copy(segment.end);
        target.end.copy(segment.end);
      }
      return triangle4.containsPoint(segment.end);
    } else {
      if (triangle4.plane.intersectLine(segment, tmpVec) != null) {
        if (target) {
          target.start.copy(tmpVec);
          target.end.copy(tmpVec);
        }
        return triangle4.containsPoint(tmpVec);
      } else {
        return false;
      }
    }
  }
  function intersectTrianglePoint(triangle4, degenerateTriangle, target) {
    const point = degenerateTriangle.a;
    if (isNearZero(triangle4.plane.distanceToPoint(point)) && triangle4.containsPoint(point)) {
      if (target) {
        target.start.copy(point);
        target.end.copy(point);
      }
      return true;
    } else {
      return false;
    }
  }
  function intersectSegmentPoint(segmentTri, pointTri, target) {
    const segment = segmentTri.degenerateSegment;
    const point = pointTri.a;
    segment.closestPointToPoint(point, true, tmpVec);
    if (point.distanceToSquared(tmpVec) < ZERO_EPSILON_SQR) {
      if (target) {
        target.start.copy(point);
        target.end.copy(point);
      }
      return true;
    } else {
      return false;
    }
  }
  function handleDegenerateCases(self2, other, target, suppressLog) {
    if (self2.isDegenerateIntoSegment) {
      if (other.isDegenerateIntoSegment) {
        const segment1 = self2.degenerateSegment;
        const segment2 = other.degenerateSegment;
        const delta1 = dir1;
        const delta2 = dir2;
        segment1.delta(delta1);
        segment2.delta(delta2);
        const startDelta = tmpVec.subVectors(segment2.start, segment1.start);
        const denom = delta1.x * delta2.y - delta1.y * delta2.x;
        if (isNearZero(denom)) {
          return false;
        }
        const t = (startDelta.x * delta2.y - startDelta.y * delta2.x) / denom;
        const u = -(delta1.x * startDelta.y - delta1.y * startDelta.x) / denom;
        if (t < 0 || t > 1 || u < 0 || u > 1) {
          return false;
        }
        const z1 = segment1.start.z + delta1.z * t;
        const z2 = segment2.start.z + delta2.z * u;
        if (isNearZero(z1 - z2)) {
          if (target) {
            target.start.copy(segment1.start).addScaledVector(delta1, t);
            target.end.copy(segment1.start).addScaledVector(delta1, t);
          }
          return true;
        } else {
          return false;
        }
      } else if (other.isDegenerateIntoPoint) {
        return intersectSegmentPoint(self2, other, target);
      } else {
        return intersectTriangleSegment(other, self2, target, suppressLog);
      }
    } else if (self2.isDegenerateIntoPoint) {
      if (other.isDegenerateIntoPoint) {
        if (other.a.distanceToSquared(self2.a) < ZERO_EPSILON_SQR) {
          if (target) {
            target.start.copy(self2.a);
            target.end.copy(self2.a);
          }
          return true;
        } else {
          return false;
        }
      } else if (other.isDegenerateIntoSegment) {
        return intersectSegmentPoint(other, self2, target);
      } else {
        return intersectTrianglePoint(other, self2, target);
      }
    } else {
      if (other.isDegenerateIntoPoint) {
        return intersectTrianglePoint(self2, other, target);
      } else if (other.isDegenerateIntoSegment) {
        return intersectTriangleSegment(self2, other, target, suppressLog);
      }
    }
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const res = handleDegenerateCases(this, other, target, suppressLog);
    if (res !== void 0) {
      return res;
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    let a1Dist = plane2.distanceToPoint(this.a);
    let b1Dist = plane2.distanceToPoint(this.b);
    let c1Dist = plane2.distanceToPoint(this.c);
    if (isNearZero(a1Dist))
      a1Dist = 0;
    if (isNearZero(b1Dist))
      b1Dist = 0;
    if (isNearZero(c1Dist))
      c1Dist = 0;
    const a1b1Dist = a1Dist * b1Dist;
    const a1c1Dist = a1Dist * c1Dist;
    if (a1b1Dist > 0 && a1c1Dist > 0) {
      return false;
    }
    let a2Dist = plane1.distanceToPoint(other.a);
    let b2Dist = plane1.distanceToPoint(other.b);
    let c2Dist = plane1.distanceToPoint(other.c);
    if (isNearZero(a2Dist))
      a2Dist = 0;
    if (isNearZero(b2Dist))
      b2Dist = 0;
    if (isNearZero(c2Dist))
      c2Dist = 0;
    const a2b2Dist = a2Dist * b2Dist;
    const a2c2Dist = a2Dist * c2Dist;
    if (a2b2Dist > 0 && a2c2Dist > 0) {
      return false;
    }
    dir1.copy(plane1.normal);
    dir2.copy(plane2.normal);
    const intersectionLine = dir1.cross(dir2);
    let componentIndex = 0;
    let maxComponent = Math.abs(intersectionLine.x);
    const comp1 = Math.abs(intersectionLine.y);
    if (comp1 > maxComponent) {
      maxComponent = comp1;
      componentIndex = 1;
    }
    const comp2 = Math.abs(intersectionLine.z);
    if (comp2 > maxComponent) {
      componentIndex = 2;
    }
    const key2 = componentKeys[componentIndex];
    const a1Proj = this.a[key2];
    const b1Proj = this.b[key2];
    const c1Proj = this.c[key2];
    const a2Proj = other.a[key2];
    const b2Proj = other.b[key2];
    const c2Proj = other.c[key2];
    if (findIntersectionLineBounds(this, a1Proj, b1Proj, c1Proj, a1b1Dist, a1c1Dist, a1Dist, b1Dist, c1Dist, bounds1, edge1)) {
      return coplanarIntersectsTriangle(this, other, target, suppressLog);
    }
    if (findIntersectionLineBounds(other, a2Proj, b2Proj, c2Proj, a2b2Dist, a2c2Dist, a2Dist, b2Dist, c2Dist, bounds2, edge2)) {
      return coplanarIntersectsTriangle(this, other, target, suppressLog);
    }
    if (bounds1.y < bounds1.x) {
      const tmp = bounds1.y;
      bounds1.y = bounds1.x;
      bounds1.x = tmp;
      tempPoint.copy(edge1.start);
      edge1.start.copy(edge1.end);
      edge1.end.copy(tempPoint);
    }
    if (bounds2.y < bounds2.x) {
      const tmp = bounds2.y;
      bounds2.y = bounds2.x;
      bounds2.x = tmp;
      tempPoint.copy(edge2.start);
      edge2.start.copy(edge2.end);
      edge2.end.copy(tempPoint);
    }
    if (bounds1.y < bounds2.x || bounds2.y < bounds1.x) {
      return false;
    }
    if (target) {
      if (bounds2.x > bounds1.x) {
        target.start.copy(edge2.start);
      } else {
        target.start.copy(edge1.start);
      }
      if (bounds2.y < bounds1.y) {
        target.end.copy(edge2.end);
      } else {
        target.end.copy(edge1.end);
      }
    }
    return true;
  };
})();
ExtendedTriangle.prototype.distanceToPoint = (function() {
  const target = new Vector315();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
})();
ExtendedTriangle.prototype.distanceToTriangle = (function() {
  const point = new Vector315();
  const point2 = new Vector315();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line32();
  const line2 = new Line32();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1) lineTarget.getCenter(target1);
        if (target2) lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(point);
        if (target2) target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(thisVec);
        if (target2) target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1) target1.copy(point);
          if (target2) target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
})();

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
var OrientedBox = class {
  constructor(min, max, matrix2) {
    this.isOrientedBox = true;
    this.min = new Vector316();
    this.max = new Vector316();
    this.matrix = new Matrix48();
    this.invMatrix = new Matrix48();
    this.points = new Array(8).fill().map(() => new Vector316());
    this.satAxes = new Array(3).fill().map(() => new Vector316());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min) this.min.copy(min);
    if (max) this.max.copy(max);
    if (matrix2) this.matrix.copy(matrix2);
  }
  set(min, max, matrix2) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix2);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = /* @__PURE__ */ (function() {
  return function update() {
    const matrix2 = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y2 = 0; y2 <= 1; y2++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          const i = (1 << 0) * x | (1 << 1) * y2 | (1 << 2) * z2;
          const v4 = points[i];
          v4.x = x ? max.x : min.x;
          v4.y = y2 ? max.y : min.y;
          v4.z = z2 ? max.z : min.z;
          v4.applyMatrix4(matrix2);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
})();
OrientedBox.prototype.intersectsBox = (function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds)) return false;
    }
    return true;
  };
})();
OrientedBox.prototype.intersectsTriangle = (function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector316();
  return function intersectsTriangle(triangle4) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle4.isExtendedTriangle) {
      saTri.copy(triangle4);
      saTri.update();
      triangle4 = saTri;
    } else if (triangle4.needsUpdate) {
      triangle4.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle4.a;
    pointsArr[1] = triangle4.b;
    pointsArr[2] = triangle4.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds)) return false;
    }
    const triSatBounds = triangle4.satBounds;
    const triSatAxes = triangle4.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds)) return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
      }
    }
    return true;
  };
})();
OrientedBox.prototype.closestPointToPoint = /* @__PURE__ */ (function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
})();
OrientedBox.prototype.distanceToPoint = (function() {
  const target = new Vector316();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
})();
OrientedBox.prototype.distanceToBox = (function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line33());
  const segments2 = new Array(12).fill().map(() => new Line33());
  const point1 = new Vector316();
  const point2 = new Vector316();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1) target1.copy(point1);
        if (target2) target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(p);
        if (target2) target2.copy(point2);
        if (dist < threshold2) return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end2 = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end2[f1] = max[f1];
          end2[f2] = i1 ? min[f2] : max[f2];
          end2[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y2 = 0; y2 <= 1; y2++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          point2.x = x ? max.x : min.x;
          point2.y = y2 ? max.y : min.y;
          point2.z = z2 ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1) target1.copy(point1);
            if (target2) target2.copy(point2);
            if (dist < threshold2) return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1) target1.copy(point1);
          if (target2) target2.copy(point2);
          if (dist < threshold2) return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
})();

// node_modules/three-mesh-bvh/src/utils/PrimitivePool.js
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};

// node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();

// node_modules/three-mesh-bvh/src/core/cast/shapecast.js
import { Box3 as Box33 } from "three";

// node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js
function IS_LEAF(n16, uint16Array2) {
  return uint16Array2[n16 + 15] === IS_LEAFNODE_FLAG;
}
function OFFSET(n32, uint32Array2) {
  return uint32Array2[n32 + 6];
}
function COUNT(n16, uint16Array2) {
  return uint16Array2[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + UINT32_PER_NODE;
}
function RIGHT_NODE(n32, uint32Array2) {
  const relativeOffset = uint32Array2[n32 + 6];
  return n32 + relativeOffset * UINT32_PER_NODE;
}
function SPLIT_AXIS(n32, uint32Array2) {
  return uint32Array2[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}

// node_modules/three-mesh-bvh/src/core/utils/BufferStack.js
var _BufferStack = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack = new _BufferStack();

// node_modules/three-mesh-bvh/src/core/cast/shapecast.js
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box33());
function shapecast(bvh2, root6, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh2._roots[root6]);
  const result = shapecastTraverse(0, bvh2.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexOffset = 0, depth = 0) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexOffset + nodeIndex32 / UINT32_PER_NODE, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array3, uint32Array: uint32Array3 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array3)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array3);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array3, uint32Array: uint32Array3 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array3)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array3);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array3) + COUNT(nodeIndex162, uint16Array3);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array2);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array2, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array2, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array2, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array2);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end2 = getRightEndOffset(c1);
      const count = end2 - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexOffset,
        depth + 1
      );
    }
    if (c1StopTraversal) return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array2, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array2);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end2 = getRightEndOffset(c2);
      const count = end2 - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexOffset,
        depth + 1
      );
    }
    if (c2StopTraversal) return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js
import { Vector3 as Vector317 } from "three";
var temp = new Vector317();
var temp1 = new Vector317();
function closestPointToPoint(bvh2, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh2.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity) return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point) target.point = temp1.clone();
  else target.point.copy(temp1);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}

// node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js
import { Vector3 as Vector318, Vector2 as Vector27, Triangle as Triangle2, DoubleSide as DoubleSide6, BackSide, REVISION } from "three";
var IS_GT_REVISION_169 = parseInt(REVISION) >= 169;
var IS_LT_REVISION_161 = parseInt(REVISION) <= 161;
var _vA = new Vector318();
var _vB = new Vector318();
var _vC = new Vector318();
var _uvA = new Vector27();
var _uvB = new Vector27();
var _uvC = new Vector27();
var _normalA = new Vector318();
var _normalB = new Vector318();
var _normalC = new Vector318();
var _intersectionPoint = new Vector318();
function checkIntersection(ray3, pA, pB, pC, point, side, near, far) {
  let intersect;
  if (side === BackSide) {
    intersect = ray3.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray3.intersectTriangle(pA, pB, pC, side !== DoubleSide6, point);
  }
  if (intersect === null) return null;
  const distance = ray3.origin.distanceTo(point);
  if (distance < near || distance > far) return null;
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray3, position2, normal, uv, uv1, a, b2, c, side, near, far) {
  _vA.fromBufferAttribute(position2, a);
  _vB.fromBufferAttribute(position2, b2);
  _vC.fromBufferAttribute(position2, c);
  const intersection = checkIntersection(ray3, _vA, _vB, _vC, _intersectionPoint, side, near, far);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b2);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = new Vector27();
      const res = Triangle2.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv);
      if (!IS_GT_REVISION_169) {
        intersection.uv = res;
      }
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b2);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = new Vector27();
      const res = Triangle2.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv1);
      if (!IS_GT_REVISION_169) {
        intersection.uv1 = res;
      }
      if (IS_LT_REVISION_161) {
        intersection.uv2 = intersection.uv1;
      }
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b2);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = new Vector318();
      const res = Triangle2.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, intersection.normal);
      if (intersection.normal.dot(ray3.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
      if (!IS_GT_REVISION_169) {
        intersection.normal = res;
      }
    }
    const face = {
      a,
      b: b2,
      c,
      normal: new Vector318(),
      materialIndex: 0
    };
    Triangle2.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
    if (IS_GT_REVISION_169) {
      const barycoord = new Vector318();
      Triangle2.getBarycoord(_intersectionPoint, _vA, _vB, _vC, barycoord);
      intersection.barycoord = barycoord;
    }
  }
  return intersection;
}
function getSide(materialOrSide) {
  return materialOrSide && materialOrSide.isMaterial ? materialOrSide.side : materialOrSide;
}
function intersectTri(geometry, materialOrSide, ray3, tri, intersections, near, far) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b2 = triOffset + 1;
  let c = triOffset + 2;
  const { index, groups } = geometry;
  if (geometry.index) {
    a = index.getX(a);
    b2 = index.getX(b2);
    c = index.getX(c);
  }
  const { position: position2, normal, uv, uv1 } = geometry.attributes;
  if (Array.isArray(materialOrSide)) {
    const firstIndex = tri * 3;
    for (let i = 0, l = groups.length; i < l; i++) {
      const { start, count, materialIndex } = groups[i];
      if (firstIndex >= start && firstIndex < start + count) {
        const side = getSide(materialOrSide[materialIndex]);
        const intersection = checkBufferGeometryIntersection(ray3, position2, normal, uv, uv1, a, b2, c, side, near, far);
        if (intersection) {
          intersection.faceIndex = tri;
          intersection.face.materialIndex = materialIndex;
          if (intersections) {
            intersections.push(intersection);
          } else {
            return intersection;
          }
        }
      }
    }
  } else {
    const side = getSide(materialOrSide);
    const intersection = checkBufferGeometryIntersection(ray3, position2, normal, uv, uv1, a, b2, c, side, near, far);
    if (intersection) {
      intersection.faceIndex = tri;
      intersection.face.materialIndex = 0;
      if (intersections) {
        intersections.push(intersection);
      } else {
        return intersection;
      }
    }
  }
  return null;
}

// node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js
import { Vector2 as Vector28, Vector3 as Vector319, Triangle as Triangle3 } from "three";
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
var tempV1 = new Vector319();
var tempV2 = new Vector319();
var tempV3 = new Vector319();
var tempUV1 = new Vector28();
var tempUV2 = new Vector28();
var tempUV3 = new Vector28();

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js
function intersectTris(bvh2, materialOrSide, ray3, offset, count, intersections, near, far) {
  const { geometry, _indirectBuffer } = bvh2;
  for (let i = offset, end2 = offset + count; i < end2; i++) {
    intersectTri(geometry, materialOrSide, ray3, i, intersections, near, far);
  }
}
function intersectClosestTri(bvh2, materialOrSide, ray3, offset, count, near, far) {
  const { geometry, _indirectBuffer } = bvh2;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end2 = offset + count; i < end2; i++) {
    let intersection;
    intersection = intersectTri(geometry, materialOrSide, ray3, i, null, near, far);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh2, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh2;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/refit.generated.js
function refit(bvh2, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh2.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array2, uint16Array2, float32Array2;
  let byteOffset = 0;
  const roots = bvh2._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array2 = new Uint32Array(buffer);
    uint16Array2 = new Uint16Array(buffer);
    float32Array2 = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(nodeIndex32, byteOffset2, force = false) {
    const nodeIndex16 = nodeIndex32 * 2;
    if (IS_LEAF(nodeIndex16, uint16Array2)) {
      const offset = uint32Array2[nodeIndex32 + 6];
      const count = uint16Array2[nodeIndex16 + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y2 = posAttr.getY(index);
        const z2 = posAttr.getZ(index);
        if (x < minx) minx = x;
        if (x > maxx) maxx = x;
        if (y2 < miny) miny = y2;
        if (y2 > maxy) maxy = y2;
        if (z2 < minz) minz = z2;
        if (z2 > maxz) maxz = z2;
      }
      if (float32Array2[nodeIndex32 + 0] !== minx || float32Array2[nodeIndex32 + 1] !== miny || float32Array2[nodeIndex32 + 2] !== minz || float32Array2[nodeIndex32 + 3] !== maxx || float32Array2[nodeIndex32 + 4] !== maxy || float32Array2[nodeIndex32 + 5] !== maxz) {
        float32Array2[nodeIndex32 + 0] = minx;
        float32Array2[nodeIndex32 + 1] = miny;
        float32Array2[nodeIndex32 + 2] = minz;
        float32Array2[nodeIndex32 + 3] = maxx;
        float32Array2[nodeIndex32 + 4] = maxy;
        float32Array2[nodeIndex32 + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = LEFT_NODE(nodeIndex32);
      const right = RIGHT_NODE(nodeIndex32, uint32Array2);
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          const leftNodeId = left / UINT32_PER_NODE + byteOffset2 / BYTES_PER_NODE;
          const rightNodeId = right / UINT32_PER_NODE + byteOffset2 / BYTES_PER_NODE;
          includesLeft = nodeIndices.has(leftNodeId);
          includesRight = nodeIndices.has(rightNodeId);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const left_i = left + i;
          const right_i = right + i;
          const minLeftValue = float32Array2[left_i];
          const maxLeftValue = float32Array2[left_i + 3];
          const minRightValue = float32Array2[right_i];
          const maxRightValue = float32Array2[right_i + 3];
          float32Array2[nodeIndex32 + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array2[nodeIndex32 + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js
function intersectRay(nodeIndex32, array, ray3, near, far) {
  let tmin, tmax, tymin, tymax, tzmin, tzmax;
  const invdirx = 1 / ray3.direction.x, invdiry = 1 / ray3.direction.y, invdirz = 1 / ray3.direction.z;
  const ox = ray3.origin.x;
  const oy = ray3.origin.y;
  const oz = ray3.origin.z;
  let minx = array[nodeIndex32];
  let maxx = array[nodeIndex32 + 3];
  let miny = array[nodeIndex32 + 1];
  let maxy = array[nodeIndex32 + 3 + 1];
  let minz = array[nodeIndex32 + 2];
  let maxz = array[nodeIndex32 + 3 + 2];
  if (invdirx >= 0) {
    tmin = (minx - ox) * invdirx;
    tmax = (maxx - ox) * invdirx;
  } else {
    tmin = (maxx - ox) * invdirx;
    tmax = (minx - ox) * invdirx;
  }
  if (invdiry >= 0) {
    tymin = (miny - oy) * invdiry;
    tymax = (maxy - oy) * invdiry;
  } else {
    tymin = (maxy - oy) * invdiry;
    tymax = (miny - oy) * invdiry;
  }
  if (tmin > tymax || tymin > tmax) return false;
  if (tymin > tmin || isNaN(tmin)) tmin = tymin;
  if (tymax < tmax || isNaN(tmax)) tmax = tymax;
  if (invdirz >= 0) {
    tzmin = (minz - oz) * invdirz;
    tzmax = (maxz - oz) * invdirz;
  } else {
    tzmin = (maxz - oz) * invdirz;
    tzmax = (minz - oz) * invdirz;
  }
  if (tmin > tzmax || tzmin > tmax) return false;
  if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
  if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
  return tmin <= far && tmax >= near;
}

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js
function intersectTris_indirect(bvh2, materialOrSide, ray3, offset, count, intersections, near, far) {
  const { geometry, _indirectBuffer } = bvh2;
  for (let i = offset, end2 = offset + count; i < end2; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, materialOrSide, ray3, vi, intersections, near, far);
  }
}
function intersectClosestTri_indirect(bvh2, materialOrSide, ray3, offset, count, near, far) {
  const { geometry, _indirectBuffer } = bvh2;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end2 = offset + count; i < end2; i++) {
    let intersection;
    intersection = intersectTri(geometry, materialOrSide, ray3, _indirectBuffer ? _indirectBuffer[i] : i, null, near, far);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh2, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh2;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh2.resolveTriangleIndex(i);
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js
function raycast(bvh2, root6, materialOrSide, ray3, intersects, near, far) {
  BufferStack.setBuffer(bvh2._roots[root6]);
  _raycast(0, bvh2, materialOrSide, ray3, intersects, near, far);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh2, materialOrSide, ray3, intersects, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    intersectTris(bvh2, materialOrSide, ray3, offset, count, intersects, near, far);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array2, ray3, near, far)) {
      _raycast(leftIndex, bvh2, materialOrSide, ray3, intersects, near, far);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array2);
    if (intersectRay(rightIndex, float32Array2, ray3, near, far)) {
      _raycast(rightIndex, bvh2, materialOrSide, ray3, intersects, near, far);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js
var _xyzFields = ["x", "y", "z"];
function raycastFirst(bvh2, root6, materialOrSide, ray3, near, far) {
  BufferStack.setBuffer(bvh2._roots[root6]);
  const result = _raycastFirst(0, bvh2, materialOrSide, ray3, near, far);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh2, materialOrSide, ray3, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    return intersectClosestTri(bvh2, materialOrSide, ray3, offset, count, near, far);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray3.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array2);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array2);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array2, ray3, near, far);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh2, materialOrSide, ray3, near, far) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array2[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array2[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array2, ray3, near, far);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh2, materialOrSide, ray3, near, far) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js
import { Box3 as Box34, Matrix4 as Matrix49 } from "three";
var boundingBox = new Box34();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix49();
var obb = new OrientedBox();
var obb2 = new OrientedBox();
function intersectsGeometry(bvh2, root6, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh2._roots[root6]);
  const result = _intersectsGeometry(0, bvh2, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh2, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const thisGeometry = bvh2.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const otherIndex = otherGeometry.index;
    const otherPos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, obb2);
      obb2.matrix.copy(invertedMat);
      obb2.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle(triangle2, i, thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      const otherTriangleCount = getTriCount(otherGeometry);
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle(triangle, i, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3) {
          setTriangle(triangle2, i2, otherIndex, otherPos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array2, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh2, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection) return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array2, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh2, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection) return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js
import { Matrix4 as Matrix410, Vector3 as Vector320 } from "three";
var tempMatrix = new Matrix410();
var obb3 = new OrientedBox();
var obb22 = new OrientedBox();
var temp12 = new Vector320();
var temp2 = new Vector320();
var temp3 = new Vector320();
var temp4 = new Vector320();
function closestPointToGeometry(bvh2, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb3.needsUpdate = true;
  const geometry = bvh2.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp12;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb22.matrix.copy(tempMatrix);
  bvh2.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb22.min.copy(box.min);
            obb22.max.copy(box.max);
            obb22.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb22.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle(triangle4, 3 * i, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle(triangle4, 3 * i, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point) target2.point = tempTargetDest2.clone();
    else target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js
function refit_indirect(bvh2, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh2.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array2, uint16Array2, float32Array2;
  let byteOffset = 0;
  const roots = bvh2._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array2 = new Uint32Array(buffer);
    uint16Array2 = new Uint16Array(buffer);
    float32Array2 = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(nodeIndex32, byteOffset2, force = false) {
    const nodeIndex16 = nodeIndex32 * 2;
    if (IS_LEAF(nodeIndex16, uint16Array2)) {
      const offset = uint32Array2[nodeIndex32 + 6];
      const count = uint16Array2[nodeIndex16 + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t = 3 * bvh2.resolveTriangleIndex(i);
        for (let j3 = 0; j3 < 3; j3++) {
          let index = t + j3;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y2 = posAttr.getY(index);
          const z2 = posAttr.getZ(index);
          if (x < minx) minx = x;
          if (x > maxx) maxx = x;
          if (y2 < miny) miny = y2;
          if (y2 > maxy) maxy = y2;
          if (z2 < minz) minz = z2;
          if (z2 > maxz) maxz = z2;
        }
      }
      if (float32Array2[nodeIndex32 + 0] !== minx || float32Array2[nodeIndex32 + 1] !== miny || float32Array2[nodeIndex32 + 2] !== minz || float32Array2[nodeIndex32 + 3] !== maxx || float32Array2[nodeIndex32 + 4] !== maxy || float32Array2[nodeIndex32 + 5] !== maxz) {
        float32Array2[nodeIndex32 + 0] = minx;
        float32Array2[nodeIndex32 + 1] = miny;
        float32Array2[nodeIndex32 + 2] = minz;
        float32Array2[nodeIndex32 + 3] = maxx;
        float32Array2[nodeIndex32 + 4] = maxy;
        float32Array2[nodeIndex32 + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = LEFT_NODE(nodeIndex32);
      const right = RIGHT_NODE(nodeIndex32, uint32Array2);
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          const leftNodeId = left / UINT32_PER_NODE + byteOffset2 / BYTES_PER_NODE;
          const rightNodeId = right / UINT32_PER_NODE + byteOffset2 / BYTES_PER_NODE;
          includesLeft = nodeIndices.has(leftNodeId);
          includesRight = nodeIndices.has(rightNodeId);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const left_i = left + i;
          const right_i = right + i;
          const minLeftValue = float32Array2[left_i];
          const maxLeftValue = float32Array2[left_i + 3];
          const minRightValue = float32Array2[right_i];
          const maxRightValue = float32Array2[right_i + 3];
          float32Array2[nodeIndex32 + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array2[nodeIndex32 + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js
function raycast_indirect(bvh2, root6, materialOrSide, ray3, intersects, near, far) {
  BufferStack.setBuffer(bvh2._roots[root6]);
  _raycast2(0, bvh2, materialOrSide, ray3, intersects, near, far);
  BufferStack.clearBuffer();
}
function _raycast2(nodeIndex32, bvh2, materialOrSide, ray3, intersects, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    intersectTris_indirect(bvh2, materialOrSide, ray3, offset, count, intersects, near, far);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array2, ray3, near, far)) {
      _raycast2(leftIndex, bvh2, materialOrSide, ray3, intersects, near, far);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array2);
    if (intersectRay(rightIndex, float32Array2, ray3, near, far)) {
      _raycast2(rightIndex, bvh2, materialOrSide, ray3, intersects, near, far);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js
var _xyzFields2 = ["x", "y", "z"];
function raycastFirst_indirect(bvh2, root6, materialOrSide, ray3, near, far) {
  BufferStack.setBuffer(bvh2._roots[root6]);
  const result = _raycastFirst2(0, bvh2, materialOrSide, ray3, near, far);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst2(nodeIndex32, bvh2, materialOrSide, ray3, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    return intersectClosestTri_indirect(bvh2, materialOrSide, ray3, offset, count, near, far);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
    const xyzAxis = _xyzFields2[splitAxis];
    const rayDir = ray3.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array2);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array2);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array2, ray3, near, far);
    const c1Result = c1Intersection ? _raycastFirst2(c1, bvh2, materialOrSide, ray3, near, far) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array2[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array2[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array2, ray3, near, far);
    const c2Result = c2Intersection ? _raycastFirst2(c2, bvh2, materialOrSide, ray3, near, far) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js
import { Box3 as Box35, Matrix4 as Matrix411 } from "three";
var boundingBox2 = new Box35();
var triangle3 = new ExtendedTriangle();
var triangle22 = new ExtendedTriangle();
var invertedMat2 = new Matrix411();
var obb4 = new OrientedBox();
var obb23 = new OrientedBox();
function intersectsGeometry_indirect(bvh2, root6, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh2._roots[root6]);
  const result = _intersectsGeometry2(0, bvh2, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry2(nodeIndex32, bvh2, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const thisGeometry = bvh2.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const otherIndex = otherGeometry.index;
    const otherPos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    invertedMat2.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, obb23);
      obb23.matrix.copy(invertedMat2);
      obb23.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb23.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle(triangle22, 3 * bvh2.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle22.needsUpdate = true;
            if (tri.intersectsTriangle(triangle22)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      const otherTriangleCount = getTriCount(otherGeometry);
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti = bvh2.resolveTriangleIndex(i);
        setTriangle(triangle3, 3 * ti, thisIndex, thisPos);
        triangle3.a.applyMatrix4(invertedMat2);
        triangle3.b.applyMatrix4(invertedMat2);
        triangle3.c.applyMatrix4(invertedMat2);
        triangle3.needsUpdate = true;
        for (let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3) {
          setTriangle(triangle22, i2, otherIndex, otherPos);
          triangle22.needsUpdate = true;
          if (triangle3.intersectsTriangle(triangle22)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array2, boundingBox2);
    const leftIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(left, bvh2, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection) return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array2, boundingBox2);
    const rightIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(right, bvh2, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection) return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js
import { Matrix4 as Matrix412, Vector3 as Vector321 } from "three";
var tempMatrix2 = new Matrix412();
var obb5 = new OrientedBox();
var obb24 = new OrientedBox();
var temp13 = new Vector321();
var temp22 = new Vector321();
var temp32 = new Vector321();
var temp42 = new Vector321();
function closestPointToGeometry_indirect(bvh2, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb5.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb5.needsUpdate = true;
  const geometry = bvh2.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp13;
  let tempTargetDest1 = temp22;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp32;
    tempTargetDest2 = temp42;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix2.copy(geometryToBvh).invert();
  obb24.matrix.copy(tempMatrix2);
  bvh2.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb5.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb24.min.copy(box.min);
            obb24.max.copy(box.max);
            obb24.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb24.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle23, 3 * ti2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti = bvh2.resolveTriangleIndex(i);
                  setTriangle(triangle4, 3 * ti, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti = bvh2.resolveTriangleIndex(i);
              setTriangle(triangle4, 3 * ti, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point) target2.point = tempTargetDest2.clone();
    else target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix2);
    tempTargetDest1.applyMatrix4(tempMatrix2);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/utils/BufferUtils.js
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}

// node_modules/three-mesh-bvh/src/core/cast/bvhcast.js
import { Box3 as Box36, Matrix4 as Matrix413 } from "three";
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box36());
var _leftBox1 = new Box36();
var _rightBox1 = new Box36();
var _leftBox2 = new Box36();
var _rightBox2 = new Box36();
var _active = false;
function bvhcast(bvh2, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh2._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let nodeOffset1 = 0;
  let nodeOffset2 = 0;
  const invMat = new Matrix413().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    nodeOffset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j3 = 0, jl = otherRoots.length; j3 < jl; j3++) {
      _bufferStack2.setBuffer(otherRoots[j3]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        nodeOffset1,
        nodeOffset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      nodeOffset2 += otherRoots[j3].byteLength / BYTES_PER_NODE;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    nodeOffset1 += roots[i].byteLength / BYTES_PER_NODE;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexOffset = 0, node2IndexOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexOffset + node2Index32 / UINT32_PER_NODE,
        depth1,
        node1IndexOffset + node1Index32 / UINT32_PER_NODE
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexOffset + node1Index32 / UINT32_PER_NODE,
        depth2,
        node2IndexOffset + node2Index32 / UINT32_PER_NODE
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexOffset,
      node1IndexOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexOffset,
      node1IndexOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexOffset,
        node2IndexOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexOffset,
        node2IndexOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexOffset,
          node2IndexOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexOffset,
          node1IndexOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexOffset,
          node1IndexOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexOffset,
          node2IndexOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexOffset,
          node1IndexOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexOffset,
          node1IndexOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
var obb6 = new OrientedBox();
var tempBox = new Box37();
var DEFAULT_OPTIONS = {
  strategy: CENTER,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: false,
  setBoundingBox: true,
  onProgress: null,
  indirect: false,
  verbose: true,
  range: null
};
var MeshBVH = class _MeshBVH {
  static serialize(bvh2, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh2.geometry;
    const rootData = bvh2._roots;
    const indirectBuffer = bvh2._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    const result = {
      version: 1,
      roots: null,
      index: null,
      indirectBuffer: null
    };
    if (options.cloneBuffers) {
      result.roots = rootData.map((root6) => root6.slice());
      result.index = indexAttribute ? indexAttribute.array.slice() : null;
      result.indirectBuffer = indirectBuffer ? indirectBuffer.slice() : null;
    } else {
      result.roots = rootData;
      result.index = indexAttribute ? indexAttribute.array : null;
      result.indirectBuffer = indirectBuffer;
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    if (!data.version) {
      console.warn(
        "MeshBVH.deserialize: Serialization format has been changed and will be fixed up. It is recommended to regenerate any stored serialized data."
      );
      fixupVersion0(roots);
    }
    const bvh2 = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh2._roots = roots;
    bvh2._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute4(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh2;
    function fixupVersion0(roots2) {
      for (let rootIndex = 0; rootIndex < roots2.length; rootIndex++) {
        const root6 = roots2[rootIndex];
        const uint32Array2 = new Uint32Array(root6);
        const uint16Array2 = new Uint16Array(root6);
        for (let node = 0, l = root6.byteLength / BYTES_PER_NODE; node < l; node++) {
          const node32Index = UINT32_PER_NODE * node;
          const node16Index = 2 * node32Index;
          if (!IS_LEAF(node16Index, uint16Array2)) {
            uint32Array2[node32Index + 6] = uint32Array2[node32Index + 6] / UINT32_PER_NODE - node;
          }
        }
      }
    }
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      ...DEFAULT_OPTIONS,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box37());
      }
    }
    this.resolveTriangleIndex = options.indirect ? (i) => this._indirectBuffer[i] : (i) => i;
  }
  shiftTriangleOffsets(offset) {
    const indirectBuffer = this._indirectBuffer;
    if (indirectBuffer) {
      for (let i = 0, l = indirectBuffer.length; i < l; i++) {
        indirectBuffer[i] += offset;
      }
    } else {
      const roots = this._roots;
      for (let rootIndex = 0; rootIndex < roots.length; rootIndex++) {
        const root6 = roots[rootIndex];
        const uint32Array2 = new Uint32Array(root6);
        const uint16Array2 = new Uint16Array(root6);
        const totalNodes = root6.byteLength / BYTES_PER_NODE;
        for (let node = 0; node < totalNodes; node++) {
          const node32Index = UINT32_PER_NODE * node;
          const node16Index = 2 * node32Index;
          if (IS_LEAF(node16Index, uint16Array2)) {
            uint32Array2[node32Index + 6] += offset;
          }
        }
      }
    }
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array2 = new Uint32Array(buffer);
    const uint16Array2 = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = IS_LEAF(node16Index, uint16Array2);
      if (isLeaf) {
        const offset = uint32Array2[node32Index + 6];
        const count = uint16Array2[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = LEFT_NODE(node32Index);
        const right = RIGHT_NODE(node32Index, uint32Array2);
        const splitAxis = SPLIT_AXIS(node32Index, uint32Array2);
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray3, materialOrSide = FrontSide2, near = 0, far = Infinity) {
    const roots = this._roots;
    const intersects = [];
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l = roots.length; i < l; i++) {
      raycastFunc(this, i, materialOrSide, ray3, intersects, near, far);
    }
    return intersects;
  }
  raycastFirst(ray3, materialOrSide = FrontSide2, near = 0, far = Infinity) {
    const roots = this._roots;
    let closestResult = null;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l = roots.length; i < l; i++) {
      const result = raycastFirstFunc(this, i, materialOrSide, ray3, near, far);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle4 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let nodeOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root6 = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset);
      if (result) {
        break;
      }
      nodeOffset += root6.byteLength / BYTES_PER_NODE;
    }
    ExtendedTrianglePool.releasePrimitive(triangle4);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle23 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle23, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle23, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle23.a.applyMatrix4(matrixToLocal);
          triangle23.b.applyMatrix4(matrixToLocal);
          triangle23.c.applyMatrix4(matrixToLocal);
          triangle23.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle23, i1, i2, depth1, nodeIndex1, depth2, nodeIndex2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb6.set(box.min, box.max, boxToMesh);
    obb6.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb6.intersectsBox(box2),
        intersectsTriangle: (tri) => obb6.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere3) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere3.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere3)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
};

// node_modules/three-mesh-bvh/src/objects/MeshBVHHelper.js
import { LineBasicMaterial, BufferAttribute as BufferAttribute5, Box3 as Box38, Group as Group8, MeshBasicMaterial as MeshBasicMaterial5, Object3D as Object3D4, BufferGeometry as BufferGeometry4, Mesh as Mesh6, Matrix4 as Matrix414 } from "three";
var boundingBox3 = new Box38();
var matrix = new Matrix414();
var MeshBVHRootHelper = class extends Object3D4 {
  get isMesh() {
    return !this.displayEdges;
  }
  get isLineSegments() {
    return this.displayEdges;
  }
  get isLine() {
    return this.displayEdges;
  }
  getVertexPosition(...args) {
    return Mesh6.prototype.getVertexPosition.call(this, ...args);
  }
  constructor(bvh2, material2, depth = 10, group = 0) {
    super();
    this.material = material2;
    this.geometry = new BufferGeometry4();
    this.name = "MeshBVHRootHelper";
    this.depth = depth;
    this.displayParents = false;
    this.bvh = bvh2;
    this.displayEdges = true;
    this._group = group;
  }
  raycast() {
  }
  update() {
    const geometry = this.geometry;
    const boundsTree = this.bvh;
    const group = this._group;
    geometry.dispose();
    this.visible = false;
    if (boundsTree) {
      const targetDepth = this.depth - 1;
      const displayParents = this.displayParents;
      let boundsCount = 0;
      boundsTree.traverse((depth, isLeaf) => {
        if (depth >= targetDepth || isLeaf) {
          boundsCount++;
          return true;
        } else if (displayParents) {
          boundsCount++;
        }
      }, group);
      let posIndex = 0;
      const positionArray = new Float32Array(8 * 3 * boundsCount);
      boundsTree.traverse((depth, isLeaf, boundingData) => {
        const terminate = depth >= targetDepth || isLeaf;
        if (terminate || displayParents) {
          arrayToBox(0, boundingData, boundingBox3);
          const { min, max } = boundingBox3;
          for (let x = -1; x <= 1; x += 2) {
            const xVal = x < 0 ? min.x : max.x;
            for (let y2 = -1; y2 <= 1; y2 += 2) {
              const yVal = y2 < 0 ? min.y : max.y;
              for (let z2 = -1; z2 <= 1; z2 += 2) {
                const zVal = z2 < 0 ? min.z : max.z;
                positionArray[posIndex + 0] = xVal;
                positionArray[posIndex + 1] = yVal;
                positionArray[posIndex + 2] = zVal;
                posIndex += 3;
              }
            }
          }
          return terminate;
        }
      }, group);
      let indexArray;
      let indices;
      if (this.displayEdges) {
        indices = new Uint8Array([
          // x axis
          0,
          4,
          1,
          5,
          2,
          6,
          3,
          7,
          // y axis
          0,
          2,
          1,
          3,
          4,
          6,
          5,
          7,
          // z axis
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ]);
      } else {
        indices = new Uint8Array([
          // X-, X+
          0,
          1,
          2,
          2,
          1,
          3,
          4,
          6,
          5,
          6,
          7,
          5,
          // Y-, Y+
          1,
          4,
          5,
          0,
          4,
          1,
          2,
          3,
          6,
          3,
          7,
          6,
          // Z-, Z+
          0,
          2,
          4,
          2,
          6,
          4,
          1,
          5,
          3,
          3,
          5,
          7
        ]);
      }
      if (positionArray.length > 65535) {
        indexArray = new Uint32Array(indices.length * boundsCount);
      } else {
        indexArray = new Uint16Array(indices.length * boundsCount);
      }
      const indexLength = indices.length;
      for (let i = 0; i < boundsCount; i++) {
        const posOffset = i * 8;
        const indexOffset = i * indexLength;
        for (let j3 = 0; j3 < indexLength; j3++) {
          indexArray[indexOffset + j3] = posOffset + indices[j3];
        }
      }
      geometry.setIndex(
        new BufferAttribute5(indexArray, 1, false)
      );
      geometry.setAttribute(
        "position",
        new BufferAttribute5(positionArray, 3, false)
      );
      this.visible = true;
    }
  }
};
var MeshBVHHelper = class _MeshBVHHelper extends Group8 {
  get color() {
    return this.edgeMaterial.color;
  }
  get opacity() {
    return this.edgeMaterial.opacity;
  }
  set opacity(v4) {
    this.edgeMaterial.opacity = v4;
    this.meshMaterial.opacity = v4;
  }
  constructor(mesh = null, bvh2 = null, depth = 10) {
    if (mesh instanceof MeshBVH) {
      depth = bvh2 || 10;
      bvh2 = mesh;
      mesh = null;
    }
    if (typeof bvh2 === "number") {
      depth = bvh2;
      bvh2 = null;
    }
    super();
    this.name = "MeshBVHHelper";
    this.depth = depth;
    this.mesh = mesh;
    this.bvh = bvh2;
    this.displayParents = false;
    this.displayEdges = true;
    this.objectIndex = 0;
    this._roots = [];
    const edgeMaterial = new LineBasicMaterial({
      color: 65416,
      transparent: true,
      opacity: 0.3,
      depthWrite: false
    });
    const meshMaterial = new MeshBasicMaterial5({
      color: 65416,
      transparent: true,
      opacity: 0.3,
      depthWrite: false
    });
    meshMaterial.color = edgeMaterial.color;
    this.edgeMaterial = edgeMaterial;
    this.meshMaterial = meshMaterial;
    this.update();
  }
  update() {
    const mesh = this.mesh;
    let bvh2 = this.bvh || mesh.geometry.boundsTree || null;
    if (mesh && mesh.isBatchedMesh && mesh.boundsTrees && !bvh2) {
      const drawInfo = mesh._drawInfo[this.objectIndex];
      if (drawInfo) {
        bvh2 = mesh.boundsTrees[drawInfo.geometryIndex] || bvh2;
      }
    }
    const totalRoots = bvh2 ? bvh2._roots.length : 0;
    while (this._roots.length > totalRoots) {
      const root6 = this._roots.pop();
      root6.geometry.dispose();
      this.remove(root6);
    }
    for (let i = 0; i < totalRoots; i++) {
      const { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;
      if (i >= this._roots.length) {
        const root7 = new MeshBVHRootHelper(bvh2, edgeMaterial, depth, i);
        this.add(root7);
        this._roots.push(root7);
      }
      const root6 = this._roots[i];
      root6.bvh = bvh2;
      root6.depth = depth;
      root6.displayParents = displayParents;
      root6.displayEdges = displayEdges;
      root6.material = displayEdges ? edgeMaterial : meshMaterial;
      root6.update();
    }
  }
  updateMatrixWorld(...args) {
    const mesh = this.mesh;
    const parent = this.parent;
    if (mesh !== null) {
      mesh.updateWorldMatrix(true, false);
      if (parent) {
        this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);
      } else {
        this.matrix.copy(mesh.matrixWorld);
      }
      if (mesh.isInstancedMesh || mesh.isBatchedMesh) {
        mesh.getMatrixAt(this.objectIndex, matrix);
        this.matrix.multiply(matrix);
      }
      this.matrix.decompose(
        this.position,
        this.quaternion,
        this.scale
      );
    }
    super.updateMatrixWorld(...args);
  }
  copy(source) {
    this.depth = source.depth;
    this.mesh = source.mesh;
    this.bvh = source.bvh;
    this.opacity = source.opacity;
    this.color.copy(source.color);
  }
  clone() {
    return new _MeshBVHHelper(this.mesh, this.bvh, this.depth);
  }
  dispose() {
    this.edgeMaterial.dispose();
    this.meshMaterial.dispose();
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].geometry.dispose();
    }
  }
};

// node_modules/three-mesh-bvh/src/debug/Debug.js
import { Box3 as Box39, Vector3 as Vector322 } from "three";
var _box12 = new Box39();
var _box22 = new Box39();
var _vec = new Vector322();

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
import { Ray as Ray2, Matrix4 as Matrix415, Mesh as Mesh7, Vector3 as Vector323, Sphere as Sphere4, BatchedMesh, REVISION as REVISION2 } from "three";

// node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  return hit;
}

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
var IS_REVISION_166 = parseInt(REVISION2) >= 166;
var ray2 = new Ray2();
var direction = new Vector323();
var tmpInverseMatrix = new Matrix415();
var origMeshRaycastFunc = Mesh7.prototype.raycast;
var origBatchedRaycastFunc = BatchedMesh.prototype.raycast;
var _worldScale = new Vector323();
var _mesh2 = new Mesh7();
var _batchIntersects = [];
function acceleratedRaycast(raycaster, intersects) {
  if (this.isBatchedMesh) {
    acceleratedBatchedMeshRaycast.call(this, raycaster, intersects);
  } else {
    acceleratedMeshRaycast.call(this, raycaster, intersects);
  }
}
function acceleratedBatchedMeshRaycast(raycaster, intersects) {
  if (this.boundsTrees) {
    const boundsTrees = this.boundsTrees;
    const drawInfo = this._drawInfo || this._instanceInfo;
    const drawRanges = this._drawRanges || this._geometryInfo;
    const matrixWorld2 = this.matrixWorld;
    _mesh2.material = this.material;
    _mesh2.geometry = this.geometry;
    const oldBoundsTree = _mesh2.geometry.boundsTree;
    const oldDrawRange = _mesh2.geometry.drawRange;
    if (_mesh2.geometry.boundingSphere === null) {
      _mesh2.geometry.boundingSphere = new Sphere4();
    }
    for (let i = 0, l = drawInfo.length; i < l; i++) {
      if (!this.getVisibleAt(i)) {
        continue;
      }
      const geometryId = drawInfo[i].geometryIndex;
      _mesh2.geometry.boundsTree = boundsTrees[geometryId];
      this.getMatrixAt(i, _mesh2.matrixWorld).premultiply(matrixWorld2);
      if (!_mesh2.geometry.boundsTree) {
        this.getBoundingBoxAt(geometryId, _mesh2.geometry.boundingBox);
        this.getBoundingSphereAt(geometryId, _mesh2.geometry.boundingSphere);
        const drawRange = drawRanges[geometryId];
        _mesh2.geometry.setDrawRange(drawRange.start, drawRange.count);
      }
      _mesh2.raycast(raycaster, _batchIntersects);
      for (let j3 = 0, l2 = _batchIntersects.length; j3 < l2; j3++) {
        const intersect = _batchIntersects[j3];
        intersect.object = this;
        intersect.batchId = i;
        intersects.push(intersect);
      }
      _batchIntersects.length = 0;
    }
    _mesh2.geometry.boundsTree = oldBoundsTree;
    _mesh2.geometry.drawRange = oldDrawRange;
    _mesh2.material = null;
    _mesh2.geometry = null;
  } else {
    origBatchedRaycastFunc.call(this, raycaster, intersects);
  }
}
function acceleratedMeshRaycast(raycaster, intersects) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0) return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray2.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    _worldScale.setFromMatrixScale(this.matrixWorld);
    direction.copy(ray2.direction).multiply(_worldScale);
    const scaleFactor = direction.length();
    const near = raycaster.near / scaleFactor;
    const far = raycaster.far / scaleFactor;
    const bvh2 = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh2.raycastFirst(ray2, this.material, near, far), this, raycaster);
      if (hit) {
        intersects.push(hit);
      }
    } else {
      const hits = bvh2.raycast(ray2, this.material, near, far);
      for (let i = 0, l = hits.length; i < l; i++) {
        const hit = convertRaycastIntersect(hits[i], this, raycaster);
        if (hit) {
          intersects.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects);
  }
}
function computeBoundsTree(options = {}) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}
function computeBatchedBoundsTree(index = -1, options = {}) {
  if (!IS_REVISION_166) {
    throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");
  }
  options = {
    ...options,
    range: null
  };
  const drawRanges = this._drawRanges || this._geometryInfo;
  const geometryCount = this._geometryCount;
  if (!this.boundsTrees) {
    this.boundsTrees = new Array(geometryCount).fill(null);
  }
  const boundsTrees = this.boundsTrees;
  while (boundsTrees.length < geometryCount) {
    boundsTrees.push(null);
  }
  if (index < 0) {
    for (let i = 0; i < geometryCount; i++) {
      options.range = drawRanges[i];
      boundsTrees[i] = new MeshBVH(this.geometry, options);
    }
    return boundsTrees;
  } else {
    if (index < drawRanges.length) {
      options.range = drawRanges[index];
      boundsTrees[index] = new MeshBVH(this.geometry, options);
    }
    return boundsTrees[index] || null;
  }
}
function disposeBatchedBoundsTree(index = -1) {
  if (index < 0) {
    this.boundsTrees.fill(null);
  } else {
    if (index < this.boundsTrees.length) {
      this.boundsTrees[index] = null;
    }
  }
}

// node_modules/three-mesh-bvh/src/webgl/MeshBVHUniformStruct.js
import {
  DataTexture as DataTexture2,
  FloatType as FloatType2,
  UnsignedIntType as UnsignedIntType2,
  RGBAFormat as RGBAFormat2,
  RGIntegerFormat as RGIntegerFormat2,
  NearestFilter as NearestFilter3,
  BufferAttribute as BufferAttribute6
} from "three";

// node_modules/three-mesh-bvh/src/webgl/VertexAttributeTexture.js
import {
  DataTexture,
  FloatType,
  IntType,
  UnsignedIntType,
  ByteType,
  UnsignedByteType,
  ShortType,
  UnsignedShortType,
  RedFormat,
  RGFormat,
  RGBAFormat,
  RedIntegerFormat,
  RGIntegerFormat,
  RGBAIntegerFormat,
  NearestFilter as NearestFilter2
} from "three";
function countToStringFormat(count) {
  switch (count) {
    case 1:
      return "R";
    case 2:
      return "RG";
    case 3:
      return "RGBA";
    case 4:
      return "RGBA";
  }
  throw new Error();
}
function countToFormat(count) {
  switch (count) {
    case 1:
      return RedFormat;
    case 2:
      return RGFormat;
    case 3:
      return RGBAFormat;
    case 4:
      return RGBAFormat;
  }
}
function countToIntFormat(count) {
  switch (count) {
    case 1:
      return RedIntegerFormat;
    case 2:
      return RGIntegerFormat;
    case 3:
      return RGBAIntegerFormat;
    case 4:
      return RGBAIntegerFormat;
  }
}
var VertexAttributeTexture = class extends DataTexture {
  constructor() {
    super();
    this.minFilter = NearestFilter2;
    this.magFilter = NearestFilter2;
    this.generateMipmaps = false;
    this.overrideItemSize = null;
    this._forcedType = null;
  }
  updateFrom(attr) {
    const overrideItemSize = this.overrideItemSize;
    const originalItemSize = attr.itemSize;
    const originalCount = attr.count;
    if (overrideItemSize !== null) {
      if (originalItemSize * originalCount % overrideItemSize !== 0) {
        throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
      }
      attr.itemSize = overrideItemSize;
      attr.count = originalCount * originalItemSize / overrideItemSize;
    }
    const itemSize = attr.itemSize;
    const count = attr.count;
    const normalized = attr.normalized;
    const originalBufferCons = attr.array.constructor;
    const byteCount = originalBufferCons.BYTES_PER_ELEMENT;
    let targetType = this._forcedType;
    let finalStride = itemSize;
    if (targetType === null) {
      switch (originalBufferCons) {
        case Float32Array:
          targetType = FloatType;
          break;
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
          targetType = UnsignedIntType;
          break;
        case Int8Array:
        case Int16Array:
        case Int32Array:
          targetType = IntType;
          break;
      }
    }
    let type, format, normalizeValue, targetBufferCons;
    let internalFormat = countToStringFormat(itemSize);
    switch (targetType) {
      case FloatType:
        normalizeValue = 1;
        format = countToFormat(itemSize);
        if (normalized && byteCount === 1) {
          targetBufferCons = originalBufferCons;
          internalFormat += "8";
          if (originalBufferCons === Uint8Array) {
            type = UnsignedByteType;
          } else {
            type = ByteType;
            internalFormat += "_SNORM";
          }
        } else {
          targetBufferCons = Float32Array;
          internalFormat += "32F";
          type = FloatType;
        }
        break;
      case IntType:
        internalFormat += byteCount * 8 + "I";
        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1;
        format = countToIntFormat(itemSize);
        if (byteCount === 1) {
          targetBufferCons = Int8Array;
          type = ByteType;
        } else if (byteCount === 2) {
          targetBufferCons = Int16Array;
          type = ShortType;
        } else {
          targetBufferCons = Int32Array;
          type = IntType;
        }
        break;
      case UnsignedIntType:
        internalFormat += byteCount * 8 + "UI";
        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1;
        format = countToIntFormat(itemSize);
        if (byteCount === 1) {
          targetBufferCons = Uint8Array;
          type = UnsignedByteType;
        } else if (byteCount === 2) {
          targetBufferCons = Uint16Array;
          type = UnsignedShortType;
        } else {
          targetBufferCons = Uint32Array;
          type = UnsignedIntType;
        }
        break;
    }
    if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {
      finalStride = 4;
    }
    const dimension = Math.ceil(Math.sqrt(count)) || 1;
    const length = finalStride * dimension * dimension;
    const dataArray = new targetBufferCons(length);
    const originalNormalized = attr.normalized;
    attr.normalized = false;
    for (let i = 0; i < count; i++) {
      const ii = finalStride * i;
      dataArray[ii] = attr.getX(i) / normalizeValue;
      if (itemSize >= 2) {
        dataArray[ii + 1] = attr.getY(i) / normalizeValue;
      }
      if (itemSize >= 3) {
        dataArray[ii + 2] = attr.getZ(i) / normalizeValue;
        if (finalStride === 4) {
          dataArray[ii + 3] = 1;
        }
      }
      if (itemSize >= 4) {
        dataArray[ii + 3] = attr.getW(i) / normalizeValue;
      }
    }
    attr.normalized = originalNormalized;
    this.internalFormat = internalFormat;
    this.format = format;
    this.type = type;
    this.image.width = dimension;
    this.image.height = dimension;
    this.image.data = dataArray;
    this.needsUpdate = true;
    this.dispose();
    attr.itemSize = originalItemSize;
    attr.count = originalCount;
  }
};
var UIntVertexAttributeTexture = class extends VertexAttributeTexture {
  constructor() {
    super();
    this._forcedType = UnsignedIntType;
  }
};
var FloatVertexAttributeTexture = class extends VertexAttributeTexture {
  constructor() {
    super();
    this._forcedType = FloatType;
  }
};

// node_modules/three-mesh-bvh/src/webgl/MeshBVHUniformStruct.js
var MeshBVHUniformStruct = class {
  constructor() {
    this.index = new UIntVertexAttributeTexture();
    this.position = new FloatVertexAttributeTexture();
    this.bvhBounds = new DataTexture2();
    this.bvhContents = new DataTexture2();
    this._cachedIndexAttr = null;
    this.index.overrideItemSize = 3;
  }
  updateFrom(bvh2) {
    const { geometry } = bvh2;
    bvhToTextures(bvh2, this.bvhBounds, this.bvhContents);
    this.position.updateFrom(geometry.attributes.position);
    if (bvh2.indirect) {
      const indirectBuffer = bvh2._indirectBuffer;
      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {
        if (geometry.index) {
          this._cachedIndexAttr = geometry.index.clone();
        } else {
          const array = getIndexArray(getVertexCount(geometry));
          this._cachedIndexAttr = new BufferAttribute6(array, 1, false);
        }
      }
      dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);
      this.index.updateFrom(this._cachedIndexAttr);
    } else {
      this.index.updateFrom(geometry.index);
    }
  }
  dispose() {
    const { index, position: position2, bvhBounds, bvhContents } = this;
    if (index) index.dispose();
    if (position2) position2.dispose();
    if (bvhBounds) bvhBounds.dispose();
    if (bvhContents) bvhContents.dispose();
  }
};
function dereferenceIndex(geometry, indirectBuffer, target) {
  const unpacked = target.array;
  const indexArray = geometry.index ? geometry.index.array : null;
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    const i3 = 3 * i;
    const v32 = 3 * indirectBuffer[i];
    for (let c = 0; c < 3; c++) {
      unpacked[i3 + c] = indexArray ? indexArray[v32 + c] : v32 + c;
    }
  }
}
function bvhToTextures(bvh2, boundsTexture, contentsTexture) {
  const roots = bvh2._roots;
  if (roots.length !== 1) {
    throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
  }
  const root6 = roots[0];
  const uint16Array2 = new Uint16Array(root6);
  const uint32Array2 = new Uint32Array(root6);
  const float32Array2 = new Float32Array(root6);
  const nodeCount = root6.byteLength / BYTES_PER_NODE;
  const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));
  const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);
  const contentsDimension = Math.ceil(Math.sqrt(nodeCount));
  const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);
  for (let i = 0; i < nodeCount; i++) {
    const nodeIndex32 = i * BYTES_PER_NODE / 4;
    const nodeIndex16 = nodeIndex32 * 2;
    const boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);
    for (let b2 = 0; b2 < 3; b2++) {
      boundsArray[8 * i + 0 + b2] = float32Array2[boundsIndex + 0 + b2];
      boundsArray[8 * i + 4 + b2] = float32Array2[boundsIndex + 3 + b2];
    }
    if (IS_LEAF(nodeIndex16, uint16Array2)) {
      const count = COUNT(nodeIndex16, uint16Array2);
      const offset = OFFSET(nodeIndex32, uint32Array2);
      const mergedLeafCount = LEAFNODE_MASK_32 | count;
      contentsArray[i * 2 + 0] = mergedLeafCount;
      contentsArray[i * 2 + 1] = offset;
    } else {
      const rightNodeIndex = uint32Array2[nodeIndex32 + 6];
      const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
      contentsArray[i * 2 + 0] = splitAxis;
      contentsArray[i * 2 + 1] = rightNodeIndex;
    }
  }
  boundsTexture.image.data = boundsArray;
  boundsTexture.image.width = boundsDimension;
  boundsTexture.image.height = boundsDimension;
  boundsTexture.format = RGBAFormat2;
  boundsTexture.type = FloatType2;
  boundsTexture.internalFormat = "RGBA32F";
  boundsTexture.minFilter = NearestFilter3;
  boundsTexture.magFilter = NearestFilter3;
  boundsTexture.generateMipmaps = false;
  boundsTexture.needsUpdate = true;
  boundsTexture.dispose();
  contentsTexture.image.data = contentsArray;
  contentsTexture.image.width = contentsDimension;
  contentsTexture.image.height = contentsDimension;
  contentsTexture.format = RGIntegerFormat2;
  contentsTexture.type = UnsignedIntType2;
  contentsTexture.internalFormat = "RG32UI";
  contentsTexture.minFilter = NearestFilter3;
  contentsTexture.magFilter = NearestFilter3;
  contentsTexture.generateMipmaps = false;
  contentsTexture.needsUpdate = true;
  contentsTexture.dispose();
}

// node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js
import { BufferAttribute as BufferAttribute7, BufferGeometry as BufferGeometry5, Vector3 as Vector324, Vector4 as Vector43, Matrix4 as Matrix416, Matrix3 } from "three";
var _positionVector = new Vector324();
var _normalVector = new Vector324();
var _tangentVector = new Vector324();
var _tangentVector4 = new Vector43();
var _morphVector = new Vector324();
var _temp = new Vector324();
var _skinIndex = new Vector43();
var _skinWeight = new Vector43();
var _matrix = new Matrix416();
var _boneMatrix = new Matrix416();

// node_modules/three-mesh-bvh/src/webgl/glsl/common_functions.glsl.js
var common_functions = (
  /* glsl */
  `

// A stack of uint32 indices can can store the indices for
// a perfectly balanced tree with a depth up to 31. Lower stack
// depth gets higher performance.
//
// However not all trees are balanced. Best value to set this to
// is the trees max depth.
#ifndef BVH_STACK_DEPTH
#define BVH_STACK_DEPTH 60
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}
`
);

// node_modules/three-mesh-bvh/src/webgl/glsl/bvh_ray_functions.glsl.js
var bvh_ray_functions = (
  /* glsl */
  `

#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

// Raycasting
bool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	dist = max( t0, 0.0 );

	return t1 >= dist;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// outputs
	inout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

bool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhIntersectFirstHit(		bvh,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)	_bvhIntersectFirstHit(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)

bool _bvhIntersectFirstHit(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// output variables split into separate variables due to output precision
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float triangleDistance = INFINITY;
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance;
		if (
			! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )
			|| boundsHitDistance > triangleDistance
		) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh_position, bvh_index, offset, count,
				rayOrigin, rayDirection, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = currNodeIndex + boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`
);

// node_modules/three-mesh-bvh/src/webgl/glsl/bvh_struct_definitions.glsl.js
var bvh_struct_definitions = (
  /* glsl */
  `
struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`
);

// node_modules/three-mesh-bvh/src/index.js
var shaderStructs = bvh_struct_definitions;
var shaderIntersectFunction = `
	${common_functions}
	${bvh_ray_functions}
`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/fragment.js
import { ShaderChunk as ShaderChunk5 } from "three";
var fragmentShader6 = `#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${shaderStructs}
${shaderIntersectFunction}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${ShaderChunk5.tonemapping_fragment}
	${ShaderChunk5.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/vertex.js
var vertexShader6 = `uniform mat4 viewMatrixInverse;

varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

void main() {
	vec4 transformedNormal = vec4(normal, 0.0);
	vec4 transformedPosition = vec4(position, 1.0);
	#ifdef USE_INSTANCING
		transformedNormal = instanceMatrix * transformedNormal;
		transformedPosition = instanceMatrix * transformedPosition;
	#endif

	#ifdef USE_INSTANCING
		vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
	#else
		vModelMatrixInverse = inverse(modelMatrix);
	#endif

	#ifdef USE_INSTANCING_COLOR
		vInstanceColor = instanceColor.rgb;
	#endif

	vWorldPosition = (modelMatrix * transformedPosition).xyz;
	vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte
MeshRefractionMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte";
function MeshRefractionMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshRefractionMaterial);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let bounces = prop($$props, "bounces", 3, 2), ior = prop($$props, "ior", 3, 2.4), fresnel = prop($$props, "fresnel", 3, 0), aberrationStrength = prop($$props, "aberrationStrength", 3, 0), color = prop($$props, "color", 3, "white"), fastChroma = prop($$props, "fastChroma", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "envMap",
      "bounces",
      "ior",
      "fresnel",
      "aberrationStrength",
      "color",
      "fastChroma",
      "ref"
    ],
    "props"
  );
  const uniforms = {
    envMap: { value: null },
    bounces: { value: 2 },
    ior: { value: 2.4 },
    correctMips: { value: true },
    aberrationStrength: { value: 0.01 },
    fresnel: { value: 0 },
    bvh: { value: new MeshBVHUniformStruct() },
    color: { value: new Color8("white") },
    resolution: { value: new Vector29() },
    viewMatrixInverse: { value: new Matrix417() },
    projectionMatrixInverse: { value: new Matrix417() }
  };
  const material2 = new ShaderMaterial6({ fragmentShader: fragmentShader6, vertexShader: vertexShader6, uniforms });
  ref(material2);
  const { size, invalidate, camera } = useThrelte();
  const parent = useParent();
  let defines = {};
  const updateDefines = (envMap, aberrationStrength2, fastChroma2) => {
    const isCubeMap = isInstanceOf(envMap, "CubeTexture");
    const w = (isCubeMap ? envMap.image[0]?.width : envMap?.image.width) ?? 1024;
    const cubeSize = w / 4;
    const lodMax = Math.floor(Math.log2(cubeSize));
    const _cubeSize = Math.pow(2, lodMax);
    const width2 = 3 * Math.max(_cubeSize, 16 * 7);
    const height2 = 4 * _cubeSize;
    if (isCubeMap) defines.ENVMAP_TYPE_CUBEM = "";
    defines.CUBEUV_TEXEL_WIDTH = `${1 / width2}`;
    defines.CUBEUV_TEXEL_HEIGHT = `${1 / height2}`;
    defines.CUBEUV_MAX_MIP = `${lodMax}.0`;
    if (aberrationStrength2 > 0) defines.CHROMATIC_ABERRATIONS = "";
    if (fastChroma2) defines.FAST_CHROMA = "";
  };
  user_pre_effect(() => {
    updateDefines($$props.envMap, aberrationStrength(), fastChroma());
  });
  onMount(() => {
    if ($parent() && $parent() instanceof Mesh8 && $parent().geometry) {
      uniforms.bvh.value = new MeshBVHUniformStruct();
      uniforms.bvh.value.updateFrom(new MeshBVH($parent()?.geometry.clone().toNonIndexed(), { strategy: SAH }));
    }
  });
  useTask(
    () => {
      uniforms.viewMatrixInverse.value = camera.current.matrixWorld;
      uniforms.projectionMatrixInverse.value = camera.current.projectionMatrixInverse;
    },
    { autoInvalidate: false }
  );
  const colorObj = new Color8(color());
  user_pre_effect(() => {
    colorObj.set(color());
    invalidate();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    let $0 = user_derived(() => [$size().width, $size().height]);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return material2;
          },
          get "uniforms.envMap.value"() {
            return $$props.envMap;
          },
          get "uniforms.bounces.value"() {
            return bounces();
          },
          get "uniforms.ior.value"() {
            return ior();
          },
          get "uniforms.fresnel.value"() {
            return fresnel();
          },
          get "uniforms.aberrationStrength.value"() {
            return aberrationStrength();
          },
          get "uniforms.color.value"() {
            return colorObj;
          },
          get "uniforms.resolution.value"() {
            return get($0);
          },
          get defines() {
            return defines;
          }
        },
        () => props
      )),
      "component",
      MeshRefractionMaterial,
      104,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MeshRefractionMaterial = hmr(MeshRefractionMaterial);
  import.meta.hot.accept((module) => {
    MeshRefractionMaterial[HMR].update(module.default);
  });
}
var MeshRefractionMaterial_default = MeshRefractionMaterial;

// node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte
import { TextGeometry } from "three/examples/jsm/geometries/TextGeometry.js";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
import { toCreasedNormals as toCreasedNormals2 } from "three/examples/jsm/utils/BufferGeometryUtils.js";
Text3DGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte";
function Text3DGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text3DGeometry);
  var $$ownership_validator = create_ownership_validator($$props);
  const $loadedFont = () => (validate_store(get(loadedFont), "loadedFont"), store_get(get(loadedFont), "$loadedFont", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let font = prop($$props, "font", 3, "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "text",
      "font",
      "size",
      "depth",
      "curveSegments",
      "bevelEnabled",
      "bevelThickness",
      "bevelSize",
      "bevelOffset",
      "bevelSegments",
      "smooth",
      "extrudePath",
      "steps",
      "UVGenerator",
      "ref",
      "children"
    ],
    "props"
  );
  const suspend = useSuspense();
  const loader = useLoader(FontLoader);
  let loadedFont = tag(
    user_derived(() => suspend(strict_equals(typeof font(), "string") ? loader.load(font()) : asyncWritable(new Promise((resolve) => resolve(font()))))),
    "loadedFont"
  );
  let baseGeometry = tag(
    user_derived(() => {
      if (!$loadedFont()) return;
      return new TextGeometry($$props.text, {
        font: $loadedFont(),
        size: $$props.size,
        depth: $$props.depth,
        curveSegments: $$props.curveSegments,
        bevelEnabled: $$props.bevelEnabled,
        bevelThickness: $$props.bevelThickness,
        bevelSize: $$props.bevelSize,
        bevelOffset: $$props.bevelOffset,
        bevelSegments: $$props.bevelSegments,
        extrudePath: $$props.extrudePath,
        steps: $$props.steps,
        UVGenerator: $$props.UVGenerator
      });
    }),
    "baseGeometry"
  );
  let creasedGeometry = tag(
    user_derived(() => {
      if (!get(baseGeometry)) return;
      if (strict_equals($$props.smooth, 0)) return get(baseGeometry);
      return toCreasedNormals2(get(baseGeometry), $$props.smooth);
    }),
    "creasedGeometry"
  );
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", T, ref);
        add_svelte_meta(
          () => T(node_1, spread_props(
            {
              get is() {
                return get(creasedGeometry);
              }
            },
            () => props,
            {
              get ref() {
                return ref();
              },
              set ref($$value) {
                ref($$value);
              },
              children: wrap_snippet(Text3DGeometry, ($$anchor3, $$slotProps) => {
                var fragment_2 = comment();
                var node_2 = first_child(fragment_2);
                add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ ref: get(creasedGeometry) })), "render", Text3DGeometry, 72, 4);
                append($$anchor3, fragment_2);
              }),
              $$slots: { default: true }
            }
          )),
          "component",
          Text3DGeometry,
          67,
          2,
          { componentTag: "T" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(creasedGeometry)) $$render(consequent);
      }),
      "if",
      Text3DGeometry,
      66,
      0
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Text3DGeometry = hmr(Text3DGeometry);
  import.meta.hot.accept((module) => {
    Text3DGeometry[HMR].update(module.default);
  });
}
var Text3DGeometry_default = Text3DGeometry;

// node_modules/@threlte/extras/node_modules/three-perf/dist/ThreePerf.mjs
var import_tweakpane = __toESM(require_tweakpane(), 1);
import { Object3D as Object3D5 } from "three";

// node_modules/troika-three-text/dist/troika-three-text.esm.js
import { Texture as Texture3, LinearFilter as LinearFilter2, Color as Color9, InstancedBufferGeometry, Sphere as Sphere5, Box3 as Box310, InstancedBufferAttribute, PlaneGeometry as PlaneGeometry2, Vector2 as Vector211, Vector4 as Vector44, Matrix3 as Matrix32, Mesh as Mesh10, MeshBasicMaterial as MeshBasicMaterial6, DoubleSide as DoubleSide8, Matrix4 as Matrix419, Vector3 as Vector326, DataTexture as DataTexture3, RGBAFormat as RGBAFormat3, FloatType as FloatType3, DynamicDrawUsage as DynamicDrawUsage2 } from "three";

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0) dependencies = [];
    var init = ref.init;
    if (init === void 0) init = function() {
    };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0) getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init = rehydrate("<" + name + ">.init", init);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init === "function") {
        value = init.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action2 = ref.action;
    var data = ref.data;
    try {
      if (action2 === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action2 === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(function(dep) {
      if (dep) {
        dep = dep.onMainThread || dep;
        if (dep._getInitResult) {
          dep = dep._getInitResult();
        }
      }
      return dep;
    }) : [];
    var initPromise = Promise.all(dependencies).then(function(deps) {
      return init.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== "undefined" && false) ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  var onMainThread = defineMainThreadModule(options);
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    if (!supportsWorkers()) {
      return onMainThread.apply(void 0, args);
    }
    if (!registrationPromise) {
      registrationPromise = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationPromise = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationPromise.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  moduleFunc.onMainThread = onMainThread;
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action2, data) {
  return new Promise(function(resolve, reject) {
    var messageId = ++_messageId;
    openRequests[messageId] = function(response) {
      if (response.success) {
        resolve(response.result);
      } else {
        reject(new Error("Error in worker " + action2 + " call: " + response.error));
      }
    };
    getWorker(workerId).postMessage({
      messageId,
      action: action2,
      data
    });
  });
}

// node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs
function SDFGenerator() {
  var exports = (function(exports2) {
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t, pointOut) {
      var t2 = 1 - t;
      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;
      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;
    }
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {
      var t2 = 1 - t;
      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;
      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;
    }
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(v4) {
          return parseFloat(v4);
        });
        switch (match[1]) {
          case "M":
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case "L":
            if (args[0] !== prevX || args[1] !== prevY) {
              commandCallback("L", prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case "Q": {
            commandCallback("Q", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
            break;
          }
          case "C": {
            commandCallback("C", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
            break;
          }
          case "Z":
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback("L", prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0) curvePoints = 16;
      var tempPoint = { x: 0, y: 0 };
      forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case "L":
            segmentCallback(startX, startY, endX, endY);
            break;
          case "Q": {
            var prevCurveX = startX;
            var prevCurveY = startY;
            for (var i = 1; i < curvePoints; i++) {
              pointOnQuadraticBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                endX,
                endY,
                i / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
              prevCurveX = tempPoint.x;
              prevCurveY = tempPoint.y;
            }
            break;
          }
          case "C": {
            var prevCurveX$1 = startX;
            var prevCurveY$1 = startY;
            for (var i$1 = 1; i$1 < curvePoints; i$1++) {
              pointOnCubicBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                ctrl2X,
                ctrl2Y,
                endX,
                endY,
                i$1 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
              prevCurveX$1 = tempPoint.x;
              prevCurveY$1 = tempPoint.y;
            }
            break;
          }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = /* @__PURE__ */ new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext("webgl", glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        let getExtension = function(name) {
          var ext = extensions[name];
          if (!ext) {
            ext = extensions[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }, compileShader = function(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          return shader;
        }, withProgram = function(name, vert, frag, func) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program,
              transaction: function transaction(func2) {
                gl.useProgram(program);
                func2({
                  setUniform: function setUniform(type, name2) {
                    var values = [], len = arguments.length - 2;
                    while (len-- > 0) values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name2] || (uniforms[name2] = gl.getUniformLocation(program, name2));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name2, size, usage, instancingDivisor, data) {
                    var attr = attributes[name2];
                    if (!attr) {
                      attr = attributes[name2] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name2),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func);
        }, withTexture = function(name, func) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }, withTextureFramebuffer = function(texture, textureUnit2, func) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit2);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }, handleContextLoss = function() {
          extensions = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        };
        var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        var extensions = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener("webglcontextlost", function(e) {
          handleContextLoss();
          e.preventDefault();
        }, false);
        cache.set(gl, wrapper = {
          gl,
          isWebGL2,
          getExtension,
          withProgram,
          withTexture,
          withTextureFramebuffer,
          handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x, y2, width2, height2, channels, framebuffer) {
      if (channels === void 0) channels = 15;
      if (framebuffer === void 0) framebuffer = null;
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture("copy", function(tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width2, height2, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram("copy", viewportQuadVertex, copyTexFragment, function(ref2) {
            var setUniform = ref2.setUniform;
            var setAttribute = ref2.setAttribute;
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform("1i", "image", texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x, y2, width2, height2);
            gl.scissor(x, y2, width2, height2);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function resizeWebGLCanvasWithoutClearing2(canvas, newWidth, newHeight) {
      var width2 = canvas.width;
      var height2 = canvas.height;
      withWebGLContext(canvas, function(ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width2 * height2 * 4);
        gl.readPixels(0, 0, width2, height2, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width2, height2);
      });
    }
    var webglUtils = Object.freeze({
      __proto__: null,
      withWebGLContext,
      renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing2
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0) sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];
      var segments = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        segments.push({
          x1,
          y1,
          x2,
          y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });
      segments.sort(function(a, b2) {
        return a.maxX - b2.maxX;
      });
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(
            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
          );
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;
      function findNearestSignedDistance(x, y2) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX + closestDist <= x) {
            break;
          }
          if (x + closestDist > seg.minX && y2 - closestDist < seg.maxY && y2 + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x, y2, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }
        if (isPointInPoly(x, y2)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }
      function isPointInPoly(x, y2) {
        var winding = 0;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX <= x) {
            break;
          }
          var intersects = seg.y1 > y2 !== seg.y2 > y2 && x < (seg.x2 - seg.x1) * (y2 - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y2, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i = 0; i < data.length; i++) {
        rgbaData[i * 4 + channel] = data[i];
      }
      renderImageData(glOrCanvas, rgbaData, x, y2, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }
    function absSquareDistanceToLineSegment(x, y2, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y2 - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x - (lineX0 + t * ldx);
      var dy = y2 - (lineY0 + t * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = /* @__PURE__ */ new WeakMap();
    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error("WebGL generation not supported");
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (glOrCanvas === void 0) glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === "function" ? new OffscreenCanvas(1, 1) : typeof document !== "undefined" ? document.createElement("canvas") : null;
          if (!canvas) {
            throw new Error("OffscreenCanvas or DOM canvas not supported");
          }
          glOrCanvas = implicitContext = canvas.getContext("webgl", { depth: false });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture("readable", function(texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function(framebuffer) {
            generateIntoFramebuffer(
              sdfWidth,
              sdfHeight,
              path,
              viewBox,
              maxDistance,
              sdfExponent,
              gl,
              framebuffer,
              0,
              0,
              0
              // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i = 0, j3 = 0; i < rgbaData.length; i += 4) {
        data[j3++] = rgbaData[i];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y2, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y2, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      validateSupport(glOrCanvas);
      var lineSegmentCoords = [];
      pathToLineSegments(path, function(x1, y1, x2, y22) {
        lineSegmentCoords.push(x1, y1, x2, y22);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture("rawDistances", function(intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              intermediateTexture._lastWidth = sdfWidth,
              intermediateTexture._lastHeight = sdfHeight,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              null
            );
          }
          withProgram("main", mainVertex, mainFragment, function(ref2) {
            var setAttribute = ref2.setAttribute;
            var setUniform = ref2.setUniform;
            var instancingExtension = !isWebGL2 && getExtension("ANGLE_instanced_arrays");
            var blendMinMaxExtension = !isWebGL2 && getExtension("EXT_blend_minmax");
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute("aLineSegment", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);
            setUniform.apply(void 0, ["4f", "uGlyphBounds"].concat(viewBox));
            setUniform("1f", "uMaxDistance", maxDistance);
            setUniform("1f", "uExponent", sdfExponent);
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer2) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
            });
          });
          withProgram("post", viewportQuadVertex, postFragment, function(program) {
            program.setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform("1i", "tex", intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x, y2, sdfWidth, sdfHeight);
            gl.scissor(x, y2, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error("webgl context lost");
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key2 = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key2);
      if (supported === void 0) {
        isTestingSupport = true;
        var failReason = null;
        try {
          var expectedResult = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ];
          var testResult = generate$1(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            glOrCanvas
          );
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i) {
            return val === expectedResult[i];
          });
          if (!supported) {
            failReason = "bad trial run results";
            console.info(expectedResult, testResult);
          }
        } catch (err) {
          supported = false;
          failReason = err.message;
        }
        if (failReason) {
          console.warn("WebGL SDF generation not supported:", failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key2, supported);
      }
      return supported;
    }
    var webgl = Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer,
      isSupported
    });
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0) sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generate$2.apply(javascript, arguments);
      }
    }
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y2, channel) {
      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y2 === void 0) y2 = 0;
      if (channel === void 0) channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports2.forEachPathCommand = forEachPathCommand;
    exports2.generate = generate;
    exports2.generateIntoCanvas = generateIntoCanvas;
    exports2.javascript = javascript;
    exports2.pathToLineSegments = pathToLineSegments;
    exports2.webgl = webgl;
    exports2.webglUtils = webglUtils;
    Object.defineProperty(exports2, "__esModule", { value: true });
    return exports2;
  })({});
  return exports;
}

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = (function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i) {
      TYPES[type] = 1 << i + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range) {
              var ref = range.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i = 0; i < step; i++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA) loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i = +entry; i--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a = ref[0];
          var b2 = ref[1];
          a = String.fromCodePoint(lastCode += parseInt(a, radix));
          b2 = String.fromCodePoint(lastCode += parseInt(b2, radix));
          map2.set(a, b2);
          includeReverse && reverseMap.set(b2, a);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i = 0; i < string.length; i++) {
        charTypes[i] = getBidiCharType(string[i]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i2, type2) {
        var oldType = charTypes[i2];
        charTypes[i2] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n) {
        return n + (n & 1 ? 1 : 2);
      };
      var nextOdd = function(n) {
        return n + (n & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j3 = run$1._start; j3 <= run$1._end; j3++) {
                seqIndices.push(j3);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a, b2) {
                return a[0] - b2[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start, isFSI) {
        for (var i2 = start; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i2);
            i2 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i2 = isolateStart + 1; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i2;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key2) {
          map2.set(key2, value);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start, end2) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var map2 = /* @__PURE__ */ new Map();
      for (var i = start; i <= end2; i++) {
        if (embeddingLevels[i] & 1) {
          var mirror = getMirroredCharacter(string[i]);
          if (mirror !== null) {
            map2.set(i, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start, end2) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start, paragraph.start);
        var lineEnd = Math.min(end2, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {
            lineLevels[i] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start, end2) {
      var indices = getReorderedIndices(string, embedLevelsResult, start, end2);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i) {
        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start, end2) {
      var segments = getReorderSegments(string, embedLevelsResult, start, end2);
      var indices = [];
      for (var i = 0; i < string.length; i++) {
        indices[i] = i;
      }
      segments.forEach(function(ref) {
        var start2 = ref[0];
        var end3 = ref[1];
        var slice = indices.slice(start2, end3 + 1);
        for (var i2 = slice.length; i2--; ) {
          indices[end3 - i2] = slice[i2];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  })({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
import { ShaderChunk as ShaderChunk6, UniformsUtils, MeshDepthMaterial as MeshDepthMaterial2, RGBADepthPacking as RGBADepthPacking2, MeshDistanceMaterial, ShaderLib, Matrix4 as Matrix418, Vector3 as Vector325, Mesh as Mesh9, CylinderGeometry, Vector2 as Vector210, MeshStandardMaterial, DoubleSide as DoubleSide7 } from "three";
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk6[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign2 = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop2)) {
          target[prop2] = source[prop2];
        }
      }
    }
  }
  return target;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign2(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived2 = Object.create(base, descriptor);
    Object.defineProperty(derived2, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived2, "id", { value: materialInstanceId++ });
    derived2.uuid = generateUUID();
    derived2.uniforms = assign2({}, base.uniforms, options.uniforms);
    derived2.defines = assign2({}, base.defines, options.defines);
    derived2.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived2.extensions = assign2({}, base.extensions, options.extensions);
    derived2._listeners = void 0;
    return derived2;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    type: {
      get: () => baseMaterial.type,
      set: (value) => {
        baseMaterial.type = value;
      }
    },
    isDerivedFrom: {
      writable: true,
      configurable: true,
      value: function(testMaterial) {
        const base = this.baseMaterial;
        return testMaterial === base || base.isDerivedMaterial && base.isDerivedFrom(testMaterial) || false;
      }
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign2(this.extensions, source.extensions);
          assign2(this.defines, source.defines);
          assign2(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial2({ depthPacking: RGBADepthPacking2 }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial) _depthMaterial.dispose();
        if (_distanceMaterial) _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material2, { vertexShader: vertexShader10, fragmentShader: fragmentShader10 }, options, key2) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader10 = expandShaderIncludes(vertexShader10);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader10 = fragmentShader10.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader10 = expandShaderIncludes(fragmentShader10);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader: vertexShader10, fragmentShader: fragmentShader10 });
    vertexShader10 = res.vertexShader;
    fragmentShader10 = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader10 = fragmentShader10.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader10 = `vec3 troika_position_${key2};
vec3 troika_normal_${key2};
vec2 troika_uv_${key2};
${vertexShader10}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key2}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key2} = vec3(position);
troika_normal_${key2} = vec3(normal);
troika_uv_${key2} = vec2(uv);
troikaVertexTransform${key2}(troika_position_${key2}, troika_normal_${key2}, troika_uv_${key2});
${vertexMainIntro}
`;
    vertexShader10 = vertexShader10.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key2}`;
    });
    if (!(material2.map && material2.map.channel > 0)) {
      vertexShader10 = vertexShader10.replace(/\bMAP_UV\b/g, `troika_uv_${key2}`);
    }
  }
  vertexShader10 = injectIntoShaderCode(vertexShader10, key2, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader10 = injectIntoShaderCode(fragmentShader10, key2, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader: vertexShader10,
    fragmentShader: fragmentShader10
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key2, value) {
  return key2 === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide7 });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), (function(r) {
    var e = { parse: function(r2) {
      var t2 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t2.readASCII(a2, 0, 4)) {
        var n = 4;
        t2.readUshort(a2, n), n += 2, t2.readUshort(a2, n), n += 2;
        var o = t2.readUint(a2, n);
        n += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t2.readUint(a2, n);
          n += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t2) {
      var a2 = e._bin, n = t2;
      a2.readFixed(r2, t2), t2 += 4;
      var o = a2.readUshort(r2, t2);
      t2 += 2, a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n }, h = {}, d = 0; d < o; d++) {
        var f = a2.readASCII(r2, t2, 4);
        t2 += 4, a2.readUint(r2, t2), t2 += 4;
        var u = a2.readUint(r2, t2);
        t2 += 4;
        var l = a2.readUint(r2, t2);
        t2 += 4, h[f] = { offset: u, length: l };
      }
      for (d = 0; d < s.length; d++) {
        var v4 = s[d];
        h[v4] && (i[v4.trim()] = e[v4.trim()].parse(r2, h[v4].offset, h[v4].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t2, a2) {
      for (var n = e._bin, o = n.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n.readASCII(r2, s, 4);
        s += 4, n.readUint(r2, s), s += 4;
        var d = n.readUint(r2, s);
        if (s += 4, n.readUint(r2, s), s += 4, h == t2) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t2) {
      return e._bin.readShort(r2, t2) / 16384;
    }, readInt: function(r2, t2) {
      return e._bin._view(r2).getInt32(t2);
    }, readInt8: function(r2, t2) {
      return e._bin._view(r2).getInt8(t2);
    }, readShort: function(r2, t2) {
      return e._bin._view(r2).getInt16(t2);
    }, readUshort: function(r2, t2) {
      return e._bin._view(r2).getUint16(t2);
    }, readUshorts: function(r2, t2, a2) {
      for (var n = [], o = 0; o < a2; o++) n.push(e._bin.readUshort(r2, t2 + 2 * o));
      return n;
    }, readUint: function(r2, t2) {
      return e._bin._view(r2).getUint32(t2);
    }, readUint64: function(r2, t2) {
      return 4294967296 * e._bin.readUint(r2, t2) + e._bin.readUint(r2, t2 + 4);
    }, readASCII: function(r2, e2, t2) {
      for (var a2 = "", n = 0; n < t2; n++) a2 += String.fromCharCode(r2[e2 + n]);
      return a2;
    }, readUnicode: function(r2, e2, t2) {
      for (var a2 = "", n = 0; n < t2; n++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t2, a2) {
      var n = e._bin._tdec;
      return n && 0 == t2 && a2 == r2.length ? n.decode(r2) : e._bin.readASCII(r2, t2, a2);
    }, readBytes: function(r2, e2, t2) {
      for (var a2 = [], n = 0; n < t2; n++) a2.push(r2[e2 + n]);
      return a2;
    }, readASCIIArray: function(r2, e2, t2) {
      for (var a2 = [], n = 0; n < t2; n++) a2.push(String.fromCharCode(r2[e2 + n]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t2, a2, n, o) {
      var s = e._bin, i = {}, h = t2;
      s.readFixed(r2, t2), t2 += 4;
      var d = s.readUshort(r2, t2);
      t2 += 2;
      var f = s.readUshort(r2, t2);
      t2 += 2;
      var u = s.readUshort(r2, t2);
      return t2 += 2, i.scriptList = e._lctf.readScriptList(r2, h + d), i.featureList = e._lctf.readFeatureList(r2, h + f), i.lookupList = e._lctf.readLookupList(r2, h + u, o), i;
    }, e._lctf.readLookupList = function(r2, t2, a2) {
      var n = e._bin, o = t2, s = [], i = n.readUshort(r2, t2);
      t2 += 2;
      for (var h = 0; h < i; h++) {
        var d = n.readUshort(r2, t2);
        t2 += 2;
        var f = e._lctf.readLookupTable(r2, o + d, a2);
        s.push(f);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t2, a2) {
      var n = e._bin, o = t2, s = { tabs: [] };
      s.ltype = n.readUshort(r2, t2), t2 += 2, s.flag = n.readUshort(r2, t2), t2 += 2;
      var i = n.readUshort(r2, t2);
      t2 += 2;
      for (var h = s.ltype, d = 0; d < i; d++) {
        var f = n.readUshort(r2, t2);
        t2 += 2;
        var u = a2(r2, h, o + f, s);
        s.tabs.push(u);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t2 = 0; t2 < 32; t2++) 0 != (r2 >>> t2 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t2) {
      var a2 = e._bin, n = [], o = a2.readUshort(r2, t2);
      if (t2 += 2, 1 == o) {
        var s = a2.readUshort(r2, t2);
        t2 += 2;
        var i = a2.readUshort(r2, t2);
        t2 += 2;
        for (var h = 0; h < i; h++) n.push(s + h), n.push(s + h), n.push(a2.readUshort(r2, t2)), t2 += 2;
      }
      if (2 == o) {
        var d = a2.readUshort(r2, t2);
        t2 += 2;
        for (h = 0; h < d; h++) n.push(a2.readUshort(r2, t2)), t2 += 2, n.push(a2.readUshort(r2, t2)), t2 += 2, n.push(a2.readUshort(r2, t2)), t2 += 2;
      }
      return n;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t2 = 0; t2 < r2.length; t2 += 3) {
        var a2 = r2[t2], n = r2[t2 + 1];
        if (r2[t2 + 2], a2 <= e2 && e2 <= n) return t2;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.fmt = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      return t2 += 2, 1 == n.fmt && (n.tab = a2.readUshorts(r2, t2, o)), 2 == n.fmt && (n.tab = a2.readUshorts(r2, t2, 3 * o)), n;
    }, e._lctf.coverageIndex = function(r2, t2) {
      var a2 = r2.tab;
      if (1 == r2.fmt) return a2.indexOf(t2);
      if (2 == r2.fmt) {
        var n = e._lctf.getInterval(a2, t2);
        if (-1 != n) return a2[n + 2] + (t2 - a2[n]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t2) {
      var a2 = e._bin, n = t2, o = [], s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t2, 4);
        t2 += 4;
        var d = a2.readUshort(r2, t2);
        t2 += 2;
        var f = e._lctf.readFeatureTable(r2, n + d);
        f.tag = h.trim(), o.push(f);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {}, s = a2.readUshort(r2, t2);
      t2 += 2, s > 0 && (o.featureParams = n + s);
      var i = a2.readUshort(r2, t2);
      t2 += 2, o.tab = [];
      for (var h = 0; h < i; h++) o.tab.push(a2.readUshort(r2, t2 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {}, s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t2, 4);
        t2 += 4;
        var d = a2.readUshort(r2, t2);
        t2 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n + d);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {}, s = a2.readUshort(r2, t2);
      t2 += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r2, n + s));
      var i = a2.readUshort(r2, t2);
      t2 += 2;
      for (var h = 0; h < i; h++) {
        var d = a2.readASCII(r2, t2, 4);
        t2 += 4;
        var f = a2.readUshort(r2, t2);
        t2 += 2, o[d.trim()] = e._lctf.readLangSysTable(r2, n + f);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t2) {
      var a2 = e._bin, n = {};
      a2.readUshort(r2, t2), t2 += 2, n.reqFeature = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      return t2 += 2, n.features = a2.readUshorts(r2, t2, o), n;
    }, e.CFF = {}, e.CFF.parse = function(r2, t2, a2) {
      var n = e._bin;
      (r2 = new Uint8Array(r2.buffer, t2, a2))[t2 = 0], r2[++t2], r2[++t2], r2[++t2], t2++;
      var o = [];
      t2 = e.CFF.readIndex(r2, t2, o);
      for (var s = [], i = 0; i < o.length - 1; i++) s.push(n.readASCII(r2, t2 + o[i], o[i + 1] - o[i]));
      t2 += o[o.length - 1];
      var h = [];
      t2 = e.CFF.readIndex(r2, t2, h);
      var d = [];
      for (i = 0; i < h.length - 1; i++) d.push(e.CFF.readDict(r2, t2 + h[i], t2 + h[i + 1]));
      t2 += h[h.length - 1];
      var f = d[0], u = [];
      t2 = e.CFF.readIndex(r2, t2, u);
      var l = [];
      for (i = 0; i < u.length - 1; i++) l.push(n.readASCII(r2, t2 + u[i], u[i + 1] - u[i]));
      if (t2 += u[u.length - 1], e.CFF.readSubrs(r2, t2, f), f.CharStrings) {
        t2 = f.CharStrings;
        u = [];
        t2 = e.CFF.readIndex(r2, t2, u);
        var v4 = [];
        for (i = 0; i < u.length - 1; i++) v4.push(n.readBytes(r2, t2 + u[i], u[i + 1] - u[i]));
        f.CharStrings = v4;
      }
      if (f.ROS) {
        t2 = f.FDArray;
        var c = [];
        t2 = e.CFF.readIndex(r2, t2, c), f.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p = e.CFF.readDict(r2, t2 + c[i], t2 + c[i + 1]);
          e.CFF._readFDict(r2, p, l), f.FDArray.push(p);
        }
        t2 += c[c.length - 1], t2 = f.FDSelect, f.FDSelect = [];
        var U3 = r2[t2];
        if (t2++, 3 != U3) throw U3;
        var g = n.readUshort(r2, t2);
        t2 += 2;
        for (i = 0; i < g + 1; i++) f.FDSelect.push(n.readUshort(r2, t2), r2[t2 + 2]), t2 += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(r2, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r2, f.charset, f.CharStrings.length)), e.CFF._readFDict(r2, f, l), f;
    }, e.CFF._readFDict = function(r2, t2, a2) {
      var n;
      for (var o in t2.Private && (n = t2.Private[1], t2.Private = e.CFF.readDict(r2, n, n + t2.Private[0]), t2.Private.Subrs && e.CFF.readSubrs(r2, n + t2.Private.Subrs, t2.Private)), t2) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t2[o] = a2[t2[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t2, a2) {
      var n = e._bin, o = [];
      t2 = e.CFF.readIndex(r2, t2, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++) a2.Subrs.push(n.readBytes(r2, t2 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t2 = 0; t2 < r2.charset.length; t2++) if (r2.charset[t2] == e2) return t2;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t2) {
      return t2 < 0 || t2 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t2]);
    }, e.CFF.readEncoding = function(r2, t2, a2) {
      e._bin;
      var n = [".notdef"], o = r2[t2];
      if (t2++, 0 != o) throw "error: unknown encoding format: " + o;
      var s = r2[t2];
      t2++;
      for (var i = 0; i < s; i++) n.push(r2[t2 + i]);
      return n;
    }, e.CFF.readCharset = function(r2, t2, a2) {
      var n = e._bin, o = [".notdef"], s = r2[t2];
      if (t2++, 0 == s) for (var i = 0; i < a2; i++) {
        var h = n.readUshort(r2, t2);
        t2 += 2, o.push(h);
      }
      else {
        if (1 != s && 2 != s) throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n.readUshort(r2, t2);
          t2 += 2;
          var d = 0;
          1 == s ? (d = r2[t2], t2++) : (d = n.readUshort(r2, t2), t2 += 2);
          for (i = 0; i <= d; i++) o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t2, a2) {
      var n = e._bin, o = n.readUshort(r2, t2) + 1, s = r2[t2 += 2];
      if (t2++, 1 == s) for (var i = 0; i < o; i++) a2.push(r2[t2 + i]);
      else if (2 == s) for (i = 0; i < o; i++) a2.push(n.readUshort(r2, t2 + 2 * i));
      else if (3 == s) for (i = 0; i < o; i++) a2.push(16777215 & n.readUint(r2, t2 + 3 * i - 1));
      else if (1 != o) throw "unsupported offset size: " + s + ", count: " + o;
      return (t2 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t2, a2) {
      var n = e._bin, o = r2[t2], s = r2[t2 + 1];
      r2[t2 + 2], r2[t2 + 3], r2[t2 + 4];
      var i = 1, h = null, d = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n.readShort(r2, t2 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n.readInt(r2, t2 + 1) / 65535, i = 5), a2.val = null != d ? d : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t2, a2) {
      for (var n = t2 + a2, o = e._bin, s = []; t2 < n; ) {
        var i = r2[t2], h = r2[t2 + 1];
        r2[t2 + 2], r2[t2 + 3], r2[t2 + 4];
        var d = 1, f = null, u = null;
        i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u = o.readShort(r2, t2 + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u = o.readInt(r2, t2 + 1) / 65535, d = 5), s.push(null != u ? u : "o" + f), t2 += d;
      }
      return s;
    }, e.CFF.readDict = function(r2, t2, a2) {
      for (var n = e._bin, o = {}, s = []; t2 < a2; ) {
        var i = r2[t2], h = r2[t2 + 1];
        r2[t2 + 2], r2[t2 + 3], r2[t2 + 4];
        var d = 1, f = null, u = null;
        if (28 == i && (u = n.readShort(r2, t2 + 1), d = 3), 29 == i && (u = n.readInt(r2, t2 + 1), d = 5), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u = n.readInt(r2, t2 + 1) / 65535, d = 5, "unknown number";
        if (30 == i) {
          var l = [];
          for (d = 1; ; ) {
            var v4 = r2[t2 + d];
            d++;
            var c = v4 >> 4, p = 15 & v4;
            if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;
          }
          for (var U3 = "", g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++) U3 += g[l[S]];
          u = parseFloat(U3);
        }
        if (i <= 21) {
          if (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], d = 1, 12 == i) f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2;
        }
        null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u), t2 += d;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t2, a2) {
      r2 = new Uint8Array(r2.buffer, t2, a2), t2 = 0;
      var n = e._bin, o = {};
      n.readUshort(r2, t2), t2 += 2;
      var s = n.readUshort(r2, t2);
      t2 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var d = n.readUshort(r2, t2);
        t2 += 2;
        var f = n.readUshort(r2, t2);
        t2 += 2;
        var u = n.readUint(r2, t2);
        t2 += 4;
        var l = "p" + d + "e" + f, v4 = i.indexOf(u);
        if (-1 == v4) {
          var c;
          v4 = o.tables.length, i.push(u);
          var p = n.readUshort(r2, u);
          0 == p ? c = e.cmap.parse0(r2, u) : 4 == p ? c = e.cmap.parse4(r2, u) : 6 == p ? c = e.cmap.parse6(r2, u) : 12 == p ? c = e.cmap.parse12(r2, u) : console.debug("unknown format: " + p, d, f, u), o.tables.push(c);
        }
        if (null != o[l]) throw "multiple tables for one platform+encoding";
        o[l] = v4;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.format = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      t2 += 2, a2.readUshort(r2, t2), t2 += 2, n.map = [];
      for (var s = 0; s < o - 6; s++) n.map.push(r2[t2 + s]);
      return n;
    }, e.cmap.parse4 = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {};
      o.format = a2.readUshort(r2, t2), t2 += 2;
      var s = a2.readUshort(r2, t2);
      t2 += 2, a2.readUshort(r2, t2), t2 += 2;
      var i = a2.readUshort(r2, t2);
      t2 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t2), t2 += 2, o.entrySelector = a2.readUshort(r2, t2), t2 += 2, o.rangeShift = a2.readUshort(r2, t2), t2 += 2, o.endCount = a2.readUshorts(r2, t2, h), t2 += 2 * h, t2 += 2, o.startCount = a2.readUshorts(r2, t2, h), t2 += 2 * h, o.idDelta = [];
      for (var d = 0; d < h; d++) o.idDelta.push(a2.readShort(r2, t2)), t2 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t2, h), t2 += 2 * h, o.glyphIdArray = []; t2 < n + s; ) o.glyphIdArray.push(a2.readUshort(r2, t2)), t2 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.format = a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2, n.firstCode = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      t2 += 2, n.glyphIdArray = [];
      for (var s = 0; s < o; s++) n.glyphIdArray.push(a2.readUshort(r2, t2)), t2 += 2;
      return n;
    }, e.cmap.parse12 = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.format = a2.readUshort(r2, t2), t2 += 2, t2 += 2, a2.readUint(r2, t2), t2 += 4, a2.readUint(r2, t2), t2 += 4;
      var o = a2.readUint(r2, t2);
      t2 += 4, n.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t2 + 12 * s, h = a2.readUint(r2, i + 0), d = a2.readUint(r2, i + 4), f = a2.readUint(r2, i + 8);
        n.groups.push([h, d, f]);
      }
      return n;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t2, a2) {
      for (var n = [], o = 0; o < a2.maxp.numGlyphs; o++) n.push(null);
      return n;
    }, e.glyf._parseGlyf = function(r2, t2) {
      var a2 = e._bin, n = r2._data, o = e._tabOffset(n, "glyf", r2._offset) + r2.loca[t2];
      if (r2.loca[t2] == r2.loca[t2 + 1]) return null;
      var s = {};
      if (s.noc = a2.readShort(n, o), o += 2, s.xMin = a2.readShort(n, o), o += 2, s.yMin = a2.readShort(n, o), o += 2, s.xMax = a2.readShort(n, o), o += 2, s.yMax = a2.readShort(n, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++) s.endPts.push(a2.readUshort(n, o)), o += 2;
        var h = a2.readUshort(n, o);
        if (o += 2, n.length - o < h) return null;
        s.instructions = a2.readBytes(n, o, h), o += h;
        var d = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < d; i++) {
          var f = n[o];
          if (o++, s.flags.push(f), 0 != (8 & f)) {
            var u = n[o];
            o++;
            for (var l = 0; l < u; l++) s.flags.push(f), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < d; i++) {
          var v4 = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v4 ? (s.xs.push(c ? n[o] : -n[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < d; i++) {
          v4 = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v4 ? (s.ys.push(c ? n[o] : -n[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n, o)), o += 2);
        }
        var p = 0, U3 = 0;
        for (i = 0; i < d; i++) p += s.xs[i], U3 += s.ys[i], s.xs[i] = p, s.ys[i] = U3;
      } else {
        var g;
        s.parts = [];
        do {
          g = a2.readUshort(n, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n, o), o += 2, 1 & g) {
            var m2 = a2.readShort(n, o);
            o += 2;
            var b2 = a2.readShort(n, o);
            o += 2;
          } else {
            m2 = a2.readInt8(n, o);
            o++;
            b2 = a2.readInt8(n, o);
            o++;
          }
          2 & g ? (S.m.tx = m2, S.m.ty = b2) : (S.p1 = m2, S.p2 = b2), 8 & g ? (S.m.a = S.m.d = a2.readF2dot14(n, o), o += 2) : 64 & g ? (S.m.a = a2.readF2dot14(n, o), o += 2, S.m.d = a2.readF2dot14(n, o), o += 2) : 128 & g && (S.m.a = a2.readF2dot14(n, o), o += 2, S.m.b = a2.readF2dot14(n, o), o += 2, S.m.c = a2.readF2dot14(n, o), o += 2, S.m.d = a2.readF2dot14(n, o), o += 2);
        } while (32 & g);
        if (256 & g) {
          var y2 = a2.readUshort(n, o);
          o += 2, s.instr = [];
          for (i = 0; i < y2; i++) s.instr.push(n[o]), o++;
        }
      }
      return s;
    }, e.GDEF = {}, e.GDEF.parse = function(r2, t2, a2, n) {
      var o = t2;
      t2 += 4;
      var s = e._bin.readUshort(r2, t2);
      return { glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r2, o + s) };
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t2, a2, n) {
      return e._lctf.parse(r2, t2, a2, n, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t2, a2, n) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t2 || 2 == t2 || 3 == t2 || 7 == t2 || 8 == t2 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t2 && 1 == i.fmt) {
        var d = o.readUshort(r2, a2);
        a2 += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r2, a2, d));
      } else if (2 == t2 && i.fmt >= 1 && i.fmt <= 2) {
        d = o.readUshort(r2, a2);
        a2 += 2;
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var u = e._lctf.numOfOnes(d), l = e._lctf.numOfOnes(f);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v4 = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v4; c++) {
            var p = s + o.readUshort(r2, a2);
            a2 += 2;
            var U3 = o.readUshort(r2, p);
            p += 2;
            for (var g = [], S = 0; S < U3; S++) {
              var m2 = o.readUshort(r2, p);
              p += 2, 0 != d && (P2 = e.GPOS.readValueRecord(r2, p, d), p += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r2, p, f), p += 2 * l), g.push({ gid2: m2, val1: P2, val2: x });
            }
            i.pairsets.push(g);
          }
        }
        if (2 == i.fmt) {
          var b2 = o.readUshort(r2, a2);
          a2 += 2;
          var y2 = o.readUshort(r2, a2);
          a2 += 2;
          var F2 = o.readUshort(r2, a2);
          a2 += 2;
          var C2 = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b2), i.classDef2 = e._lctf.readClassDef(r2, s + y2), i.matrix = [];
          for (c = 0; c < F2; c++) {
            var _ = [];
            for (S = 0; S < C2; S++) {
              var P2 = null, x = null;
              0 != d && (P2 = e.GPOS.readValueRecord(r2, a2, d), a2 += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * l), _.push({ val1: P2, val2: x });
            }
            i.matrix.push(_);
          }
        }
      } else if (4 == t2 && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.baseCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.markArray = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.baseArray = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else if (6 == t2 && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.mark2Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.mark1Array = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else {
        if (9 == t2 && 1 == i.fmt) {
          var I2 = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n.ltype) n.ltype = I2;
          else if (n.ltype != I2) throw "invalid extension substitution";
          return e.GPOS.subt(r2, n.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t2, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t2, a2) {
      var n = e._bin, o = [];
      return o.push(1 & a2 ? n.readShort(r2, t2) : 0), t2 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n.readShort(r2, t2) : 0), t2 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n.readShort(r2, t2) : 0), t2 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n.readShort(r2, t2) : 0), t2 += 8 & a2 ? 2 : 0, o;
    }, e.GPOS.readBaseArray = function(r2, t2, a2) {
      var n = e._bin, o = [], s = t2, i = n.readUshort(r2, t2);
      t2 += 2;
      for (var h = 0; h < i; h++) {
        for (var d = [], f = 0; f < a2; f++) d.push(e.GPOS.readAnchorRecord(r2, s + n.readUshort(r2, t2))), t2 += 2;
        o.push(d);
      }
      return o;
    }, e.GPOS.readMarkArray = function(r2, t2) {
      var a2 = e._bin, n = [], o = t2, s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = e.GPOS.readAnchorRecord(r2, a2.readUshort(r2, t2 + 2) + o);
        h.markClass = a2.readUshort(r2, t2), n.push(h), t2 += 4;
      }
      return n;
    }, e.GPOS.readAnchorRecord = function(r2, t2) {
      var a2 = e._bin, n = {};
      return n.fmt = a2.readUshort(r2, t2), n.x = a2.readShort(r2, t2 + 2), n.y = a2.readShort(r2, t2 + 4), n;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t2, a2, n) {
      return e._lctf.parse(r2, t2, a2, n, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t2, a2, n) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t2 && 2 != t2 && 4 != t2 && 5 != t2 && 6 != t2) return null;
      if (1 == t2 || 2 == t2 || 4 == t2 || 5 == t2 && i.fmt <= 2 || 6 == t2 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t2 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt) i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var d = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, d), a2 += 2 * i.newg.length;
        }
      } else if (2 == t2 && 1 == i.fmt) {
        d = o.readUshort(r2, a2);
        a2 += 2, i.seqs = [];
        for (var f = 0; f < d; f++) {
          var u = o.readUshort(r2, a2) + s;
          a2 += 2;
          var l = o.readUshort(r2, u);
          i.seqs.push(o.readUshorts(r2, u + 2, l));
        }
      } else if (4 == t2) {
        i.vals = [];
        d = o.readUshort(r2, a2);
        a2 += 2;
        for (f = 0; f < d; f++) {
          var v4 = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + v4));
        }
      } else if (5 == t2 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var c = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + c), i.scset = [];
          var p = o.readUshort(r2, a2);
          a2 += 2;
          for (f = 0; f < p; f++) {
            var U3 = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == U3 ? null : e.GSUB.readSubClassSet(r2, s + U3));
          }
        }
      } else if (6 == t2 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (f = 0; f < 3; f++) {
            d = o.readUshort(r2, a2);
            a2 += 2;
            for (var g = [], S = 0; S < d; S++) g.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * S)));
            a2 += 2 * d, 0 == f && (i.backCvg = g), 1 == f && (i.inptCvg = g), 2 == f && (i.ahedCvg = g);
          }
          d = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, d);
        }
      } else {
        if (7 == t2 && 1 == i.fmt) {
          var m2 = o.readUshort(r2, a2);
          a2 += 2;
          var b2 = o.readUint(r2, a2);
          if (a2 += 4, 9 == n.ltype) n.ltype = m2;
          else if (n.ltype != m2) throw "invalid extension substitution";
          return e.GSUB.subt(r2, n.ltype, s + b2);
        }
        console.debug("unsupported GSUB table LookupType", t2, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t2) {
      var a2 = e._bin.readUshort, n = t2, o = [], s = a2(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t2);
        t2 += 2, o.push(e.GSUB.readSubClassRule(r2, n + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t2) {
      var a2 = e._bin.readUshort, n = {}, o = a2(r2, t2), s = a2(r2, t2 += 2);
      t2 += 2, n.input = [];
      for (var i = 0; i < o - 1; i++) n.input.push(a2(r2, t2)), t2 += 2;
      return n.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t2, s), n;
    }, e.GSUB.readSubstLookupRecords = function(r2, t2, a2) {
      for (var n = e._bin.readUshort, o = [], s = 0; s < a2; s++) o.push(n(r2, t2), n(r2, t2 + 2)), t2 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t2) {
      var a2 = e._bin, n = t2, o = [], s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t2);
        t2 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t2) {
      for (var a2 = e._bin, n = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t2);
        t2 += 2, 1 == s && i--, n[o[s]] = a2.readUshorts(r2, t2, i), t2 += 2 * n[o[s]].length;
      }
      i = a2.readUshort(r2, t2);
      return t2 += 2, n.subst = a2.readUshorts(r2, t2, 2 * i), t2 += 2 * n.subst.length, n;
    }, e.GSUB.readLigatureSet = function(r2, t2) {
      var a2 = e._bin, n = t2, o = [], s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t2);
        t2 += 2, o.push(e.GSUB.readLigature(r2, n + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t2) {
      var a2 = e._bin, n = { chain: [] };
      n.nglyph = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      t2 += 2;
      for (var s = 0; s < o - 1; s++) n.chain.push(a2.readUshort(r2, t2)), t2 += 2;
      return n;
    }, e.head = {}, e.head.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      return n.readFixed(r2, t2), t2 += 4, o.fontRevision = n.readFixed(r2, t2), t2 += 4, n.readUint(r2, t2), t2 += 4, n.readUint(r2, t2), t2 += 4, o.flags = n.readUshort(r2, t2), t2 += 2, o.unitsPerEm = n.readUshort(r2, t2), t2 += 2, o.created = n.readUint64(r2, t2), t2 += 8, o.modified = n.readUint64(r2, t2), t2 += 8, o.xMin = n.readShort(r2, t2), t2 += 2, o.yMin = n.readShort(r2, t2), t2 += 2, o.xMax = n.readShort(r2, t2), t2 += 2, o.yMax = n.readShort(r2, t2), t2 += 2, o.macStyle = n.readUshort(r2, t2), t2 += 2, o.lowestRecPPEM = n.readUshort(r2, t2), t2 += 2, o.fontDirectionHint = n.readShort(r2, t2), t2 += 2, o.indexToLocFormat = n.readShort(r2, t2), t2 += 2, o.glyphDataFormat = n.readShort(r2, t2), t2 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      return n.readFixed(r2, t2), t2 += 4, o.ascender = n.readShort(r2, t2), t2 += 2, o.descender = n.readShort(r2, t2), t2 += 2, o.lineGap = n.readShort(r2, t2), t2 += 2, o.advanceWidthMax = n.readUshort(r2, t2), t2 += 2, o.minLeftSideBearing = n.readShort(r2, t2), t2 += 2, o.minRightSideBearing = n.readShort(r2, t2), t2 += 2, o.xMaxExtent = n.readShort(r2, t2), t2 += 2, o.caretSlopeRise = n.readShort(r2, t2), t2 += 2, o.caretSlopeRun = n.readShort(r2, t2), t2 += 2, o.caretOffset = n.readShort(r2, t2), t2 += 2, t2 += 8, o.metricDataFormat = n.readShort(r2, t2), t2 += 2, o.numberOfHMetrics = n.readUshort(r2, t2), t2 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t2, a2, n) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, d = 0; d < n.maxp.numGlyphs; d++) d < n.hhea.numberOfHMetrics && (i = o.readUshort(r2, t2), t2 += 2, h = o.readShort(r2, t2), t2 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t2, a2, n) {
      var o = e._bin, s = o.readUshort(r2, t2);
      if (t2 += 2, 1 == s) return e.kern.parseV1(r2, t2 - 2, a2, n);
      var i = o.readUshort(r2, t2);
      t2 += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < i; d++) {
        t2 += 2;
        a2 = o.readUshort(r2, t2);
        t2 += 2;
        var f = o.readUshort(r2, t2);
        t2 += 2;
        var u = f >>> 8;
        if (0 != (u &= 15)) throw "unknown kern table format: " + u;
        t2 = e.kern.readFormat0(r2, t2, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t2, a2, n) {
      var o = e._bin;
      o.readFixed(r2, t2), t2 += 4;
      var s = o.readUint(r2, t2);
      t2 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t2), t2 += 4;
        var d = o.readUshort(r2, t2);
        t2 += 2, o.readUshort(r2, t2), t2 += 2;
        var f = d >>> 8;
        if (0 != (f &= 15)) throw "unknown kern table format: " + f;
        t2 = e.kern.readFormat0(r2, t2, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t2, a2) {
      var n = e._bin, o = -1, s = n.readUshort(r2, t2);
      t2 += 2, n.readUshort(r2, t2), t2 += 2, n.readUshort(r2, t2), t2 += 2, n.readUshort(r2, t2), t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = n.readUshort(r2, t2);
        t2 += 2;
        var d = n.readUshort(r2, t2);
        t2 += 2;
        var f = n.readShort(r2, t2);
        t2 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var u = a2.rval[a2.rval.length - 1];
        u.glyph2.push(d), u.vals.push(f), o = h;
      }
      return t2;
    }, e.loca = {}, e.loca.parse = function(r2, t2, a2, n) {
      var o = e._bin, s = [], i = n.head.indexToLocFormat, h = n.maxp.numGlyphs + 1;
      if (0 == i) for (var d = 0; d < h; d++) s.push(o.readUshort(r2, t2 + (d << 1)) << 1);
      if (1 == i) for (d = 0; d < h; d++) s.push(o.readUint(r2, t2 + (d << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t2, a2) {
      var n = e._bin, o = {}, s = n.readUint(r2, t2);
      return t2 += 4, o.numGlyphs = n.readUshort(r2, t2), t2 += 2, 65536 == s && (o.maxPoints = n.readUshort(r2, t2), t2 += 2, o.maxContours = n.readUshort(r2, t2), t2 += 2, o.maxCompositePoints = n.readUshort(r2, t2), t2 += 2, o.maxCompositeContours = n.readUshort(r2, t2), t2 += 2, o.maxZones = n.readUshort(r2, t2), t2 += 2, o.maxTwilightPoints = n.readUshort(r2, t2), t2 += 2, o.maxStorage = n.readUshort(r2, t2), t2 += 2, o.maxFunctionDefs = n.readUshort(r2, t2), t2 += 2, o.maxInstructionDefs = n.readUshort(r2, t2), t2 += 2, o.maxStackElements = n.readUshort(r2, t2), t2 += 2, o.maxSizeOfInstructions = n.readUshort(r2, t2), t2 += 2, o.maxComponentElements = n.readUshort(r2, t2), t2 += 2, o.maxComponentDepth = n.readUshort(r2, t2), t2 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      n.readUshort(r2, t2), t2 += 2;
      var s = n.readUshort(r2, t2);
      t2 += 2, n.readUshort(r2, t2);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = t2 += 2, f = 0; f < s; f++) {
        var u = n.readUshort(r2, t2);
        t2 += 2;
        var l = n.readUshort(r2, t2);
        t2 += 2;
        var v4 = n.readUshort(r2, t2);
        t2 += 2;
        var c = n.readUshort(r2, t2);
        t2 += 2;
        var p = n.readUshort(r2, t2);
        t2 += 2;
        var U3 = n.readUshort(r2, t2);
        t2 += 2;
        var g, S = h[c], m2 = d + 12 * s + U3;
        if (0 == u) g = n.readUnicode(r2, m2, p / 2);
        else if (3 == u && 0 == l) g = n.readUnicode(r2, m2, p / 2);
        else if (0 == l) g = n.readASCII(r2, m2, p);
        else if (1 == l) g = n.readUnicode(r2, m2, p / 2);
        else if (3 == l) g = n.readUnicode(r2, m2, p / 2);
        else {
          if (1 != u) throw "unknown encoding " + l + ", platformID: " + u;
          g = n.readASCII(r2, m2, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b2 = "p" + u + "," + v4.toString(16);
        null == o[b2] && (o[b2] = {}), o[b2][void 0 !== S ? S : c] = g, o[b2]._lang = v4;
      }
      for (var y2 in o) if (null != o[y2].postScriptName && 1033 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName && 0 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName && 3084 == o[y2]._lang) return o[y2];
      for (var y2 in o) if (null != o[y2].postScriptName) return o[y2];
      for (var y2 in o) {
        i = y2;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t2, a2) {
      var n = e._bin.readUshort(r2, t2);
      t2 += 2;
      var o = {};
      if (0 == n) e["OS/2"].version0(r2, t2, o);
      else if (1 == n) e["OS/2"].version1(r2, t2, o);
      else if (2 == n || 3 == n || 4 == n) e["OS/2"].version2(r2, t2, o);
      else {
        if (5 != n) throw "unknown OS/2 table version: " + n;
        e["OS/2"].version5(r2, t2, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t2, a2) {
      var n = e._bin;
      return a2.xAvgCharWidth = n.readShort(r2, t2), t2 += 2, a2.usWeightClass = n.readUshort(r2, t2), t2 += 2, a2.usWidthClass = n.readUshort(r2, t2), t2 += 2, a2.fsType = n.readUshort(r2, t2), t2 += 2, a2.ySubscriptXSize = n.readShort(r2, t2), t2 += 2, a2.ySubscriptYSize = n.readShort(r2, t2), t2 += 2, a2.ySubscriptXOffset = n.readShort(r2, t2), t2 += 2, a2.ySubscriptYOffset = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptXSize = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptYSize = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptXOffset = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptYOffset = n.readShort(r2, t2), t2 += 2, a2.yStrikeoutSize = n.readShort(r2, t2), t2 += 2, a2.yStrikeoutPosition = n.readShort(r2, t2), t2 += 2, a2.sFamilyClass = n.readShort(r2, t2), t2 += 2, a2.panose = n.readBytes(r2, t2, 10), t2 += 10, a2.ulUnicodeRange1 = n.readUint(r2, t2), t2 += 4, a2.ulUnicodeRange2 = n.readUint(r2, t2), t2 += 4, a2.ulUnicodeRange3 = n.readUint(r2, t2), t2 += 4, a2.ulUnicodeRange4 = n.readUint(r2, t2), t2 += 4, a2.achVendID = [n.readInt8(r2, t2), n.readInt8(r2, t2 + 1), n.readInt8(r2, t2 + 2), n.readInt8(r2, t2 + 3)], t2 += 4, a2.fsSelection = n.readUshort(r2, t2), t2 += 2, a2.usFirstCharIndex = n.readUshort(r2, t2), t2 += 2, a2.usLastCharIndex = n.readUshort(r2, t2), t2 += 2, a2.sTypoAscender = n.readShort(r2, t2), t2 += 2, a2.sTypoDescender = n.readShort(r2, t2), t2 += 2, a2.sTypoLineGap = n.readShort(r2, t2), t2 += 2, a2.usWinAscent = n.readUshort(r2, t2), t2 += 2, a2.usWinDescent = n.readUshort(r2, t2), t2 += 2;
    }, e["OS/2"].version1 = function(r2, t2, a2) {
      var n = e._bin;
      return t2 = e["OS/2"].version0(r2, t2, a2), a2.ulCodePageRange1 = n.readUint(r2, t2), t2 += 4, a2.ulCodePageRange2 = n.readUint(r2, t2), t2 += 4;
    }, e["OS/2"].version2 = function(r2, t2, a2) {
      var n = e._bin;
      return t2 = e["OS/2"].version1(r2, t2, a2), a2.sxHeight = n.readShort(r2, t2), t2 += 2, a2.sCapHeight = n.readShort(r2, t2), t2 += 2, a2.usDefault = n.readUshort(r2, t2), t2 += 2, a2.usBreak = n.readUshort(r2, t2), t2 += 2, a2.usMaxContext = n.readUshort(r2, t2), t2 += 2;
    }, e["OS/2"].version5 = function(r2, t2, a2) {
      var n = e._bin;
      return t2 = e["OS/2"].version2(r2, t2, a2), a2.usLowerOpticalPointSize = n.readUshort(r2, t2), t2 += 2, a2.usUpperOpticalPointSize = n.readUshort(r2, t2), t2 += 2;
    }, e.post = {}, e.post.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      return o.version = n.readFixed(r2, t2), t2 += 4, o.italicAngle = n.readFixed(r2, t2), t2 += 4, o.underlinePosition = n.readShort(r2, t2), t2 += 2, o.underlineThickness = n.readShort(r2, t2), t2 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t2 = r2.cmap, a2 = -1;
      if (null != t2.p0e4 ? a2 = t2.p0e4 : null != t2.p3e1 ? a2 = t2.p3e1 : null != t2.p1e0 ? a2 = t2.p1e0 : null != t2.p0e3 && (a2 = t2.p0e3), -1 == a2) throw "no familiar platform and encoding!";
      var n = t2.tables[a2];
      if (0 == n.format) return e2 >= n.map.length ? 0 : n.map[e2];
      if (4 == n.format) {
        for (var o = -1, s = 0; s < n.endCount.length; s++) if (e2 <= n.endCount[s]) {
          o = s;
          break;
        }
        if (-1 == o) return 0;
        if (n.startCount[o] > e2) return 0;
        return 65535 & (0 != n.idRangeOffset[o] ? n.glyphIdArray[e2 - n.startCount[o] + (n.idRangeOffset[o] >> 1) - (n.idRangeOffset.length - o)] : e2 + n.idDelta[o]);
      }
      if (12 == n.format) {
        if (e2 > n.groups[n.groups.length - 1][1]) return 0;
        for (s = 0; s < n.groups.length; s++) {
          var i = n.groups[s];
          if (i[0] <= e2 && e2 <= i[1]) return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n.format;
    }, e.U.glyphToPath = function(r2, t2) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t2]) {
        var n = r2.SVG.entries[t2];
        return null == n ? a2 : ("string" == typeof n && (n = e.SVG.toPath(n), r2.SVG.entries[t2] = n), n);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t2; ) h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t2], o, s, i, a2);
      } else r2.glyf && e.U._drawGlyf(t2, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t2, a2) {
      var n = t2.glyf[r2];
      null == n && (n = t2.glyf[r2] = e.glyf._parseGlyf(t2, r2)), null != n && (n.noc > -1 ? e.U._simpleGlyph(n, a2) : e.U._compoGlyph(n, t2, a2));
    }, e.U._simpleGlyph = function(r2, t2) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n; s <= o; s++) {
          var i = s == n ? o : s - 1, h = s == o ? n : s + 1, d = 1 & r2.flags[s], f = 1 & r2.flags[i], u = 1 & r2.flags[h], l = r2.xs[s], v4 = r2.ys[s];
          if (s == n) if (d) {
            if (!f) {
              e.U.P.moveTo(t2, l, v4);
              continue;
            }
            e.U.P.moveTo(t2, r2.xs[i], r2.ys[i]);
          } else f ? e.U.P.moveTo(t2, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t2, (r2.xs[i] + l) / 2, (r2.ys[i] + v4) / 2);
          d ? f && e.U.P.lineTo(t2, l, v4) : u ? e.U.P.qcurveTo(t2, l, v4, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t2, l, v4, (l + r2.xs[h]) / 2, (v4 + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t2);
      }
    }, e.U._compoGlyph = function(r2, t2, a2) {
      for (var n = 0; n < r2.parts.length; n++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n];
        e.U._drawGlyf(s.glyphIndex, t2, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var d = o.crds[h], f = o.crds[h + 1];
          a2.crds.push(d * i.a + f * i.b + i.tx), a2.crds.push(d * i.c + f * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++) a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t2) {
      var a2 = e._lctf.getInterval(t2, r2);
      return -1 == a2 ? 0 : t2[a2 + 2];
    }, e.U._applySubs = function(r2, t2, a2, n) {
      for (var o = r2.length - t2 - 1, s = 0; s < a2.tabs.length; s++) if (null != a2.tabs[s]) {
        var i, h = a2.tabs[s];
        if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t2]))) {
          if (1 == a2.ltype) r2[t2], 1 == h.fmt ? r2[t2] = r2[t2] + h.delta : r2[t2] = h.newg[i];
          else if (4 == a2.ltype) for (var d = h.vals[i], f = 0; f < d.length; f++) {
            var u = d[f], l = u.chain.length;
            if (!(l > o)) {
              for (var v4 = true, c = 0, p = 0; p < l; p++) {
                for (; -1 == r2[t2 + c + (1 + p)]; ) c++;
                u.chain[p] != r2[t2 + c + (1 + p)] && (v4 = false);
              }
              if (v4) {
                r2[t2] = u.nglyph;
                for (p = 0; p < l + c; p++) r2[t2 + p + 1] = -1;
                break;
              }
            }
          }
          else if (5 == a2.ltype && 2 == h.fmt) for (var U3 = e._lctf.getInterval(h.cDef, r2[t2]), g = h.cDef[U3 + 2], S = h.scset[g], m2 = 0; m2 < S.length; m2++) {
            var b2 = S[m2], y2 = b2.input;
            if (!(y2.length > o)) {
              for (v4 = true, p = 0; p < y2.length; p++) {
                var F2 = e._lctf.getInterval(h.cDef, r2[t2 + 1 + p]);
                if (-1 == U3 && h.cDef[F2 + 2] != y2[p]) {
                  v4 = false;
                  break;
                }
              }
              if (v4) {
                var C2 = b2.substLookupRecords;
                for (f = 0; f < C2.length; f += 2) C2[f], C2[f + 1];
              }
            }
          }
          else if (6 == a2.ltype && 3 == h.fmt) {
            if (!e.U._glsCovered(r2, h.backCvg, t2 - h.backCvg.length)) continue;
            if (!e.U._glsCovered(r2, h.inptCvg, t2)) continue;
            if (!e.U._glsCovered(r2, h.ahedCvg, t2 + h.inptCvg.length)) continue;
            var _ = h.lookupRec;
            for (m2 = 0; m2 < _.length; m2 += 2) {
              U3 = _[m2];
              var P2 = n[_[m2 + 1]];
              e.U._applySubs(r2, t2 + U3, P2, n);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r2, t2, a2) {
      for (var n = 0; n < t2.length; n++) {
        if (-1 == e._lctf.coverageIndex(t2[n], r2[a2 + n])) return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t2, a2) {
      for (var n = { cmds: [], crds: [] }, o = 0, s = 0; s < t2.length; s++) {
        var i = t2[s];
        if (-1 != i) {
          for (var h = s < t2.length - 1 && -1 != t2[s + 1] ? t2[s + 1] : 0, d = e.U.glyphToPath(r2, i), f = 0; f < d.crds.length; f += 2) n.crds.push(d.crds[f] + o), n.crds.push(d.crds[f + 1]);
          a2 && n.cmds.push(a2);
          for (f = 0; f < d.cmds.length; f++) n.cmds.push(d.cmds[f]);
          a2 && n.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t2.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t2) {
      r2.cmds.push("M"), r2.crds.push(e2, t2);
    }, e.U.P.lineTo = function(r2, e2, t2) {
      r2.cmds.push("L"), r2.crds.push(e2, t2);
    }, e.U.P.curveTo = function(r2, e2, t2, a2, n, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t2, a2, n, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t2, a2, n) {
      r2.cmds.push("Q"), r2.crds.push(e2, t2, a2, n);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t2, a2, n, o) {
      for (var s = t2.stack, i = t2.nStems, h = t2.haveWidth, d = t2.width, f = t2.open, u = 0, l = t2.x, v4 = t2.y, c = 0, p = 0, U3 = 0, g = 0, S = 0, m2 = 0, b2 = 0, y2 = 0, F2 = 0, C2 = 0, _ = { val: 0, size: 0 }; u < r2.length; ) {
        e.CFF.getCharString(r2, u, _);
        var P2 = _.val;
        if (u += _.size, "o1" == P2 || "o18" == P2) s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == P2 || "o23" == P2) {
          s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == P2) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = true), f && e.U.P.closePath(o), v4 += s.pop(), e.U.P.moveTo(o, l, v4), f = true;
        else if ("o5" == P2) for (; s.length > 0; ) l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4);
        else if ("o6" == P2 || "o7" == P2) for (var x = s.length, I2 = "o6" == P2, w = 0; w < x; w++) {
          var k3 = s.shift();
          I2 ? l += k3 : v4 += k3, I2 = !I2, e.U.P.lineTo(o, l, v4);
        }
        else if ("o8" == P2 || "o24" == P2) {
          x = s.length;
          for (var G2 = 0; G2 + 6 <= x; ) c = l + s.shift(), p = v4 + s.shift(), U3 = c + s.shift(), g = p + s.shift(), l = U3 + s.shift(), v4 = g + s.shift(), e.U.P.curveTo(o, c, p, U3, g, l, v4), G2 += 6;
          "o24" == P2 && (l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4));
        } else {
          if ("o11" == P2) break;
          if ("o1234" == P2 || "o1235" == P2 || "o1236" == P2 || "o1237" == P2) "o1234" == P2 && (p = v4, U3 = (c = l + s.shift()) + s.shift(), C2 = g = p + s.shift(), m2 = g, y2 = v4, l = (b2 = (S = (F2 = U3 + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U3, g, F2, C2), e.U.P.curveTo(o, S, m2, b2, y2, l, v4)), "o1235" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U3 = c + s.shift(), g = p + s.shift(), F2 = U3 + s.shift(), C2 = g + s.shift(), S = F2 + s.shift(), m2 = C2 + s.shift(), b2 = S + s.shift(), y2 = m2 + s.shift(), l = b2 + s.shift(), v4 = y2 + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U3, g, F2, C2), e.U.P.curveTo(o, S, m2, b2, y2, l, v4)), "o1236" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U3 = c + s.shift(), C2 = g = p + s.shift(), m2 = g, b2 = (S = (F2 = U3 + s.shift()) + s.shift()) + s.shift(), y2 = m2 + s.shift(), l = b2 + s.shift(), e.U.P.curveTo(o, c, p, U3, g, F2, C2), e.U.P.curveTo(o, S, m2, b2, y2, l, v4)), "o1237" == P2 && (c = l + s.shift(), p = v4 + s.shift(), U3 = c + s.shift(), g = p + s.shift(), F2 = U3 + s.shift(), C2 = g + s.shift(), S = F2 + s.shift(), m2 = C2 + s.shift(), b2 = S + s.shift(), y2 = m2 + s.shift(), Math.abs(b2 - l) > Math.abs(y2 - v4) ? l = b2 + s.shift() : v4 = y2 + s.shift(), e.U.P.curveTo(o, c, p, U3, g, F2, C2), e.U.P.curveTo(o, S, m2, b2, y2, l, v4));
          else if ("o14" == P2) {
            if (s.length > 0 && !h && (d = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var O3 = s.shift(), T4 = s.shift(), D2 = s.shift(), B2 = s.shift(), A2 = e.CFF.glyphBySE(a2, D2), R2 = e.CFF.glyphBySE(a2, B2);
              e.U._drawCFF(a2.CharStrings[A2], t2, a2, n, o), t2.x = O3, t2.y = T4, e.U._drawCFF(a2.CharStrings[R2], t2, a2, n, o);
            }
            f && (e.U.P.closePath(o), f = false);
          } else if ("o19" == P2 || "o20" == P2) {
            s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, u += i + 7 >> 3;
          } else if ("o21" == P2) s.length > 2 && !h && (d = s.shift() + n.nominalWidthX, h = true), v4 += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v4), f = true;
          else if ("o22" == P2) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = true), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v4), f = true;
          else if ("o25" == P2) {
            for (; s.length > 6; ) l += s.shift(), v4 += s.shift(), e.U.P.lineTo(o, l, v4);
            c = l + s.shift(), p = v4 + s.shift(), U3 = c + s.shift(), g = p + s.shift(), l = U3 + s.shift(), v4 = g + s.shift(), e.U.P.curveTo(o, c, p, U3, g, l, v4);
          } else if ("o26" == P2) for (s.length % 2 && (l += s.shift()); s.length > 0; ) c = l, p = v4 + s.shift(), l = U3 = c + s.shift(), v4 = (g = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U3, g, l, v4);
          else if ("o27" == P2) for (s.length % 2 && (v4 += s.shift()); s.length > 0; ) p = v4, U3 = (c = l + s.shift()) + s.shift(), g = p + s.shift(), l = U3 + s.shift(), v4 = g, e.U.P.curveTo(o, c, p, U3, g, l, v4);
          else if ("o10" == P2 || "o29" == P2) {
            var L2 = "o10" == P2 ? n : a2;
            if (0 == s.length) console.debug("error: empty stack");
            else {
              var W2 = s.pop(), M3 = L2.Subrs[W2 + L2.Bias];
              t2.x = l, t2.y = v4, t2.nStems = i, t2.haveWidth = h, t2.width = d, t2.open = f, e.U._drawCFF(M3, t2, a2, n, o), l = t2.x, v4 = t2.y, i = t2.nStems, h = t2.haveWidth, d = t2.width, f = t2.open;
            }
          } else if ("o30" == P2 || "o31" == P2) {
            var V3 = s.length, E2 = (G2 = 0, "o31" == P2);
            for (G2 += V3 - (x = -3 & V3); G2 < x; ) E2 ? (p = v4, U3 = (c = l + s.shift()) + s.shift(), v4 = (g = p + s.shift()) + s.shift(), x - G2 == 5 ? (l = U3 + s.shift(), G2++) : l = U3, E2 = false) : (c = l, p = v4 + s.shift(), U3 = c + s.shift(), g = p + s.shift(), l = U3 + s.shift(), x - G2 == 5 ? (v4 = g + s.shift(), G2++) : v4 = g, E2 = true), e.U.P.curveTo(o, c, p, U3, g, l, v4), G2 += 4;
          } else {
            if ("o" == (P2 + "").charAt(0)) throw console.debug("Unknown operation: " + P2, r2), P2;
            s.push(P2);
          }
        }
      }
      t2.x = l, t2.y = v4, t2.nStems = i, t2.haveWidth = h, t2.width = d, t2.open = f;
    };
    var t = e, a = { Typr: t };
    return r.Typr = t, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  })({}).Typr;
}
function woff2otfFactory() {
  return (function(r) {
    var e = Uint8Array, n = Uint16Array, t = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n(31), i2 = 0; i2 < 31; ++i2) a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t(a2[30]);
      for (i2 = 1; i2 < 30; ++i2) for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2) o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u = f(a, 2), v4 = u[0], s = u[1];
    v4[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n(32768), g = 0; g < 32768; ++g) {
      var h = (43690 & g) >>> 1 | (21845 & g) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t2) {
      for (var a2 = r2.length, i2 = 0, o2 = new n(e2); i2 < a2; ++i2) ++o2[r2[i2] - 1];
      var f2, u2 = new n(e2);
      for (i2 = 0; i2 < e2; ++i2) u2[i2] = u2[i2 - 1] + o2[i2 - 1] << 1;
      if (t2) {
        f2 = new n(1 << e2);
        var v5 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2) if (r2[i2]) for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g2 = u2[r2[i2] - 1]++ << l2, h2 = g2 | (1 << l2) - 1; g2 <= h2; ++g2) f2[c[g2] >>> v5] = s2;
      } else for (f2 = new n(a2), i2 = 0; i2 < a2; ++i2) r2[i2] && (f2[i2] = c[u2[r2[i2] - 1]++] >>> 15 - r2[i2]);
      return f2;
    }, d = new e(288);
    for (g = 0; g < 144; ++g) d[g] = 8;
    for (g = 144; g < 256; ++g) d[g] = 9;
    for (g = 256; g < 280; ++g) d[g] = 7;
    for (g = 280; g < 288; ++g) d[g] = 8;
    var m2 = new e(32);
    for (g = 0; g < 32; ++g) m2[g] = 5;
    var b2 = w(d, 9, 1), p = w(m2, 5, 1), y2 = function(r2) {
      for (var e2 = r2[0], n2 = 1; n2 < r2.length; ++n2) r2[n2] > e2 && (e2 = r2[n2]);
      return e2;
    }, L2 = function(r2, e2, n2) {
      var t2 = e2 / 8 | 0;
      return (r2[t2] | r2[t2 + 1] << 8) >> (7 & e2) & n2;
    }, U3 = function(r2, e2) {
      var n2 = e2 / 8 | 0;
      return (r2[n2] | r2[n2 + 1] << 8 | r2[n2 + 2] << 16) >> (7 & e2);
    }, k3 = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T4 = function(r2, e2, n2) {
      var t2 = new Error(e2 || k3[r2]);
      if (t2.code = r2, Error.captureStackTrace && Error.captureStackTrace(t2, T4), !n2) throw t2;
      return t2;
    }, O3 = function(r2, f2, u2) {
      var s2 = r2.length;
      if (!s2 || u2 && !u2.l && s2 < 5) return f2 || new e(0);
      var c2 = !f2 || u2, g2 = !u2 || u2.i;
      u2 || (u2 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n2 = f2.length;
        if (r3 > n2) {
          var t2 = new e(Math.max(2 * n2, r3));
          t2.set(f2), f2 = t2;
        }
      }, m3 = u2.f || 0, k4 = u2.p || 0, O4 = u2.b || 0, A3 = u2.l, x2 = u2.d, E2 = u2.m, D2 = u2.n, M3 = 8 * s2;
      do {
        if (!A3) {
          u2.f = m3 = L2(r2, k4, 1);
          var S = L2(r2, k4 + 1, 3);
          if (k4 += 3, !S) {
            var V3 = r2[(I2 = ((h2 = k4) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I2 - 3] << 8, _ = I2 + V3;
            if (_ > s2) {
              g2 && T4(0);
              break;
            }
            c2 && d2(O4 + V3), f2.set(r2.subarray(I2, _), O4), u2.b = O4 += V3, u2.p = k4 = 8 * _;
            continue;
          }
          if (1 == S) A3 = b2, x2 = p, E2 = 9, D2 = 5;
          else if (2 == S) {
            var j3 = L2(r2, k4, 31) + 257, z2 = L2(r2, k4 + 10, 15) + 4, C2 = j3 + L2(r2, k4 + 5, 31) + 1;
            k4 += 14;
            for (var F2 = new e(C2), P2 = new e(19), q3 = 0; q3 < z2; ++q3) P2[o[q3]] = L2(r2, k4 + 3 * q3, 7);
            k4 += 3 * z2;
            var B2 = y2(P2), G2 = (1 << B2) - 1, H3 = w(P2, B2, 1);
            for (q3 = 0; q3 < C2; ) {
              var I2, J2 = H3[L2(r2, k4, G2)];
              if (k4 += 15 & J2, (I2 = J2 >>> 4) < 16) F2[q3++] = I2;
              else {
                var K3 = 0, N3 = 0;
                for (16 == I2 ? (N3 = 3 + L2(r2, k4, 3), k4 += 2, K3 = F2[q3 - 1]) : 17 == I2 ? (N3 = 3 + L2(r2, k4, 7), k4 += 3) : 18 == I2 && (N3 = 11 + L2(r2, k4, 127), k4 += 7); N3--; ) F2[q3++] = K3;
              }
            }
            var Q3 = F2.subarray(0, j3), R2 = F2.subarray(j3);
            E2 = y2(Q3), D2 = y2(R2), A3 = w(Q3, E2, 1), x2 = w(R2, D2, 1);
          } else T4(1);
          if (k4 > M3) {
            g2 && T4(0);
            break;
          }
        }
        c2 && d2(O4 + 131072);
        for (var W2 = (1 << E2) - 1, X3 = (1 << D2) - 1, Y3 = k4; ; Y3 = k4) {
          var Z2 = (K3 = A3[U3(r2, k4) & W2]) >>> 4;
          if ((k4 += 15 & K3) > M3) {
            g2 && T4(0);
            break;
          }
          if (K3 || T4(2), Z2 < 256) f2[O4++] = Z2;
          else {
            if (256 == Z2) {
              Y3 = k4, A3 = null;
              break;
            }
            var $3 = Z2 - 254;
            if (Z2 > 264) {
              var rr = a[q3 = Z2 - 257];
              $3 = L2(r2, k4, (1 << rr) - 1) + v4[q3], k4 += rr;
            }
            var er = x2[U3(r2, k4) & X3], nr = er >>> 4;
            er || T4(3), k4 += 15 & er;
            R2 = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R2 += U3(r2, k4) & (1 << rr) - 1, k4 += rr;
            }
            if (k4 > M3) {
              g2 && T4(0);
              break;
            }
            c2 && d2(O4 + 131072);
            for (var tr = O4 + $3; O4 < tr; O4 += 4) f2[O4] = f2[O4 - R2], f2[O4 + 1] = f2[O4 + 1 - R2], f2[O4 + 2] = f2[O4 + 2 - R2], f2[O4 + 3] = f2[O4 + 3 - R2];
            O4 = tr;
          }
        }
        u2.l = A3, u2.p = Y3, u2.b = O4, A3 && (m3 = 1, u2.m = E2, u2.d = x2, u2.n = D2);
      } while (!m3);
      return O4 == f2.length ? f2 : (function(r3, a2, i2) {
        (null == a2 || a2 < 0) && (a2 = 0), (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n ? n : r3 instanceof t ? t : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      })(f2, 0, O4);
    }, A2 = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A2, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n2 = 0;
      function t2() {
        var r3 = e2.getUint16(n2);
        return n2 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n2);
        return n2 += 4, r3;
      }
      function i2(r3) {
        m3.setUint16(b3, r3), b3 += 2;
      }
      function o2(r3) {
        m3.setUint32(b3, r3), b3 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t2(), reserved: t2(), totalSfntSize: a2(), majorVersion: t2(), minorVersion: t2(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u2 = 0; Math.pow(2, u2) <= f2.numTables; ) u2++;
      u2--;
      for (var v5 = 16 * Math.pow(2, u2), s2 = 16 * f2.numTables - v5, l2 = 12, c2 = [], g2 = 0; g2 < f2.numTables; g2++) c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce((function(r3, e3) {
        return r3 + e3.origLength + 4;
      }), 0)), d2 = w2.buffer, m3 = new DataView(d2), b3 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v5), i2(u2), i2(s2), c2.forEach((function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      })), c2.forEach((function(e3) {
        var n3, t3 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n3 = new Uint8Array(t3, 2), O3(n3, a3);
        } else a3 = new Uint8Array(t3);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      })), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  })({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m2 = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m2[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m2[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535) i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535) i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]]) continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function calcGlyphPositions(font, glyphIds) {
    const positions = new Int16Array(glyphIds.length * 3);
    let glyphIndex = 0;
    for (; glyphIndex < glyphIds.length; glyphIndex++) {
      const glyphId = glyphIds[glyphIndex];
      if (glyphId === -1) continue;
      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId];
      const gpos = font.GPOS;
      if (gpos) {
        const llist = gpos.lookupList;
        for (let i = 0; i < llist.length; i++) {
          const lookup = llist[i];
          for (let j3 = 0; j3 < lookup.tabs.length; j3++) {
            const tab = lookup.tabs[j3];
            if (lookup.ltype === 1) {
              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);
              if (ind !== -1 && tab.pos) {
                applyValueRecord(tab.pos, glyphIndex);
                break;
              }
            } else if (lookup.ltype === 2) {
              let adj = null;
              let prevGlyphIndex = getPrevGlyphIndex();
              if (prevGlyphIndex !== -1) {
                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);
                if (coverageIndex !== -1) {
                  if (tab.fmt === 1) {
                    const right = tab.pairsets[coverageIndex];
                    for (let k3 = 0; k3 < right.length; k3++) {
                      if (right[k3].gid2 === glyphId) adj = right[k3];
                    }
                  } else if (tab.fmt === 2) {
                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);
                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);
                    adj = tab.matrix[c1][c2];
                  }
                  if (adj) {
                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);
                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);
                    break;
                  }
                }
              }
            } else if (lookup.ltype === 4) {
              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);
              if (markArrIndex !== -1) {
                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);
                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);
                if (baseArrIndex !== -1) {
                  const markRecord = tab.markArray[markArrIndex];
                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];
                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];
                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];
                  break;
                }
              }
            } else if (lookup.ltype === 6) {
              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);
              if (mark1ArrIndex !== -1) {
                const prevGlyphIndex = getPrevGlyphIndex();
                if (prevGlyphIndex !== -1) {
                  const prevGlyphId = glyphIds[prevGlyphIndex];
                  if (getGlyphClass(font, prevGlyphId) === 3) {
                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);
                    if (mark2ArrIndex !== -1) {
                      const mark1Record = tab.mark1Array[mark1ArrIndex];
                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];
                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];
                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (font.kern && !font.cff) {
        const prevGlyphIndex = getPrevGlyphIndex();
        if (prevGlyphIndex !== -1) {
          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);
          if (ind1 !== -1) {
            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);
            if (ind2 !== -1) {
              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];
            }
          }
        }
      }
    }
    return positions;
    function getPrevGlyphIndex(filter) {
      for (let i = glyphIndex - 1; i >= 0; i--) {
        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {
          return i;
        }
      }
      return -1;
    }
    function isBaseGlyph(glyphId) {
      return getGlyphClass(font, glyphId) === 1;
    }
    function applyValueRecord(source, gi) {
      for (let i = 0; i < 3; i++) {
        positions[gi * 3 + i] += source[i] || 0;
      }
    }
  }
  function getGlyphClass(font, glyphId) {
    const classDef = font.GDEF && font.GDEF.glyphClassDef;
    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;
  }
  function firstNum(...args) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === "number") {
        return args[i];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os2 = typrFont["OS/2"];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      supportsCodePoint(code) {
        return Typr.U.codeToGlyph(typrFont, code) > 0;
      },
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let penX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIds = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        const positions = calcGlyphPositions(typrFont, glyphIds);
        glyphIds.forEach((glyphId, i) => {
          if (glyphId !== -1) {
            let glyphObj = glyphMap[glyphId];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphId);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j3 = 1; j3 <= numArgs; j3++) {
                  path += (j3 > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x = crds[i2];
                  let y2 = crds[i2 + 1];
                  if (x < xMin) xMin = x;
                  if (y2 < yMin) yMin = y2;
                  if (x > xMax) xMax = x;
                  if (y2 > yMax) yMax = y2;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphId] = {
                index: glyphId,
                advanceWidth: typrFont.hmtx.aWidth[glyphId],
                xMin,
                yMin,
                xMax,
                yMax,
                path
              };
            }
            callback.call(
              null,
              glyphObj,
              penX + positions[i * 3] * fontScale,
              positions[i * 3 + 1] * fontScale,
              charIndex
            );
            penX += positions[i * 3 + 2] * fontScale;
            if (letterSpacing) {
              penX += letterSpacing * fontSize;
            }
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return penX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag2 = Typr._bin.readASCII(peek, 0, 4);
    if (tag2 === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag2 === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
function unicodeFontResolverClientFactory() {
  return (function(t) {
    var n = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    n.prototype.add = function(t2) {
      var n2 = t2 >> 5;
      this.buckets.set(n2, (this.buckets.get(n2) || 0) | 1 << (31 & t2));
    }, n.prototype.has = function(t2) {
      var n2 = this.buckets.get(t2 >> 5);
      return void 0 !== n2 && 0 != (n2 & 1 << (31 & t2));
    }, n.prototype.serialize = function() {
      var t2 = [];
      return this.buckets.forEach((function(n2, r2) {
        t2.push((+r2).toString(36) + ":" + n2.toString(36));
      })), t2.join(",");
    }, n.prototype.deserialize = function(t2) {
      var n2 = this;
      this.buckets.clear(), t2.split(",").forEach((function(t3) {
        var r2 = t3.split(":");
        n2.buckets.set(parseInt(r2[0], 36), parseInt(r2[1], 36));
      }));
    };
    var r = Math.pow(2, 8), e = r - 1, o = ~e;
    function a(t2) {
      var n2 = (function(t3) {
        return t3 & o;
      })(t2).toString(16), e2 = (function(t3) {
        return (t3 & o) + r - 1;
      })(t2).toString(16);
      return "codepoint-index/plane" + (t2 >> 16) + "/" + n2 + "-" + e2 + ".json";
    }
    function i(t2, n2) {
      var r2 = t2 & e, o2 = n2.codePointAt(r2 / 6 | 0);
      return 0 != ((o2 = (o2 || 48) - 48) & 1 << r2 % 6);
    }
    function u(t2, n2) {
      var r2;
      (r2 = t2, r2.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map((function(t3) {
        return t3.split("-").map((function(t4) {
          return parseInt(t4.trim(), 16);
        }));
      }))).forEach((function(t3) {
        var r3 = t3[0], e2 = t3[1];
        void 0 === e2 && (e2 = r3), n2(r3, e2);
      }));
    }
    function c(t2, n2) {
      u(t2, (function(t3, r2) {
        for (var e2 = t3; e2 <= r2; e2++) n2(e2);
      }));
    }
    var s = {}, f = {}, l = /* @__PURE__ */ new WeakMap(), v4 = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(t2) {
      var r2 = l.get(t2);
      return r2 || (r2 = new n(), c(t2.ranges, (function(t3) {
        return r2.add(t3);
      })), l.set(t2, r2)), r2;
    }
    var h, p = /* @__PURE__ */ new Map();
    function g(t2, n2, r2) {
      return t2[n2] ? n2 : t2[r2] ? r2 : (function(t3) {
        for (var n3 in t3) return n3;
      })(t2);
    }
    function w(t2, n2) {
      var r2 = n2;
      if (!t2.includes(r2)) {
        r2 = 1 / 0;
        for (var e2 = 0; e2 < t2.length; e2++) Math.abs(t2[e2] - n2) < Math.abs(r2 - n2) && (r2 = t2[e2]);
      }
      return r2;
    }
    function k3(t2) {
      return h || (h = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", (function(t3) {
        h.add(t3);
      }))), h.has(t2);
    }
    return t.CodePointSet = n, t.clearCache = function() {
      s = {}, f = {};
    }, t.getFontsForString = function(t2, n2) {
      void 0 === n2 && (n2 = {});
      var r2, e2 = n2.lang;
      void 0 === e2 && (e2 = new RegExp("\\p{Script=Hangul}", "u").test(r2 = t2) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(r2) ? "ja" : "en");
      var o2 = n2.category;
      void 0 === o2 && (o2 = "sans-serif");
      var u2 = n2.style;
      void 0 === u2 && (u2 = "normal");
      var c2 = n2.weight;
      void 0 === c2 && (c2 = 400);
      var l2 = (n2.dataUrl || v4).replace(/\/$/g, ""), h2 = /* @__PURE__ */ new Map(), y2 = new Uint8Array(t2.length), b2 = {}, m2 = {}, A2 = new Array(t2.length), S = /* @__PURE__ */ new Map(), j3 = false;
      function M3(t3) {
        var n3 = p.get(t3);
        return n3 || (n3 = fetch(l2 + "/" + t3).then((function(t4) {
          if (!t4.ok) throw new Error(t4.statusText);
          return t4.json().then((function(t5) {
            if (!Array.isArray(t5) || 1 !== t5[0]) throw new Error("Incorrect schema version; need 1, got " + t5[0]);
            return t5[1];
          }));
        })).catch((function(n4) {
          if (l2 !== v4) return j3 || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + l2 + '", trying default CDN. ' + n4.message), j3 = true), l2 = v4, p.delete(t3), M3(t3);
          throw n4;
        })), p.set(t3, n3)), n3;
      }
      for (var P2 = function(n3) {
        var r3 = t2.codePointAt(n3), e3 = a(r3);
        A2[n3] = e3, s[e3] || S.has(e3) || S.set(e3, M3(e3).then((function(t3) {
          s[e3] = t3;
        }))), r3 > 65535 && (n3++, E2 = n3);
      }, E2 = 0; E2 < t2.length; E2++) P2(E2);
      return Promise.all(S.values()).then((function() {
        S.clear();
        for (var n3 = function(n4) {
          var o3 = t2.codePointAt(n4), a2 = null, u3 = s[A2[n4]], c3 = void 0;
          for (var l3 in u3) {
            var v5 = m2[l3];
            if (void 0 === v5 && (v5 = m2[l3] = new RegExp(l3).test(e2 || "en")), v5) {
              for (var d2 in c3 = l3, u3[l3]) if (i(o3, u3[l3][d2])) {
                a2 = d2;
                break;
              }
              break;
            }
          }
          if (!a2) {
            t: for (var h3 in u3) if (h3 !== c3) {
              for (var p2 in u3[h3]) if (i(o3, u3[h3][p2])) {
                a2 = p2;
                break t;
              }
            }
          }
          a2 || (console.debug("No font coverage for U+" + o3.toString(16)), a2 = "latin"), A2[n4] = a2, f[a2] || S.has(a2) || S.set(a2, M3("font-meta/" + a2 + ".json").then((function(t3) {
            f[a2] = t3;
          }))), o3 > 65535 && (n4++, r3 = n4);
        }, r3 = 0; r3 < t2.length; r3++) n3(r3);
        return Promise.all(S.values());
      })).then((function() {
        for (var n3, r3 = null, e3 = 0; e3 < t2.length; e3++) {
          var a2 = t2.codePointAt(e3);
          if (r3 && (k3(a2) || d(r3).has(a2))) y2[e3] = y2[e3 - 1];
          else {
            r3 = f[A2[e3]];
            var i2 = b2[r3.id];
            if (!i2) {
              var s2 = r3.typeforms, v5 = g(s2, o2, "sans-serif"), p2 = g(s2[v5], u2, "normal"), m3 = w(null === (n3 = s2[v5]) || void 0 === n3 ? void 0 : n3[p2], c2);
              i2 = b2[r3.id] = l2 + "/font-files/" + r3.id + "/" + v5 + "." + p2 + "." + m3 + ".woff";
            }
            var S2 = h2.get(i2);
            null == S2 && (S2 = h2.size, h2.set(i2, S2)), y2[e3] = S2;
          }
          a2 > 65535 && (e3++, y2[e3] = y2[e3 - 1]);
        }
        return { fontUrls: Array.from(h2.keys()), chars: y2 };
      }));
    }, Object.defineProperty(t, "__esModule", { value: true }), t;
  })({});
}
function createFontResolver(fontParser, unicodeFontResolverClient) {
  const parsedFonts = /* @__PURE__ */ Object.create(null);
  const loadingFonts = /* @__PURE__ */ Object.create(null);
  function doLoadFont(url, callback) {
    const onError2 = (err) => {
      console.error(`Failure loading font ${url}`, err);
    };
    try {
      const request = new XMLHttpRequest();
      request.open("get", url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        if (request.status >= 400) {
          onError2(new Error(request.statusText));
        } else if (request.status > 0) {
          try {
            const fontObj = fontParser(request.response);
            fontObj.src = url;
            callback(fontObj);
          } catch (e) {
            onError2(e);
          }
        }
      };
      request.onerror = onError2;
      request.send();
    } catch (err) {
      onError2(err);
    }
  }
  function loadFont(fontUrl, callback) {
    let font = parsedFonts[fontUrl];
    if (font) {
      callback(font);
    } else if (loadingFonts[fontUrl]) {
      loadingFonts[fontUrl].push(callback);
    } else {
      loadingFonts[fontUrl] = [callback];
      doLoadFont(fontUrl, (fontObj) => {
        fontObj.src = fontUrl;
        parsedFonts[fontUrl] = fontObj;
        loadingFonts[fontUrl].forEach((cb) => cb(fontObj));
        delete loadingFonts[fontUrl];
      });
    }
  }
  return function(text, callback, {
    lang,
    fonts: userFonts = [],
    style = "normal",
    weight = "normal",
    unicodeFontsURL
  } = {}) {
    const charResolutions = new Uint8Array(text.length);
    const fontResolutions = [];
    if (!text.length) {
      allDone();
    }
    const fontIndices = /* @__PURE__ */ new Map();
    const fallbackRanges = [];
    if (style !== "italic") style = "normal";
    if (typeof weight !== "number") {
      weight = weight === "bold" ? 700 : 400;
    }
    if (userFonts && !Array.isArray(userFonts)) {
      userFonts = [userFonts];
    }
    userFonts = userFonts.slice().filter((def) => !def.lang || def.lang.test(lang)).reverse();
    if (userFonts.length) {
      const UNKNOWN = 0;
      const RESOLVED = 1;
      const NEEDS_FALLBACK = 2;
      let prevCharResult = UNKNOWN;
      (function resolveUserFonts(startIndex = 0) {
        for (let i = startIndex, iLen = text.length; i < iLen; i++) {
          const codePoint = text.codePointAt(i);
          if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || i > 0 && /\s/.test(text[i])) {
            charResolutions[i] = charResolutions[i - 1];
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          } else {
            for (let j3 = charResolutions[i], jLen = userFonts.length; j3 <= jLen; j3++) {
              if (j3 === jLen) {
                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [i, i];
                range[1] = i;
                prevCharResult = NEEDS_FALLBACK;
              } else {
                charResolutions[i] = j3;
                const { src, unicodeRange } = userFonts[j3];
                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {
                  const fontObj = parsedFonts[src];
                  if (!fontObj) {
                    loadFont(src, () => {
                      resolveUserFonts(i);
                    });
                    return;
                  }
                  if (fontObj.supportsCodePoint(codePoint)) {
                    let fontIndex = fontIndices.get(fontObj);
                    if (typeof fontIndex !== "number") {
                      fontIndex = fontResolutions.length;
                      fontResolutions.push(fontObj);
                      fontIndices.set(fontObj, fontIndex);
                    }
                    charResolutions[i] = fontIndex;
                    prevCharResult = RESOLVED;
                    break;
                  }
                }
              }
            }
          }
          if (codePoint > 65535 && i + 1 < iLen) {
            charResolutions[i + 1] = charResolutions[i];
            i++;
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          }
        }
        resolveFallbacks();
      })();
    } else {
      fallbackRanges.push([0, text.length - 1]);
      resolveFallbacks();
    }
    function resolveFallbacks() {
      if (fallbackRanges.length) {
        const fallbackString = fallbackRanges.map((range) => text.substring(range[0], range[1] + 1)).join("\n");
        unicodeFontResolverClient.getFontsForString(fallbackString, {
          lang: lang || void 0,
          style,
          weight,
          dataUrl: unicodeFontsURL
        }).then(({ fontUrls, chars }) => {
          const fontIndexOffset = fontResolutions.length;
          let charIdx = 0;
          fallbackRanges.forEach((range) => {
            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {
              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;
            }
            charIdx++;
          });
          let loadedCount = 0;
          fontUrls.forEach((url, i) => {
            loadFont(url, (fontObj) => {
              fontResolutions[i + fontIndexOffset] = fontObj;
              if (++loadedCount === fontUrls.length) {
                allDone();
              }
            });
          });
        });
      } else {
        allDone();
      }
    }
    function allDone() {
      callback({
        chars: charResolutions,
        fonts: fontResolutions
      });
    }
    function isCodeInRanges(code, ranges) {
      for (let k3 = 0; k3 < ranges.length; k3++) {
        const [start, end2 = start] = ranges[k3];
        if (start <= code && code <= end2) {
          return true;
        }
      }
      return false;
    }
  };
}
var fontResolverWorkerModule = defineWorkerModule({
  name: "FontResolver",
  dependencies: [
    createFontResolver,
    workerModule,
    unicodeFontResolverClientFactory
  ],
  init(createFontResolver2, fontParser, unicodeFontResolverClientFactory2) {
    return createFontResolver2(fontParser, unicodeFontResolverClientFactory2());
  }
});
function createTypesetter(resolveFonts, bidi) {
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function calculateFontRuns({ text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL }, onDone) {
    const onResolved = ({ chars, fonts: parsedFonts }) => {
      let curRun, prevVal;
      const runs = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] !== prevVal) {
          prevVal = chars[i];
          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]] });
        } else {
          curRun.end = i;
        }
      }
      onDone(runs);
    };
    if (preResolvedFonts) {
      onResolved(preResolvedFonts);
    } else {
      resolveFonts(
        text,
        onResolved,
        { lang, fonts, style, weight, unicodeFontsURL }
      );
    }
  }
  function typeset({
    text = "",
    font,
    lang,
    sdfGlyphSize = 64,
    fontSize = 400,
    fontWeight = 1,
    fontStyle = "normal",
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction: direction2,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    metricsOnly = false,
    unicodeFontsURL,
    preResolvedFonts = null,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    calculateFontRuns({
      text,
      lang,
      style: fontStyle,
      weight: fontWeight,
      fonts: typeof font === "string" ? [{ src: font }] : font,
      unicodeFontsURL,
      preResolvedFonts
    }, (runs) => {
      timings.fontLoad = now2() - mainStart;
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphFontIndices = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const metricsByFont = /* @__PURE__ */ new Map();
      const typesetStart = now2();
      let lineXOffset = textIndent;
      let prevRunEndX = 0;
      let currentLine = new TextLine();
      const lines = [currentLine];
      runs.forEach((run) => {
        const { fontObj } = run;
        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
        let fontData2 = metricsByFont.get(fontObj);
        if (!fontData2) {
          const fontSizeMult2 = fontSize / unitsPerEm;
          const calcLineHeight = lineHeight === "normal" ? (ascender - descender + lineGap) * fontSizeMult2 : lineHeight * fontSize;
          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult2) / 2;
          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult2);
          const caretTop = (ascender + descender) / 2 * fontSizeMult2 + caretHeight / 2;
          fontData2 = {
            index: metricsByFont.size,
            src: fontObj.src,
            fontObj,
            fontSizeMult: fontSizeMult2,
            unitsPerEm,
            ascender: ascender * fontSizeMult2,
            descender: descender * fontSizeMult2,
            capHeight: capHeight * fontSizeMult2,
            xHeight: xHeight * fontSizeMult2,
            lineHeight: calcLineHeight,
            baseline: -halfLeading - ascender * fontSizeMult2,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop,
            caretBottom: caretTop - caretHeight
          };
          metricsByFont.set(fontObj, fontData2);
        }
        const { fontSizeMult } = fontData2;
        const runText = text.slice(run.start, run.end + 1);
        let prevGlyphX, prevGlyphObj;
        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {
          glyphX += prevRunEndX;
          charIndex += run.start;
          prevGlyphX = glyphX;
          prevGlyphObj = glyphObj;
          const char = text.charAt(charIndex);
          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
          const curLineCount = currentLine.count;
          let nextLine;
          if (!("isEmpty" in glyphObj)) {
            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
          }
          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
            renderableGlyphCount++;
          }
          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
              nextLine = new TextLine();
              lineXOffset = -glyphX;
            } else {
              for (let i = curLineCount; i--; ) {
                if (i === 0 && overflowWrap === "break-word") {
                  nextLine = new TextLine();
                  lineXOffset = -glyphX;
                  break;
                } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                  nextLine = currentLine.splitAt(i + 1);
                  const adjustX = nextLine.glyphAt(0).x;
                  lineXOffset -= adjustX;
                  for (let j3 = nextLine.count; j3--; ) {
                    nextLine.glyphAt(j3).x -= adjustX;
                  }
                  break;
                }
              }
            }
            if (nextLine) {
              currentLine.isSoftWrapped = true;
              currentLine = nextLine;
              lines.push(currentLine);
              maxLineWidth = maxWidth;
            }
          }
          let fly = currentLine.glyphAt(currentLine.count);
          fly.glyphObj = glyphObj;
          fly.x = glyphX + lineXOffset;
          fly.y = glyphY;
          fly.width = glyphWidth;
          fly.charIndex = charIndex;
          fly.fontData = fontData2;
          if (char === "\n") {
            currentLine = new TextLine();
            lines.push(currentLine);
            lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
          }
        });
        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;
      });
      let totalHeight = 0;
      lines.forEach((line) => {
        let isTrailingWhitespace = true;
        for (let i = line.count; i--; ) {
          const glyphInfo = line.glyphAt(i);
          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {
            line.width = glyphInfo.x + glyphInfo.width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            isTrailingWhitespace = false;
          }
          let { lineHeight: lineHeight2, capHeight, xHeight, baseline } = glyphInfo.fontData;
          if (lineHeight2 > line.lineHeight) line.lineHeight = lineHeight2;
          const baselineDiff = baseline - line.baseline;
          if (baselineDiff < 0) {
            line.baseline += baselineDiff;
            line.cap += baselineDiff;
            line.ex += baselineDiff;
          }
          line.cap = Math.max(line.cap, line.baseline + capHeight);
          line.ex = Math.max(line.ex, line.baseline + xHeight);
        }
        line.baseline -= totalHeight;
        line.cap -= totalHeight;
        line.ex -= totalHeight;
        totalHeight += line.lineHeight;
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -lines[0].baseline : anchorY === "top-cap" ? -lines[0].cap : anchorY === "top-ex" ? -lines[0].ex : anchorY === "middle" ? totalHeight / 2 : anchorY === "bottom" ? totalHeight : anchorY === "bottom-baseline" ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction2);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphFontIndices = new Uint8Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 4);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end2] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end2) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j3 = startInLine; j3 < endInLine; j3++) {
                    const glyphInfo = line.glyphAt(j3);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g) => glyphObj = g;
            for (let i = 0; i < lineGlyphCount; i++) {
              const glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex, fontData: fontData2 } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 4 + 2] = line.baseline + fontData2.caretBottom + anchorYOffset;
                caretPositions[charIndex * 4 + 3] = line.baseline + fontData2.caretTop + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                const { fontSizeMult, src: fontSrc, index: fontIndex } = glyphInfo.fontData;
                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});
                if (!fontGlyphData[glyphId]) {
                  fontGlyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                glyphFontIndices[idx] = fontIndex;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      const fontData = [];
      metricsByFont.forEach(({ index, src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight }) => {
        fontData[index] = { src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight };
      });
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices,
        //index into fontData for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        fontData,
        //data about each font used in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        topBaseline: anchorYOffset + lines[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - totalHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset({ ...args, metricsOnly: true }, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 4];
    const ligEndX = caretPositions[ligStartIndex * 4 + 1];
    const ligBottom = caretPositions[ligStartIndex * 4 + 2];
    const ligTop = caretPositions[ligStartIndex * 4 + 3];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 4;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligBottom;
      caretPositions[startIndex + 3] = ligTop;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  TextLine.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop2, i, all) => {
    Object.defineProperty(obj, prop2, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width2, height2, path, viewBox, distance, exponent, canvas, x, y2, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width2, height2, path, viewBox, distance, exponent, canvas, x, y2, channel);
  }
  return generateSDF_GL(width2, height2, path, viewBox, distance, exponent, canvas, x, y2, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width2, height2, path, viewBox, distance, exponent, canvas, x, y2, channel);
    }
  );
}
var queue = [];
var chunkTimeBudget = 5;
var timer = 0;
function nextChunk() {
  const start = now();
  while (queue.length && now() - start < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
var generateSDF_GL = (...args) => {
  return new Promise((resolve, reject) => {
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve({ timing: now() - start });
      } catch (err) {
        reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
var threadCount = 4;
var idleTimeout = 2e3;
var threads = {};
var callNum = 0;
function generateSDF_JS_Worker(width2, height2, path, viewBox, distance, exponent, canvas, x, y2, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: defineWorkerModule({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now
        ],
        init(_createSDFGenerator, now2) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start = now2();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now2() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width2, height2, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
    const start = now();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i = 0; i < textureData.length; i++) {
      imageData[i * 4 + channel] = textureData[i];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y2, width2, height2, 1 << 3 - channel);
    timing += now() - start;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker(workerId);
      }, idleTimeout);
    }
    return { timing };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
var CONFIG = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048,
  useWorker: true
};
var tempColor = new Color9();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign3({}, args);
  const totalStart = now$1();
  const { defaultFontURL } = CONFIG;
  const fonts = [];
  if (defaultFontURL) {
    fonts.push({ label: "default", src: toAbsoluteURL(defaultFontURL) });
  }
  if (args.font) {
    fonts.push({ label: "user", src: toAbsoluteURL(args.font) });
  }
  args.font = fonts;
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key2 in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key2)) {
        let val = args.colorRanges[key2];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key2] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture3(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter2,
        LinearFilter2
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  const typeset = CONFIG.useWorker ? typesetInWorker : typesetOnMainThread;
  typeset(args).then((result) => {
    const { glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    const fontGlyphMaps = fontData.map((font) => {
      let map = atlas.glyphsByFont.get(font.src);
      if (!map) {
        atlas.glyphsByFont.set(font.src, map = /* @__PURE__ */ new Map());
      }
      return map;
    });
    glyphIds.forEach((glyphId, i) => {
      const fontIndex = glyphFontIndices[i];
      const { src: fontSrc, unitsPerEm } = fontData[fontIndex];
      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[fontSrc][glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      const fontSizeMult = fontSize / unitsPerEm;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y2 = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y2, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function preloadFont({ font, characters, sdfGlyphSize }, callback) {
  let text = Array.isArray(characters) ? characters.join("\n") : "" + characters;
  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);
}
function assign3(toObj, fromObj) {
  for (let key2 in fromObj) {
    if (fromObj.hasOwnProperty(key2)) {
      toObj[key2] = fromObj[key2];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width: width2, height: height2 } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width2 * height2 * 4) {
      pixels = new Uint8Array(width2 * height2 * 4);
      sdfTexture.image = { width: width2, height: height2, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width2, height2, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    createTypesetter,
    fontResolverWorkerModule,
    bidi_default
  ],
  init(createTypesetter2, fontResolver, bidiFactory2) {
    return createTypesetter2(fontResolver, bidiFactory2());
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve) => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    const transferables = [];
    for (let p in result) {
      if (result[p] && result[p].buffer) {
        transferables.push(result[p].buffer);
      }
    }
    return transferables;
  }
});
var typesetOnMainThread = typesetInWorker.onMainThread;
var templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    geom = templateGeometries[detail] = new PlaneGeometry2(1, 1, detail, detail).translate(0.5, 0.5, 0);
  }
  return geom;
}
var glyphBoundsAttrName = "aTroikaGlyphBounds";
var glyphIndexAttrName = "aTroikaGlyphIndex";
var glyphColorAttrName = "aTroikaGlyphColor";
var GlyphsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere5();
    this.boundingBox = new Box310();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    this.updateAttributeData(glyphBoundsAttrName, glyphBounds, 4);
    this.updateAttributeData(glyphIndexAttrName, glyphAtlasIndices, 1);
    this.updateAttributeData(glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i = chunks.length; i--; ) {
        count = chunks[i].end;
        let rect = chunks[i].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(attrName, newArray, itemSize) {
    const attr = this.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        this.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete this._maxInstanceCount;
        this.dispose();
      }
    } else if (attr) {
      this.deleteAttribute(attrName);
    }
  }
};
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector211() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector44(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector44(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector211() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color9() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix32() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: vertexShader10, fragmentShader: fragmentShader10 }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader10)) {
        fragmentShader10 = fragmentShader10.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader10)) {
          vertexShader10 = vertexShader10.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader: vertexShader10, fragmentShader: fragmentShader10 };
    }
  });
  textMaterial.transparent = true;
  textMaterial.forceSinglePass = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var defaultMaterial = new MeshBasicMaterial6({
  color: 16777215,
  side: DoubleSide8,
  transparent: true
});
var defaultStrokeColor = 8421504;
var tempMat4 = new Matrix419();
var tempVec3a = new Vector326();
var tempVec3b = new Vector326();
var tempArray = [];
var origin2 = new Vector326();
var defaultOrient = "+x+y";
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
var getFlatRaycastMesh = () => {
  const mesh = new Mesh10(
    new PlaneGeometry2(1, 1),
    defaultMaterial
  );
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
var getCurvedRaycastMesh = () => {
  const mesh = new Mesh10(
    new PlaneGeometry2(1, 1, 32, 1),
    defaultMaterial
  );
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
var syncStartEvent = { type: "syncstart" };
var syncCompleteEvent = { type: "synccomplete" };
var SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
var COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
var Text = class extends Mesh10 {
  constructor() {
    const geometry = new GlyphsGeometry();
    super(geometry, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.unicodeFontsURL = null;
    this.fontSize = 0.1;
    this.fontWeight = "normal";
    this.fontStyle = "normal";
    this.lang = null;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          lang: this.lang,
          fontSize: this.fontSize || 0.1,
          fontWeight: this.fontWeight || "normal",
          fontStyle: this.fontStyle || "normal",
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF,
          unicodeFontsURL: this.unicodeFontsURL
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material2, group) {
    this.sync();
    if (material2.isTroikaTextMaterial) {
      this._prepareForRender(material2);
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(baseMaterial) {
    return createTextDerivedMaterial(baseMaterial);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {
      derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.hasOutline()) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  set customDepthMaterial(m2) {
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(m2) {
  }
  _prepareForRender(material2) {
    const isOutline = material2.isTextOutlineMaterial;
    const uniforms = material2.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null) strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaEdgeOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material2.polygonOffset = !!this.depthOffset;
    material2.polygonOffsetFactor = material2.polygonOffsetUnits = this.depthOffset || 0;
    const color = isOutline ? this.outlineColor || 0 : this.color;
    if (color == null) {
      delete material2.color;
    } else {
      const colorObj = material2.hasOwnProperty("color") ? material2.color : material2.color = new Color9();
      if (color !== colorObj._input || typeof color === "object") {
        colorObj.set(colorObj._input = color);
      }
    }
    let orient = this.orientation || defaultOrient;
    if (orient !== material2._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat4.lookAt(origin2, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material2._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position2, target = new Vector211()) {
    target.copy(position2);
    const r = this.curveRadius;
    if (r) {
      target.x = Math.atan2(position2.x, Math.abs(r) - Math.abs(position2.z)) * Math.abs(r);
    }
    return target;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position2, target = new Vector211()) {
    tempVec3a.copy(position2);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const { position: position2, uv } = geom.attributes;
      for (let i = 0; i < uv.count; i++) {
        let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
        const y2 = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
        let z2 = 0;
        if (curveRadius) {
          z2 = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position2.setXYZ(i, x, y2, z2);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i = 0; i < tempArray.length; i++) {
        tempArray[i].object = this;
        intersects.push(tempArray[i]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach((prop2) => {
      this[prop2] = source[prop2];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS.forEach((prop2) => {
  const privateKey = "_private_" + prop2;
  Object.defineProperty(Text.prototype, prop2, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});
var tempBox3 = new Box310();
var tempColor$1 = new Color9();

// node_modules/@threlte/extras/node_modules/three-perf/dist/ui/UI.mjs
import { WebGLRenderer, Scene, OrthographicCamera as OrthographicCamera4, BufferGeometry as BufferGeometry6, BufferAttribute as BufferAttribute8, DynamicDrawUsage as DynamicDrawUsage3, Line, LineBasicMaterial as LineBasicMaterial2 } from "three";
var ThreePerfUI = class {
  //
  constructor(props) {
    var _a;
    this._charts = /* @__PURE__ */ new Map();
    this._width = 400;
    this._height = 110;
    this._backgroundOpacity = 0.7;
    this._perf = props.perf;
    this._backgroundOpacity = (_a = props.backgroundOpacity) != null ? _a : this._backgroundOpacity;
    this.wrapper = document.createElement("div");
    this.wrapper.id = "three-perf-ui";
    this.wrapper.style.position = "fixed";
    this.wrapper.style.bottom = "0";
    this.wrapper.style.left = "0";
    this.wrapper.style.width = this._width + "px";
    this.wrapper.style.height = this._height + "px";
    props.domElement.appendChild(this.wrapper);
    this.canvas = document.createElement("canvas");
    this.canvas.width = this._width;
    this.canvas.height = this._height;
    this.canvas.style.position = "absolute";
    this.wrapper.appendChild(this.canvas);
    this.initCanvas();
  }
  setScale(value) {
    this.wrapper.style.width = value * this.width + "px";
    this.wrapper.style.height = value * this.height + "px";
    this._renderer.setSize(this._width * value, this._height * value, true);
  }
  initCanvas() {
    this._renderer = new WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
    this._renderer.setClearColor(0, this._backgroundOpacity);
    this._renderer.setPixelRatio(window.devicePixelRatio);
    this._scene = new Scene();
    this._camera = new OrthographicCamera4(0, this._width, 0, -this._height, 0.1, 100);
    this._camera.position.set(0, 0, 10);
    this._camera.lookAt(0, 0, 0);
    this._camera.updateProjectionMatrix();
    this._scene.add(this._camera);
    this._scene.userData.useStats = false;
    const gpuValue = new Text();
    gpuValue.anchorX = "right";
    gpuValue.position.set(45, -8, 0);
    gpuValue.text = "0.000";
    gpuValue.fontSize = 15;
    gpuValue.color = "rgb(253, 151, 31)";
    gpuValue.sync();
    this._scene.add(gpuValue);
    const gpuMs = new Text();
    gpuMs.anchorX = "right";
    gpuMs.position.set(65, -7, 0);
    gpuMs.text = "ms";
    gpuMs.fontSize = 9;
    gpuMs.color = "rgb(255, 255, 255)";
    gpuMs.sync();
    this._scene.add(gpuMs);
    const gpuLabel = new Text();
    gpuLabel.anchorX = "right";
    gpuLabel.position.set(65, -22, 0);
    gpuLabel.text = "GPU";
    gpuLabel.fontSize = 9;
    gpuLabel.color = "rgb(253, 151, 31)";
    gpuLabel.sync();
    this._scene.add(gpuLabel);
    const cpuValue = new Text();
    cpuValue.anchorX = "right";
    cpuValue.position.set(115, -8, 0);
    cpuValue.text = "0.000";
    cpuValue.fontSize = 15;
    cpuValue.color = "rgb(66, 226, 46)";
    cpuValue.sync();
    this._scene.add(cpuValue);
    const cpuMs = new Text();
    cpuMs.anchorX = "right";
    cpuMs.position.set(135, -7, 0);
    cpuMs.text = "ms";
    cpuMs.fontSize = 9;
    cpuMs.color = "rgb(255, 255, 255)";
    cpuMs.sync();
    this._scene.add(cpuMs);
    const cpuLabel = new Text();
    cpuLabel.anchorX = "right";
    cpuLabel.position.set(135, -22, 0);
    cpuLabel.text = "CPU";
    cpuLabel.fontSize = 9;
    cpuLabel.color = "rgb(66, 226, 46)";
    cpuLabel.sync();
    this._scene.add(cpuLabel);
    const fpsValue = new Text();
    fpsValue.anchorX = "center";
    fpsValue.position.set(165, -8, 0);
    fpsValue.text = "0";
    fpsValue.fontSize = 15;
    fpsValue.color = "rgb(238, 38, 110)";
    fpsValue.sync();
    this._scene.add(fpsValue);
    const fpsLabel = new Text();
    fpsLabel.anchorX = "center";
    fpsLabel.position.set(175, -22, 0);
    fpsLabel.text = "FPS";
    fpsLabel.fontSize = 9;
    fpsLabel.color = "rgb(238, 38, 110)";
    fpsLabel.sync();
    this._scene.add(fpsLabel);
    const callsValue = new Text();
    callsValue.anchorX = "right";
    callsValue.position.set(235, -8, 0);
    callsValue.text = "0";
    callsValue.fontSize = 15;
    callsValue.color = "#ffffff";
    callsValue.sync();
    this._scene.add(callsValue);
    const callsLabel = new Text();
    callsLabel.anchorX = "right";
    callsLabel.position.set(235, -22, 0);
    callsLabel.text = "calls";
    callsLabel.fontSize = 9;
    callsLabel.color = "rgb(101, 197, 188)";
    callsLabel.sync();
    this._scene.add(callsLabel);
    const trianglesValue = new Text();
    trianglesValue.anchorX = "right";
    trianglesValue.position.set(315, -8, 0);
    trianglesValue.text = "0";
    trianglesValue.fontSize = 15;
    trianglesValue.color = "#ffffff";
    trianglesValue.sync();
    this._scene.add(trianglesValue);
    const trianglesLabel = new Text();
    trianglesLabel.anchorX = "right";
    trianglesLabel.position.set(315, -22, 0);
    trianglesLabel.text = "triangles";
    trianglesLabel.fontSize = 9;
    trianglesLabel.color = "rgb(101, 197, 188)";
    trianglesLabel.sync();
    this._scene.add(trianglesLabel);
    const renderpassesValue = new Text();
    renderpassesValue.anchorX = "right";
    renderpassesValue.position.set(365, -8, 0);
    renderpassesValue.text = "0";
    renderpassesValue.fontSize = 15;
    renderpassesValue.color = "#ffffff";
    renderpassesValue.sync();
    this._scene.add(renderpassesValue);
    const renderpassesLabel = new Text();
    renderpassesLabel.anchorX = "right";
    renderpassesLabel.position.set(365, -22, 0);
    renderpassesLabel.text = "passes";
    renderpassesLabel.fontSize = 9;
    renderpassesLabel.color = "rgb(101, 197, 188)";
    renderpassesLabel.sync();
    this._scene.add(renderpassesLabel);
    this._basicInfoElements = {
      gpuValue,
      cpuValue,
      fpsValue,
      callsValue,
      trianglesValue,
      renderpassesValue
    };
    const geometriesValue = new Text();
    geometriesValue.anchorX = "right";
    geometriesValue.position.set(65, -39, 0);
    geometriesValue.text = "0";
    geometriesValue.fontSize = 15;
    geometriesValue.color = "#ffffff";
    geometriesValue.sync();
    this._scene.add(geometriesValue);
    const geometriesLabel = new Text();
    geometriesLabel.anchorX = "right";
    geometriesLabel.position.set(65, -53, 0);
    geometriesLabel.text = "geometries";
    geometriesLabel.fontSize = 9;
    geometriesLabel.color = "rgb(101, 197, 188)";
    geometriesLabel.sync();
    this._scene.add(geometriesLabel);
    const texturesValue = new Text();
    texturesValue.anchorX = "right";
    texturesValue.position.set(135, -39, 0);
    texturesValue.text = "0";
    texturesValue.fontSize = 15;
    texturesValue.color = "#ffffff";
    texturesValue.sync();
    this._scene.add(texturesValue);
    const texturesLabel = new Text();
    texturesLabel.anchorX = "right";
    texturesLabel.position.set(135, -53, 0);
    texturesLabel.text = "textures";
    texturesLabel.fontSize = 9;
    texturesLabel.color = "rgb(101, 197, 188)";
    texturesLabel.sync();
    this._scene.add(texturesLabel);
    const shadersValue = new Text();
    shadersValue.anchorX = "right";
    shadersValue.position.set(205, -39, 0);
    shadersValue.text = "0";
    shadersValue.fontSize = 15;
    shadersValue.color = "#ffffff";
    shadersValue.sync();
    this._scene.add(shadersValue);
    const shadersLabel = new Text();
    shadersLabel.anchorX = "right";
    shadersLabel.position.set(205, -53, 0);
    shadersLabel.text = "shaders";
    shadersLabel.fontSize = 9;
    shadersLabel.color = "rgb(101, 197, 188)";
    shadersLabel.sync();
    this._scene.add(shadersLabel);
    const linesValue = new Text();
    linesValue.anchorX = "right";
    linesValue.position.set(275, -39, 0);
    linesValue.text = "0";
    linesValue.fontSize = 15;
    linesValue.color = "#ffffff";
    linesValue.sync();
    this._scene.add(linesValue);
    const linesLabel = new Text();
    linesLabel.anchorX = "right";
    linesLabel.position.set(275, -53, 0);
    linesLabel.text = "lines";
    linesLabel.fontSize = 9;
    linesLabel.color = "rgb(101, 197, 188)";
    linesLabel.sync();
    this._scene.add(linesLabel);
    const pointsValue = new Text();
    pointsValue.anchorX = "right";
    pointsValue.position.set(345, -39, 0);
    pointsValue.text = "0";
    pointsValue.fontSize = 15;
    pointsValue.color = "#ffffff";
    pointsValue.sync();
    this._scene.add(pointsValue);
    const pointsLabel = new Text();
    pointsLabel.anchorX = "right";
    pointsLabel.position.set(345, -53, 0);
    pointsLabel.text = "points";
    pointsLabel.fontSize = 9;
    pointsLabel.color = "rgb(101, 197, 188)";
    pointsLabel.sync();
    this._scene.add(pointsLabel);
    this._memInfoElements = {
      geometriesValue,
      geometriesLabel,
      texturesValue,
      texturesLabel,
      shadersValue,
      shadersLabel,
      linesValue,
      linesLabel,
      pointsValue,
      pointsLabel
    };
    const gpuChartGeometry = new BufferGeometry6();
    let positions = new Float32Array(60 * 3);
    for (let i = 0; i < 60; i++) {
      positions[3 * i + 0] = this._width / 59 * i;
      positions[3 * i + 1] = -110;
      positions[3 * i + 2] = 0;
    }
    let positionAttribute = new BufferAttribute8(positions, 3);
    positionAttribute.usage = DynamicDrawUsage3;
    gpuChartGeometry.setAttribute("position", positionAttribute);
    const gpuChart = new Line(gpuChartGeometry, new LineBasicMaterial2({ color: "rgb(253, 151, 31)" }));
    this._scene.add(gpuChart);
    this._charts.set("gpu", gpuChart);
    const cpuChartGeometry = new BufferGeometry6();
    positions = new Float32Array(60 * 3);
    for (let i = 0; i < 60; i++) {
      positions[3 * i + 0] = this._width / 59 * i;
      positions[3 * i + 1] = -110;
      positions[3 * i + 2] = 0;
    }
    positionAttribute = new BufferAttribute8(positions, 3);
    positionAttribute.usage = DynamicDrawUsage3;
    cpuChartGeometry.setAttribute("position", positionAttribute);
    const cpuChart = new Line(cpuChartGeometry, new LineBasicMaterial2({ color: "rgb(66, 226, 46)" }));
    this._scene.add(cpuChart);
    this._charts.set("cpu", cpuChart);
    const fpsChartGeometry = new BufferGeometry6();
    positions = new Float32Array(60 * 3);
    for (let i = 0; i < 60; i++) {
      positions[3 * i + 0] = this._width / 59 * i;
      positions[3 * i + 1] = -110;
      positions[3 * i + 2] = 0;
    }
    positionAttribute = new BufferAttribute8(positions, 3);
    positionAttribute.usage = DynamicDrawUsage3;
    fpsChartGeometry.setAttribute("position", positionAttribute);
    const fpsChart = new Line(fpsChartGeometry, new LineBasicMaterial2({ color: "rgb(238, 38, 110)" }));
    this._scene.add(fpsChart);
    this._charts.set("fps", fpsChart);
  }
  update() {
    var _a, _b;
    if (this._perf.chart && this._perf.showGraph) {
      for (const chartName in this._perf.chart.data) {
        const chartData = this._perf.chart.data[chartName];
        if (!this._charts.get(chartName) || !chartData)
          continue;
        const geometry = this._charts.get(chartName).geometry;
        const positionAttr = geometry.attributes.position;
        let maxValue = 0;
        for (let i = 0; i < chartData.length; i++) {
          if (chartData[i] > maxValue)
            maxValue = chartData[i];
        }
        maxValue = Math.max(maxValue, 20);
        for (let i = 0; i < chartData.length; i++) {
          let id = (this._perf.chart.circularId + i + 1) % 60;
          positionAttr.setY(i, (chartData[id] / maxValue * 90 - 110) * this.height / 110);
        }
        positionAttr.needsUpdate = true;
      }
    }
    this._basicInfoElements.gpuValue.text = this._perf.log.gpu.toFixed(3);
    this._basicInfoElements.cpuValue.text = this._perf.log.cpu.toFixed(3);
    this._basicInfoElements.fpsValue.text = this._perf.log.fps.toFixed(0);
    this._basicInfoElements.callsValue.text = this._perf.threeRenderer.info.render.calls.toString();
    this._basicInfoElements.trianglesValue.text = this._perf.threeRenderer.info.render.triangles.toString();
    this._basicInfoElements.renderpassesValue.text = this._perf.renderPassesNumber.toString();
    this._memInfoElements.geometriesValue.text = this._perf.threeRenderer.info.memory.geometries.toString();
    this._memInfoElements.texturesValue.text = this._perf.threeRenderer.info.memory.textures.toString();
    this._memInfoElements.shadersValue.text = (_b = (_a = this._perf.threeRenderer.info.programs) == null ? void 0 : _a.length.toString()) != null ? _b : "";
    this._memInfoElements.linesValue.text = this._perf.threeRenderer.info.render.lines.toString();
    this._memInfoElements.pointsValue.text = this._perf.threeRenderer.info.render.points.toString();
    this.render();
  }
  render() {
    this._renderer.render(this._scene, this._camera);
  }
  dispose() {
    this.wrapper.remove();
  }
  //
  toggleVisibility(value) {
    this.wrapper.style.display = value ? "block" : "none";
  }
  toggleCharts(value) {
    this._charts.forEach((chart) => {
      chart.visible = value;
    });
    if (this._perf.showGraph) {
      this.height = this._perf.memory ? 110 : 70;
    } else {
      this.height = this._perf.memory ? 70 : 40;
    }
    this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  toggleMemoryInfo(value) {
    for (const key2 in this._memInfoElements) {
      this._memInfoElements[key2].visible = value;
    }
    this.width = 380;
    if (this._perf.showGraph) {
      this.height = this._perf.memory ? 110 : 70;
    } else {
      this.height = this._perf.memory ? 70 : 40;
    }
    this.wrapper.style.width = this._perf.scale * this.width + "px";
    this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  setBackgroundOpacity(value) {
    this._backgroundOpacity = value;
    this._renderer.setClearColor(0, this._backgroundOpacity);
    this.render();
  }
  //
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._camera.right = value;
    this._camera.updateProjectionMatrix();
    this._renderer.setSize(this._perf.scale * this._width, this._perf.scale * this._height);
    this.render();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._camera.bottom = -value;
    this._camera.updateProjectionMatrix();
    this._renderer.setSize(this._perf.scale * this._width, this._perf.scale * this._height);
    this.render();
  }
};

// node_modules/@threlte/extras/node_modules/three-perf/dist/GLPerf.mjs
import { MathUtils as MathUtils3 } from "three";
var overLimitFps = {
  value: 0,
  fpsLimit: 60,
  isOverLimit: 0
};
var average = (arr) => (arr == null ? void 0 : arr.reduce((a, b2) => a + b2, 0)) / arr.length;
var GLPerf = class {
  //
  constructor(settings) {
    this.names = [""];
    this.finished = [];
    this.paused = false;
    this.overClock = false;
    this.queryHasResult = false;
    this.queryCreated = false;
    this.isWebGL2 = true;
    this.memAccums = [];
    this.gpuAccums = [];
    this.activeAccums = [];
    this.logsAccums = {
      mem: [],
      gpu: [],
      cpu: [],
      fps: [],
      fpsFixed: []
    };
    this.fpsChart = [];
    this.gpuChart = [];
    this.cpuChart = [];
    this.memChart = [];
    this.paramLogger = () => {
    };
    this.glFinish = () => {
    };
    this.chartLogger = () => {
    };
    this.chartLen = 60;
    this.logsPerSecond = 10;
    this.maxMemory = 1500;
    this.chartHz = 10;
    this.startCpuProfiling = false;
    this.lastCalculateFixed = 0;
    this.chartFrame = 0;
    this.gpuTimeProcess = 0;
    this.chartTime = 0;
    this.activeQueries = 0;
    this.circularId = 0;
    this.detected = 0;
    this.frameId = 0;
    this.rafId = 0;
    this.idleCbId = 0;
    this.checkQueryId = 0;
    this.uuid = void 0;
    this.currentCpu = 0;
    this.currentMem = 0;
    this.paramFrame = 0;
    this.paramTime = 0;
    this.now = () => {
    };
    this.t0 = 0;
    this.nextFps = (d) => {
      const goal = 1e3 / 60;
      const elapsed = goal - d.timeRemaining();
      const fps = goal * overLimitFps.fpsLimit / 10 / elapsed;
      if (fps < 0)
        return;
      overLimitFps.value = fps;
      if (overLimitFps.isOverLimit < 25) {
        overLimitFps.isOverLimit++;
      } else {
        this.perf.overclockingFps = true;
      }
    };
    this.nextFrame = (now2) => {
      this.frameId++;
      const t = now2 || this.now();
      let duration = t - this.paramTime;
      let gpu = 0;
      if (this.frameId <= 1) {
        this.paramFrame = this.frameId;
        this.paramTime = t;
      } else {
        if (t >= this.paramTime) {
          this.maxMemory = window.performance.memory ? window.performance.memory.jsHeapSizeLimit / 1048576 : 0;
          const frameCount = this.frameId - this.paramFrame;
          const fpsFixed = frameCount * 1e3 / duration;
          const fps = this.perf.overclockingFps ? overLimitFps.value : fpsFixed;
          gpu = this.isWebGL2 ? this.gpuAccums[0] : this.gpuAccums[0] / duration;
          if (this.isWebGL2) {
            this.gpuAccums[0] = 0;
          } else {
            Promise.all(this.finished).then(() => {
              this.gpuAccums[0] = 0;
              this.finished = [];
            });
          }
          this.currentMem = Math.round(window.performance && window.performance.memory ? window.performance.memory.usedJSHeapSize / 1048576 : 0);
          if (window.performance && this.startCpuProfiling) {
            window.performance.mark("cpu-finished");
            const cpuMeasure = performance.measure("cpu-duration", "cpu-started", "cpu-finished");
            this.currentCpu = cpuMeasure.duration;
            this.logsAccums.cpu.push(this.currentCpu);
            this.startCpuProfiling = false;
          }
          this.logsAccums.mem.push(this.currentMem);
          this.logsAccums.fpsFixed.push(fpsFixed);
          this.logsAccums.fps.push(fps);
          this.logsAccums.gpu.push(gpu);
          if (this.overClock && typeof window.requestIdleCallback !== "undefined") {
            if (overLimitFps.isOverLimit > 0 && fps > fpsFixed) {
              overLimitFps.isOverLimit--;
            } else if (this.perf.overclockingFps) {
              this.perf.overclockingFps = false;
            }
          }
          if (t >= this.paramTime + 1e3 / this.logsPerSecond) {
            this.paramLogger({
              cpu: average(this.logsAccums.cpu),
              gpu: average(this.logsAccums.gpu),
              mem: average(this.logsAccums.mem),
              fps: average(this.logsAccums.fps),
              duration: Math.round(duration),
              maxMemory: this.maxMemory,
              frameCount
            });
            this.logsAccums.mem = [];
            this.logsAccums.fps = [];
            this.logsAccums.gpu = [];
            this.logsAccums.cpu = [];
            this.paramFrame = this.frameId;
            this.paramTime = t;
          }
          if (this.overClock) {
            if (t - this.lastCalculateFixed >= 2 * 1e3) {
              this.lastCalculateFixed = now2;
              overLimitFps.fpsLimit = Math.round(average(this.logsAccums.fpsFixed) / 10) * 100;
              this.perf.fpsLimit = overLimitFps.fpsLimit / 10;
              this.logsAccums.fpsFixed = [];
              this.paramFrame = this.frameId;
              this.paramTime = t;
            }
          }
        }
      }
      if (!this.detected || !this.chartFrame) {
        this.chartFrame = this.frameId;
        this.chartTime = t;
        this.circularId = 0;
      } else {
        const timespan = t - this.chartTime;
        let hz = this.chartHz * timespan / 1e3;
        while (--hz > 0 && this.detected) {
          const frameCount = this.frameId - this.chartFrame;
          const fpsFixed = frameCount / timespan * 1e3;
          const fps = this.perf.overclockingFps ? overLimitFps.value : fpsFixed;
          this.fpsChart[this.circularId % this.chartLen] = fps;
          const memS = 1e3 / this.currentMem;
          const cpuS = this.currentCpu;
          const gpuS = (this.isWebGL2 ? this.gpuAccums[1] * 2 : Math.round(this.gpuAccums[1] / duration * 100)) + 4;
          if (gpuS > 0) {
            this.gpuChart[this.circularId % this.chartLen] = gpuS;
          }
          if (cpuS > 0) {
            this.cpuChart[this.circularId % this.chartLen] = cpuS;
          }
          if (memS > 0) {
            this.memChart[this.circularId % this.chartLen] = memS;
          }
          for (let i = 0; i < this.names.length; i++) {
            this.chartLogger({
              i,
              data: {
                fps: this.fpsChart,
                gpu: this.gpuChart,
                cpu: this.cpuChart,
                mem: this.memChart
              },
              circularId: this.circularId
            });
          }
          this.circularId++;
          this.chartFrame = this.frameId;
          this.chartTime = t;
        }
      }
    };
    this.perf = settings.perf;
    this.trackGPU = settings.trackGPU;
    this.overClock = settings.overClock;
    this.logsPerSecond = settings.logsPerSecond;
    this.gl = settings.gl;
    this.paramLogger = settings.paramLogger;
    this.chartLogger = settings.chartLogger;
    window.GLPerf = window.GLPerf || {};
    this.fpsChart = new Array(this.chartLen).fill(0);
    this.gpuChart = new Array(this.chartLen).fill(0);
    this.cpuChart = new Array(this.chartLen).fill(0);
    this.memChart = new Array(this.chartLen).fill(0);
    this.now = () => window.performance && window.performance.now ? window.performance.now() : Date.now();
    this.initGpu();
    this.is120hz();
  }
  initGpu() {
    this.uuid = MathUtils3.generateUUID();
    if (this.gl) {
      this.isWebGL2 = true;
      if (!this.extension) {
        this.extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
      }
      if (this.extension === null) {
        this.isWebGL2 = false;
      }
    }
  }
  /**
   * 120hz device detection
   */
  is120hz() {
    let n = 0;
    const loop = (t) => {
      if (++n < 20) {
        this.rafId = window.requestAnimationFrame(loop);
      } else {
        this.detected = Math.ceil(1e3 * n / (t - this.t0) / 70);
        window.cancelAnimationFrame(this.rafId);
      }
      if (!this.t0)
        this.t0 = t;
    };
    this.rafId = window.requestAnimationFrame(loop);
  }
  /**
   * Explicit UI add
   * @param { string | undefined } name
   */
  addUI(name) {
    if (this.names.indexOf(name) === -1) {
      this.names.push(name);
      this.gpuAccums.push(0);
      this.activeAccums.push(false);
    }
  }
  startGpu() {
    const gl = this.gl;
    const ext = this.extension;
    if (!gl || !ext)
      return;
    if (this.isWebGL2) {
      let available = false;
      let disjoint;
      let ns;
      if (this.query) {
        this.queryHasResult = false;
        let query = this.query;
        available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
        disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
        if (available && !disjoint) {
          ns = gl.getQueryParameter(this.query, gl.QUERY_RESULT);
          const ms = ns * 1e-6;
          if (available || disjoint) {
            gl.deleteQuery(this.query);
            query = null;
          }
          if (available && ms > 0) {
            if (!disjoint) {
              this.activeAccums.forEach((_active2, i) => {
                this.gpuAccums[i] = ms;
              });
            }
          }
        }
      }
      if (available || !this.query) {
        this.queryCreated = true;
        this.query = gl.createQuery();
        gl.beginQuery(ext.TIME_ELAPSED_EXT, this.query);
      }
    }
  }
  endGpu() {
    const ext = this.extension;
    const gl = this.gl;
    if (this.isWebGL2 && this.queryCreated && gl.getQuery(ext.TIME_ELAPSED_EXT, gl.CURRENT_QUERY)) {
      gl.endQuery(ext.TIME_ELAPSED_EXT);
    }
  }
  /**
   * Begin named measurement
   * @param { string | undefined } name
   */
  begin(name) {
    this.startGpu();
    this.updateAccums(name);
  }
  /**
   * End named measure
   * @param { string | undefined } name
   */
  end(name) {
    this.endGpu();
    this.updateAccums(name);
  }
  updateAccums(name) {
    let nameId = this.names.indexOf(name);
    if (nameId === -1) {
      nameId = this.names.length;
      this.addUI(name);
    }
    const t = this.now();
    this.activeAccums[nameId] = !this.activeAccums[nameId];
    this.t0 = t;
  }
};

// node_modules/@threlte/extras/node_modules/three-perf/dist/ThreePerf.mjs
var updateMatrixWorldTemp = Object3D5.prototype.updateMatrixWorld;
var updateWorldMatrixTemp = Object3D5.prototype.updateWorldMatrix;
var updateMatrixTemp = Object3D5.prototype.updateMatrix;
var maxGl = ["calls", "triangles", "points", "lines"];
var maxLog = ["gpu", "cpu", "mem", "fps"];
var ThreePerf = class {
  //
  constructor(props) {
    var _a, _b, _c, _d, _e3, _f, _g, _h, _i, _j, _k, _l;
    this.gui = new import_tweakpane.Pane();
    this.accumulated = {
      totalFrames: 0,
      log: {
        i: 0,
        maxMemory: 0,
        gpu: 0,
        mem: 0,
        cpu: 0,
        fps: 0,
        duration: 0,
        frameCount: 0
      },
      gl: {
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
        counts: 0
      },
      max: {
        log: {
          i: 0,
          maxMemory: 0,
          gpu: 0,
          mem: 0,
          cpu: 0,
          fps: 0,
          duration: 0,
          frameCount: 0
        },
        gl: {
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0,
          counts: 0
        }
      }
    };
    this.renderPassesNumber = 0;
    this._keypressed = "";
    this._guiVisible = true;
    this.actionToCallUI = "dev";
    this.keypressHandler = (event) => {
      if (!this.actionToCallUI)
        return;
      this._keypressed += event.key;
      const keys = this._keypressed.split("");
      while (keys.length > this.actionToCallUI.length) {
        keys.shift();
      }
      if (keys.join("") === this.actionToCallUI) {
        this._keypressed = "";
        this.guiVisible = !this.guiVisible;
      }
    };
    this.afterRender = () => {
      if (!this._enabled)
        return;
      if (!this.perfEngine.paused) {
        this.perfEngine.nextFrame(window.performance.now());
        if (this.perfEngine.overClock && typeof window.requestIdleCallback !== "undefined") {
          this.perfEngine.idleCbId = requestIdleCallback(this.perfEngine.nextFps);
        }
      }
      if (this.perfEngine) {
        this.perfEngine.end("profiler");
      }
      if (window.performance) {
        window.performance.mark("cpu-started");
        this.perfEngine.startCpuProfiling = true;
      }
      if (this.deepAnalyze) {
      }
    };
    this.deepAnalyze = (_a = props.deepAnalyze) != null ? _a : false;
    this.threeRenderer = props.renderer;
    this.ui = new ThreePerfUI({ perf: this, domElement: props.domElement, backgroundOpacity: props.backgroundOpacity });
    this._visible = (_b = props.visible) != null ? _b : true;
    this._enabled = (_c = props.enabled) != null ? _c : true;
    this.scale = (_d = props.scale) != null ? _d : 1;
    this.anchorX = (_e3 = props.anchorX) != null ? _e3 : "left";
    this.anchorY = (_f = props.anchorY) != null ? _f : "top";
    this.showGraph = (_g = props.showGraph) != null ? _g : true;
    this.memory = (_h = props.memory) != null ? _h : true;
    this.actionToCallUI = (_i = props.actionToCallUI) != null ? _i : "";
    this.guiVisible = (_j = props.guiVisible) != null ? _j : false;
    this.gui.element.parentElement.style.width = "300px";
    window.addEventListener("keypress", this.keypressHandler);
    const overClock = (_k = props.overClock) != null ? _k : true;
    this.perfEngine = new GLPerf({
      perf: this,
      trackGPU: true,
      overClock,
      chartLen: 120,
      // chart ? chart.length : 120,
      chartHz: 60,
      // chart ? chart.hz : 60,
      logsPerSecond: (_l = props.logsPerSecond) != null ? _l : 10,
      gl: props.renderer.getContext(),
      chartLogger: (chart) => {
        this.chart = chart;
      },
      paramLogger: (logger) => {
        if (!this._enabled)
          return;
        const log = {
          maxMemory: logger.maxMemory,
          gpu: logger.gpu,
          cpu: logger.cpu,
          mem: logger.mem,
          fps: logger.fps,
          totalTime: logger.duration,
          frameCount: logger.frameCount
        };
        this.log = log;
        const accumulated = this.accumulated;
        const glRender = this.threeRenderer.info.render;
        accumulated.totalFrames++;
        accumulated.gl.calls += glRender.calls;
        accumulated.gl.triangles += glRender.triangles;
        accumulated.gl.points += glRender.points;
        accumulated.gl.lines += glRender.lines;
        accumulated.log.gpu += logger.gpu;
        accumulated.log.cpu += logger.cpu;
        accumulated.log.mem += logger.mem;
        accumulated.log.fps += logger.fps;
        for (let i = 0; i < maxGl.length; i++) {
          const key2 = maxGl[i];
          const value = glRender[key2];
          if (value > accumulated.max.gl[key2]) {
            accumulated.max.gl[key2] = value;
          }
        }
        for (let i = 0; i < maxLog.length; i++) {
          const key2 = maxLog[i];
          const value = logger[key2];
          if (value > accumulated.max.log[key2]) {
            accumulated.max.log[key2] = value;
          }
        }
        this.accumulated = accumulated;
        this.ui.update();
      }
    });
    const ctx = props.renderer.getContext();
    let glRenderer = null;
    let glVendor = null;
    const rendererInfo = ctx.getExtension("WEBGL_debug_renderer_info");
    const glVersion = ctx.getParameter(ctx.VERSION);
    if (rendererInfo != null) {
      glRenderer = ctx.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      glVendor = ctx.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!glVendor) {
      glVendor = "Unknown vendor";
    }
    if (!glRenderer) {
      glRenderer = ctx.getParameter(ctx.RENDERER);
    }
    this.startTime = performance.now();
    this.infos = {
      version: glVersion,
      renderer: glRenderer,
      vendor: glVendor
    };
    this.rendererRender = this.threeRenderer.render;
    this.threeRenderer.info.autoReset = false;
    this.threeRenderer.render = (scene, camera) => {
      this.renderPassesNumber++;
      this.rendererRender.call(this.threeRenderer, scene, camera);
    };
    this.guiFolder = this.gui.addFolder({ title: "Settings" });
    const perfFolder = this.guiFolder.addFolder({ title: "ThreePerf" });
    perfFolder.addInput(this, "visible", { label: "Visible" });
    perfFolder.addInput(this, "enabled", { label: "Enabled" });
    perfFolder.addInput(this, "anchorX", { label: "xAnchor", options: { left: "left", right: "right" } });
    perfFolder.addInput(this, "anchorY", { label: "yAnchor", options: { top: "top", bottom: "bottom" } });
    perfFolder.addInput(this, "backgroundOpacity", { label: "Background opacity", min: 0, max: 1, step: 0.1 });
    perfFolder.addInput(this, "memory", { label: "Memory" });
    perfFolder.addInput(this, "showGraph", { label: "Charts" });
    perfFolder.addInput(this, "scale", { label: "Scale", min: 0.1, max: 2, step: 0.1 });
    perfFolder.addInput(this, "logsPerSecond", { label: "LogsPerSecond", min: 1, max: 60, step: 1 });
    console.log("ThreePerf inited.");
  }
  begin() {
    this.perfEngine.begin("profiler");
  }
  end() {
    this.afterRender();
    this.renderPassesNumber = 0;
    this.threeRenderer.info.reset();
  }
  dispose() {
    var _a;
    this.ui.dispose();
    (_a = this.gui.element.parentElement) == null ? void 0 : _a.remove();
    window.removeEventListener("keypress", this.keypressHandler);
  }
  //
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.ui.toggleVisibility(value);
  }
  get guiVisible() {
    return this._guiVisible;
  }
  set guiVisible(value) {
    this._guiVisible = value;
    this.gui.element.parentElement.style["display"] = value ? "block" : "none";
  }
  get anchorX() {
    return this._anchorX;
  }
  set anchorX(value) {
    this._anchorX = value;
    if (this._anchorX === "left") {
      this.ui.wrapper.style.left = "0";
      this.ui.wrapper.style.right = "";
    } else {
      this.ui.wrapper.style.left = "";
      this.ui.wrapper.style.right = "0";
    }
  }
  get anchorY() {
    return this._anchorY;
  }
  set anchorY(value) {
    this._anchorY = value;
    if (this._anchorY === "top") {
      this.ui.wrapper.style.top = "0";
      this.ui.wrapper.style.bottom = "";
    } else {
      this.ui.wrapper.style.top = "";
      this.ui.wrapper.style.bottom = "0";
    }
  }
  get showGraph() {
    return this._showGraph;
  }
  set showGraph(value) {
    this._showGraph = value;
    this.ui.toggleCharts(value);
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    this._memory = value;
    this.ui.toggleMemoryInfo(value);
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    this._scale = value;
    this.ui.setScale(value);
  }
  get logsPerSecond() {
    return this.perfEngine.logsPerSecond;
  }
  set logsPerSecond(value) {
    this.perfEngine.logsPerSecond = value;
  }
  get backgroundOpacity() {
    return this.ui._backgroundOpacity;
  }
  set backgroundOpacity(value) {
    this.ui.setBackgroundOpacity(value);
  }
};

// node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte
PerfMonitor[FILENAME] = "node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte";
function PerfMonitor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PerfMonitor);
  let domElement = prop($$props, "domElement", 19, () => document.body), logsPerSecond = prop($$props, "logsPerSecond", 3, 10), showGraph = prop($$props, "showGraph", 3, true), memory = prop($$props, "memory", 3, true), enabled = prop($$props, "enabled", 3, true), visible = prop($$props, "visible", 3, true), actionToCallUI = prop($$props, "actionToCallUI", 3, ""), guiVisible = prop($$props, "guiVisible", 3, false), backgroundOpacity = prop($$props, "backgroundOpacity", 3, 0.7), scale = prop($$props, "scale", 3, 1), anchorX = prop($$props, "anchorX", 3, "left"), anchorY = prop($$props, "anchorY", 3, "top");
  const { renderer, renderStage, mainStage } = useThrelte();
  let perf;
  user_pre_effect(() => {
    perf = new ThreePerf({ domElement: domElement(), renderer });
    return () => perf.dispose();
  });
  user_pre_effect(() => {
    perf.logsPerSecond = logsPerSecond();
    perf.showGraph = showGraph();
    perf.memory = memory();
    perf.enabled = enabled();
    perf.visible = visible();
    perf.actionToCallUI = actionToCallUI();
    perf.guiVisible = guiVisible();
    perf.backgroundOpacity = backgroundOpacity();
    perf.scale = scale();
    perf.anchorX = anchorX();
    perf.anchorY = anchorY();
  });
  useTask(
    () => {
      perf.begin();
    },
    { stage: useStage("monitor-begin", { before: mainStage }) }
  );
  useTask(
    () => {
      perf.end();
    },
    { stage: useStage("monitor-end", { after: renderStage }) }
  );
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  PerfMonitor = hmr(PerfMonitor);
  import.meta.hot.accept((module) => {
    PerfMonitor[HMR].update(module.default);
  });
}
var PerfMonitor_default = PerfMonitor;

// node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte
import {
  BackSide as BackSide2,
  Color as Color10,
  Group as Group9,
  InstancedMesh as InstancedMesh2,
  Mesh as Mesh11,
  ShaderMaterial as ShaderMaterial7,
  SkinnedMesh,
  Vector2 as Vector212
} from "three";
import { toCreasedNormals as toCreasedNormals3 } from "three/examples/jsm/utils/BufferGeometryUtils.js";

// node_modules/@threlte/extras/dist/components/Outlines/shaders.js
var vertexShader7 = `
#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

uniform float thickness;
uniform bool screenspace;
uniform vec2 size;

void main() {
  #if defined (USE_SKINNING)
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif
  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  vec4 tNormal = vec4(normal, 0.0);
  vec4 tPosition = vec4(transformed, 1.0);
  #ifdef USE_INSTANCING
    tNormal = instanceMatrix * tNormal;
    tPosition = instanceMatrix * tPosition;
  #endif
  if (!screenspace) {
    vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  } else {
    vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
    vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
    vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
    clipPosition.xy += offset;
    gl_Position = clipPosition;
  }
}`;
var fragmentShader7 = `
uniform vec3 color;
uniform float opacity;
void main(){
  gl_FragColor = vec4(color, opacity);
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
}
`;

// node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte
Outlines[FILENAME] = "node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte";
var root_23 = add_locations(from_html(`<!> <!>`, 1), Outlines[FILENAME], []);
var root_17 = add_locations(from_html(`<!> <!>`, 1), Outlines[FILENAME], []);
function Outlines($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Outlines);
  let color = prop($$props, "color", 3, "black"), screenspace = prop($$props, "screenspace", 3, false), opacity = prop($$props, "opacity", 3, 1), transparent = prop($$props, "transparent", 3, false), thickness = prop($$props, "thickness", 3, 0.05), toneMapped = prop($$props, "toneMapped", 3, true), angle = prop($$props, "angle", 19, () => Math.PI), polygonOffset = prop($$props, "polygonOffset", 3, false), polygonOffsetFactor = prop($$props, "polygonOffsetFactor", 3, 0), renderOrder = prop($$props, "renderOrder", 3, 0), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "color",
      "screenspace",
      "opacity",
      "transparent",
      "thickness",
      "toneMapped",
      "angle",
      "polygonOffset",
      "polygonOffsetFactor",
      "renderOrder",
      "children",
      "ref"
    ],
    "props"
  );
  const { renderer } = useThrelte();
  const uniforms = {
    screenspace: { value: screenspace() },
    color: { value: new Color10(color()) },
    opacity: { value: opacity() },
    thickness: { value: thickness() },
    size: { value: new Vector212() }
  };
  const group = new Group9();
  ref(group);
  const material2 = new ShaderMaterial7({ side: BackSide2, uniforms, vertexShader: vertexShader7, fragmentShader: fragmentShader7 });
  const parent = useParent();
  let parentMesh = fromStore(parent);
  let geometry = tag(
    user_derived(() => {
      if (!isInstanceOf(parentMesh.current, "Mesh")) return void 0;
      return toCreasedNormals3(parentMesh.current.geometry, angle());
    }),
    "geometry"
  );
  let mesh = tag(
    user_derived(() => {
      if (!isInstanceOf(parentMesh.current, "Mesh")) return;
      if (isInstanceOf(parentMesh.current, "SkinnedMesh")) {
        const nextMesh = new SkinnedMesh();
        nextMesh.bind(parentMesh.current.skeleton, parentMesh.current.bindMatrix);
        return nextMesh;
      } else if (isInstanceOf(parentMesh.current, "InstancedMesh")) {
        const nextMesh = new InstancedMesh2(void 0, void 0, parentMesh.current.count);
        nextMesh.instanceMatrix = parentMesh.current.instanceMatrix;
        return nextMesh;
      }
      return new Mesh11();
    }),
    "mesh"
  );
  user_pre_effect(() => {
    if (get(mesh)) get(mesh).renderOrder = renderOrder();
  });
  user_pre_effect(() => {
    material2.transparent = transparent();
  });
  user_pre_effect(() => {
    material2.toneMapped = toneMapped();
  });
  user_pre_effect(() => {
    material2.polygonOffset = polygonOffset();
  });
  user_pre_effect(() => {
    material2.polygonOffsetFactor = polygonOffsetFactor();
  });
  user_pre_effect(() => {
    material2.uniforms.screenspace.value = screenspace();
  });
  user_pre_effect(() => {
    material2.uniforms.color.value.set(color());
  });
  user_pre_effect(() => {
    material2.uniforms.opacity.value = opacity();
  });
  user_pre_effect(() => {
    material2.uniforms.thickness.value = thickness();
  });
  user_pre_effect(() => {
    renderer.getDrawingBufferSize(material2.uniforms.size.value);
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(
    () => T(node, spread_props(
      {
        get is() {
          return group;
        }
      },
      () => props,
      {
        children: wrap_snippet(Outlines, ($$anchor2, $$slotProps) => {
          var fragment_1 = root_17();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(
            () => T(node_1, {
              get is() {
                return get(mesh);
              },
              children: wrap_snippet(Outlines, ($$anchor3, $$slotProps2) => {
                var fragment_2 = root_23();
                var node_2 = first_child(fragment_2);
                add_svelte_meta(
                  () => T(node_2, {
                    get is() {
                      return get(geometry);
                    }
                  }),
                  "component",
                  Outlines,
                  114,
                  4,
                  { componentTag: "T" }
                );
                var node_3 = sibling(node_2, 2);
                add_svelte_meta(
                  () => T(node_3, {
                    get is() {
                      return material2;
                    }
                  }),
                  "component",
                  Outlines,
                  115,
                  4,
                  { componentTag: "T" }
                );
                append($$anchor3, fragment_2);
              }),
              $$slots: { default: true }
            }),
            "component",
            Outlines,
            113,
            2,
            { componentTag: "T" }
          );
          var node_4 = sibling(node_1, 2);
          add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group })), "render", Outlines, 117, 2);
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    )),
    "component",
    Outlines,
    109,
    0,
    { componentTag: "T" }
  );
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Outlines = hmr(Outlines);
  import.meta.hot.accept((module) => {
    Outlines[HMR].update(module.default);
  });
}
var Outlines_default = Outlines;

// node_modules/@threlte/extras/dist/components/Mask/Mask.svelte
import { ReplaceStencilOp, AlwaysStencilFunc, Mesh as Mesh12 } from "three";
Mask[FILENAME] = "node_modules/@threlte/extras/dist/components/Mask/Mask.svelte";
function Mask($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mask);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 3, 1), colorWrite = prop($$props, "colorWrite", 3, false), depthWrite = prop($$props, "depthWrite", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "colorWrite",
      "depthWrite",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new Mesh12();
  user_effect(() => {
    const { material: material2 } = mesh;
    if (Array.isArray(material2)) return;
    material2.colorWrite = colorWrite();
    material2.depthWrite = depthWrite();
    material2.stencilWrite = true;
    material2.stencilRef = id();
    material2.stencilFunc = AlwaysStencilFunc;
    material2.stencilFail = ReplaceStencilOp;
    material2.stencilZFail = ReplaceStencilOp;
    material2.stencilZPass = ReplaceStencilOp;
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    let $0 = user_derived(() => -id());
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return mesh;
          },
          get renderOrder() {
            return get($0);
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Mask, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: mesh })), "render", Mask, 43, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Mask,
      37,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Mask = hmr(Mask);
  import.meta.hot.accept((module) => {
    Mask[HMR].update(module.default);
  });
}
var Mask_default = Mask;

// node_modules/@threlte/extras/dist/components/BakeShadows/BakeShadows.svelte
BakeShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/BakeShadows/BakeShadows.svelte";
function BakeShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BakeShadows);
  const suspended = fromStore(useSuspense().suspended);
  const { renderer } = useThrelte();
  user_pre_effect(() => {
    if (suspended.current) {
      return;
    }
    const { autoUpdate } = renderer.shadowMap;
    renderer.shadowMap.autoUpdate = false;
    renderer.shadowMap.needsUpdate = true;
    return () => {
      renderer.shadowMap.autoUpdate = autoUpdate;
      renderer.shadowMap.needsUpdate = true;
    };
  });
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  BakeShadows = hmr(BakeShadows);
  import.meta.hot.accept((module) => {
    BakeShadows[HMR].update(module.default);
  });
}
var BakeShadows_default = BakeShadows;

// node_modules/@threlte/extras/dist/components/Detailed/Detailed.svelte
import { LOD } from "three";
Detailed[FILENAME] = "node_modules/@threlte/extras/dist/components/Detailed/Detailed.svelte";
function Detailed($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Detailed);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "children"], "props");
  const lod = new LOD();
  injectPlugin("detailed", (args) => {
    const parent = useParent();
    if (strict_equals(parent.current, lod, false)) return;
    let previousRef;
    let previousDistance = args.props.distance;
    let previousHysteresis = args.props.hysteresis;
    const ref2 = tag(user_derived(() => isInstanceOf(args.ref, "Object3D") ? args.ref : void 0), "ref");
    const distance = tag(user_derived(() => args.props.distance ?? 0), "distance");
    const hysteresis = tag(user_derived(() => args.props.hysteresis ?? 0), "hysteresis");
    const addLevel = (ref3, distance2, hysteresis2) => {
      lod.addLevel(ref3, distance2, hysteresis2);
    };
    const removeLevel = (ref3) => {
      const i = lod.levels.findIndex((l) => strict_equals(l.object, ref3));
      if (i > -1) {
        lod.levels.splice(i, 1);
      }
    };
    const mutateLevel = (ref3, distance2, hysteresis2) => {
      untrack(() => {
        const level = lod.levels.find((l) => strict_equals(l.object, ref3));
        if (!level) return;
        level.distance = distance2;
        level.hysteresis = hysteresis2;
      });
    };
    observe.pre(() => [get(ref2), get(distance), get(hysteresis)], ([ref3, distance2, hysteresis2]) => {
      if (strict_equals(ref3, previousRef, false)) {
        if (previousRef) removeLevel(previousRef);
        if (ref3) addLevel(ref3, distance2, hysteresis2);
        previousRef = ref3;
      }
      if (ref3 && (strict_equals(distance2, previousDistance, false) || strict_equals(hysteresis2, previousHysteresis, false))) {
        mutateLevel(ref3, distance2, hysteresis2);
        previousDistance = distance2;
        previousHysteresis = hysteresis2;
      }
    });
    onDestroy(() => {
      if (get(ref2)) removeLevel(get(ref2));
    });
    return { pluginProps: ["distance", "hysteresis"] };
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return lod;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Detailed, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: lod })), "render", Detailed, 78, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Detailed,
      73,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Detailed = hmr(Detailed);
  import.meta.hot.accept((module) => {
    Detailed[HMR].update(module.default);
  });
}
var Detailed_default = Detailed;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/fragment.js
var fragmentShader8 = `void main() {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	discard;
}
`;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/vertex.js
var vertexShader8 = `void main() {}`;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte
MeshDiscardMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte";
function MeshDiscardMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshDiscardMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "children", "ref"], "props");
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(
    () => component(node, () => T.ShaderMaterial, ($$anchor2, T_ShaderMaterial) => {
      $$ownership_validator.binding("ref", T_ShaderMaterial, ref);
      T_ShaderMaterial($$anchor2, spread_props(
        {
          get fragmentShader() {
            return fragmentShader8;
          },
          get vertexShader() {
            return vertexShader8;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(MeshDiscardMaterial, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, ref), "render", MeshDiscardMaterial, 16, 2);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      ));
    }),
    "component",
    MeshDiscardMaterial,
    10,
    0,
    { componentTag: "T.ShaderMaterial" }
  );
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  MeshDiscardMaterial = hmr(MeshDiscardMaterial);
  import.meta.hot.accept((module) => {
    MeshDiscardMaterial[HMR].update(module.default);
  });
}
var MeshDiscardMaterial_default = MeshDiscardMaterial;

// node_modules/@threlte/extras/dist/components/Resize/Resize.svelte
import { Box3 as Box311, Group as Group10 } from "three";
Resize[FILENAME] = "node_modules/@threlte/extras/dist/components/Resize/Resize.svelte";
var _box = new Box311();
function Resize($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Resize);
  var $$ownership_validator = create_ownership_validator($$props);
  const { renderStage } = useThrelte();
  let auto = prop($$props, "auto", 3, false), box = prop($$props, "box", 3, _box), stage = prop($$props, "stage", 19, () => useStage("<Resize>", { before: renderStage })), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "axis",
      "auto",
      "box",
      "precise",
      "onresize",
      "stage",
      "ref",
      "children"
    ],
    "props"
  );
  const group = new Group10();
  const inner = new Group10();
  const outer = new Group10();
  const doResize = () => {
    outer.matrixWorld.identity();
    const { max, min } = box().setFromObject(inner, $$props.precise);
    const width2 = max.x - min.x;
    const height2 = max.y - min.y;
    const depth = max.z - min.z;
    const denominator = strict_equals($$props.axis, "x") ? width2 : strict_equals($$props.axis, "y") ? height2 : strict_equals($$props.axis, "z") ? depth : Math.max(width2, height2, depth);
    outer.scale.setScalar(1 / denominator);
    $$props.onresize?.();
  };
  const { start: scheduleResizing, stop } = useTask(
    () => {
      doResize();
      stop();
    },
    { autoStart: false, stage: stage() }
  );
  const resize = scheduleResizing;
  observe(() => [$$props.axis, $$props.precise], scheduleResizing);
  const plugin = (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    observe.pre(() => [args.ref], () => {
      if (auto()) scheduleResizing();
      return () => {
        if (auto()) scheduleResizing();
      };
    });
  };
  var $$exports = {
    get resize() {
      return resize;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return group;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Resize, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => T(node_1, {
                get is() {
                  return outer;
                },
                children: wrap_snippet(Resize, ($$anchor3, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_2 = first_child(fragment_2);
                  add_svelte_meta(
                    () => T(node_2, {
                      get is() {
                        return inner;
                      },
                      children: wrap_snippet(Resize, ($$anchor4, $$slotProps3) => {
                        var fragment_3 = comment();
                        var node_3 = first_child(fragment_3);
                        add_svelte_meta(
                          () => InjectPlugin_default(node_3, {
                            name: "resize",
                            plugin,
                            children: wrap_snippet(Resize, ($$anchor5, $$slotProps4) => {
                              var fragment_4 = comment();
                              var node_4 = first_child(fragment_4);
                              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group, resize: scheduleResizing })), "render", Resize, 99, 8);
                              append($$anchor5, fragment_4);
                            }),
                            $$slots: { default: true }
                          }),
                          "component",
                          Resize,
                          95,
                          6,
                          { componentTag: "InjectPlugin" }
                        );
                        append($$anchor4, fragment_3);
                      }),
                      $$slots: { default: true }
                    }),
                    "component",
                    Resize,
                    94,
                    4,
                    { componentTag: "T" }
                  );
                  append($$anchor3, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              Resize,
              93,
              2,
              { componentTag: "T" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Resize,
      88,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Resize = hmr(Resize);
  import.meta.hot.accept((module) => {
    Resize[HMR].update(module.default);
  });
}
var Resize_default = Resize;

// node_modules/@threlte/extras/dist/components/CubeCamera/CubeCamera.svelte
import { Group as Group11 } from "three";
CubeCamera3[FILENAME] = "node_modules/@threlte/extras/dist/components/CubeCamera/CubeCamera.svelte";
var root_18 = add_locations(from_html(`<!> <!>`, 1), CubeCamera3[FILENAME], []);
function CubeCamera3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CubeCamera3);
  var $$ownership_validator = create_ownership_validator($$props);
  const $started = () => (validate_store(started, "started"), store_get(started, "$started", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let background = prop($$props, "background", 3, "auto"), far = prop($$props, "far", 3, 1e3), fog = prop($$props, "fog", 3, "auto"), frames = prop($$props, "frames", 3, Infinity), near = prop($$props, "near", 3, 0.1), resolution = prop($$props, "resolution", 3, 256), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "background",
      "far",
      "fog",
      "frames",
      "near",
      "onupdatestart",
      "onupdatestop",
      "resolution",
      "children",
      "ref"
    ],
    "props"
  );
  const { camera, renderTarget } = useCubeCamera(() => near(), () => far(), () => resolution());
  const { renderer, scene } = useThrelte();
  const group = new Group11();
  const inner = new Group11();
  let count = 0;
  const update = () => {
    if (count < frames()) {
      inner.visible = false;
      const originalFog = scene.fog;
      const originalBackground = scene.background;
      scene.background = strict_equals(background(), "auto") ? originalBackground : background();
      scene.fog = strict_equals(fog(), "auto") ? originalFog : fog();
      camera.update(renderer, scene);
      scene.background = originalBackground;
      scene.fog = originalFog;
      inner.visible = true;
      count += 1;
    } else {
      stop();
      $$props.onupdatestop?.();
    }
  };
  const { start, stop, started } = useTask(update, { autoStart: false });
  const restart = () => {
    if ($started()) {
      stop();
      $$props.onupdatestop?.();
    }
    count = 0;
    start();
    $$props.onupdatestart?.();
  };
  observe(() => [background(), far(), near(), fog(), frames(), resolution()], restart);
  var $$exports = {
    get camera() {
      return camera;
    },
    get renderTarget() {
      return renderTarget;
    },
    get update() {
      return update;
    },
    get restart() {
      return restart;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return group;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(CubeCamera3, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_18();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(
              () => T(node_1, {
                get is() {
                  return camera;
                }
              }),
              "component",
              CubeCamera3,
              74,
              2,
              { componentTag: "T" }
            );
            var node_2 = sibling(node_1, 2);
            add_svelte_meta(
              () => T(node_2, {
                get is() {
                  return inner;
                },
                children: wrap_snippet(CubeCamera3, ($$anchor3, $$slotProps2) => {
                  var fragment_2 = comment();
                  var node_3 = first_child(fragment_2);
                  add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => ({ camera, ref: group, renderTarget, restart, update })), "render", CubeCamera3, 76, 4);
                  append($$anchor3, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              CubeCamera3,
              75,
              2,
              { componentTag: "T" }
            );
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      CubeCamera3,
      69,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  CubeCamera3 = hmr(CubeCamera3);
  import.meta.hot.accept((module) => {
    CubeCamera3[HMR].update(module.default);
  });
}
var CubeCamera_default = CubeCamera3;

// node_modules/@threlte/extras/dist/components/GradientTexture/linear/LinearGradientTexture.svelte
import { CanvasTexture as CanvasTexture2 } from "three";
LinearGradientTexture[FILENAME] = "node_modules/@threlte/extras/dist/components/GradientTexture/linear/LinearGradientTexture.svelte";
function LinearGradientTexture($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinearGradientTexture);
  var $$ownership_validator = create_ownership_validator($$props);
  let width2 = prop($$props, "width", 3, 1024), height2 = prop($$props, "height", 3, 1024), startX = prop($$props, "startX", 3, 0), startY = prop($$props, "startY", 3, 0), endX = prop($$props, "endX", 3, 0), endY = prop($$props, "endY", 19, height2), stops = prop($$props, "stops", 19, () => [{ offset: 0, color: "black" }, { offset: 1, color: "white" }]), attach = prop($$props, "attach", 3, "map"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "startX",
      "startY",
      "endX",
      "endY",
      "stops",
      "attach",
      "children",
      "ref"
    ],
    "props"
  );
  const canvas = new OffscreenCanvas(0, 0);
  const context = canvas.getContext("2d");
  if (strict_equals(context, null)) {
    throw new Error("canvas texture context is null");
  }
  const texture = new CanvasTexture2(canvas);
  user_pre_effect(() => {
    canvas.width = width2();
  });
  user_pre_effect(() => {
    canvas.height = height2();
  });
  observe(() => [$$props.wrapS, $$props.wrapT], () => {
    texture.needsUpdate = true;
    invalidate();
  });
  const gradient = tag(
    user_derived(() => {
      const gradient2 = context.createLinearGradient(startX(), startY(), endX(), endY());
      addStops(gradient2, stops());
      return gradient2;
    }),
    "gradient"
  );
  const { invalidate } = useThrelte();
  user_effect(() => {
    context.save();
    context.fillStyle = get(gradient);
    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
    context.restore();
    texture.needsUpdate = true;
    invalidate();
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return texture;
          },
          get attach() {
            return attach();
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(LinearGradientTexture, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: texture })), "render", LinearGradientTexture, 74, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      LinearGradientTexture,
      68,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  LinearGradientTexture = hmr(LinearGradientTexture);
  import.meta.hot.accept((module) => {
    LinearGradientTexture[HMR].update(module.default);
  });
}
var LinearGradientTexture_default = LinearGradientTexture;

// node_modules/@threlte/extras/dist/components/UvMaterial/UvMaterial.svelte
import { ShaderMaterial as ShaderMaterial8 } from "three";
UvMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/UvMaterial/UvMaterial.svelte";
var vertexShader9 = `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
		}
	`;
var fragmentShader9 = `
		varying vec2 vUv;
		void main() {
			gl_FragColor = vec4(vUv, 0.0, 1.0);
		}
	`;
function UvMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, UvMaterial);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "children", "ref"], "restProps");
  const material2 = new ShaderMaterial8({ fragmentShader: fragmentShader9, vertexShader: vertexShader9 });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return material2;
          }
        },
        () => restProps,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(UvMaterial, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material2 })), "render", UvMaterial, 39, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      UvMaterial,
      34,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  UvMaterial = hmr(UvMaterial);
  import.meta.hot.accept((module) => {
    UvMaterial[HMR].update(module.default);
  });
}
var UvMaterial_default = UvMaterial;

// node_modules/@threlte/extras/dist/components/View/InnerView.svelte
import { Vector4 as Vector45 } from "three";

// node_modules/@threlte/extras/dist/components/View/OffscreenObserver.svelte.js
var OffscreenObserver = class {
  #isOffscreen = tag(state(false), "OffscreenObserver.isOffscreen");
  get isOffscreen() {
    return get(this.#isOffscreen);
  }
  set isOffscreen(value) {
    set(this.#isOffscreen, value, true);
  }
  constructor(getElement) {
    observe(() => [getElement()], ([element2]) => {
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          this.isOffscreen = !entry.isIntersecting;
        }
      });
      observer.observe(element2);
      return () => {
        observer.disconnect();
      };
    });
  }
};

// node_modules/@threlte/extras/dist/components/View/InnerView.svelte
InnerView[FILENAME] = "node_modules/@threlte/extras/dist/components/View/InnerView.svelte";
function InnerView($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InnerView);
  const offscreenObserver = new OffscreenObserver(() => $$props.dom);
  const parentContext = useThrelte();
  createDOMContext({ dom: $$props.dom, canvas: parentContext.canvas });
  createCacheContext();
  const { scene } = createSceneContext();
  createParentContext(scene);
  createParentObject3DContext(scene);
  const { camera } = createCameraContext();
  createUserContext();
  const { renderer, renderStage, canvas } = useThrelte();
  const originalViewport = new Vector45();
  const originalScissor = new Vector45();
  let originalScissorTest;
  const { start, stop } = useTask(
    /* @__PURE__ */ Symbol("<View>"),
    () => {
      if (offscreenObserver.isOffscreen) return;
      const { left: trackLeft, bottom: trackBottom, width: width2, height: height2 } = $$props.dom.getBoundingClientRect();
      const { bottom: canvasBottom, left: canvasLeft } = canvas.getBoundingClientRect();
      const bottom = canvasBottom - trackBottom;
      const left = trackLeft - canvasLeft;
      renderer.getScissor(originalScissor);
      renderer.getViewport(originalViewport);
      originalScissorTest = renderer.getScissorTest();
      renderer.setViewport(left, bottom, width2, height2);
      renderer.setScissor(left, bottom, width2, height2);
      renderer.setScissorTest(true);
      renderer.render(scene, camera.current);
      renderer.setViewport(originalViewport);
      renderer.setScissor(originalScissor);
      renderer.setScissorTest(originalScissorTest);
    },
    { stage: renderStage, autoStart: false }
  );
  user_effect(() => {
    if (offscreenObserver.isOffscreen) {
      stop();
    } else {
      start();
    }
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", InnerView, 80, 0);
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  InnerView = hmr(InnerView);
  import.meta.hot.accept((module) => {
    InnerView[HMR].update(module.default);
  });
}
var InnerView_default = InnerView;

// node_modules/@threlte/extras/dist/components/View/View.svelte
View[FILENAME] = "node_modules/@threlte/extras/dist/components/View/View.svelte";
function View($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, View);
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => InnerView_default(node_1, {
          get dom() {
            return $$props.dom;
          },
          children: wrap_snippet(View, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", View, 10, 4);
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        View,
        9,
        2,
        { componentTag: "InnerView" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.dom) $$render(consequent);
      }),
      "if",
      View,
      8,
      0
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  View = hmr(View);
  import.meta.hot.accept((module) => {
    View[HMR].update(module.default);
  });
}
var View_default = View;

// node_modules/@threlte/extras/dist/components/Wireframe/Wireframe.svelte
import {
  BufferGeometry as BufferGeometry7,
  Mesh as Mesh13,
  Material,
  WireframeGeometry,
  BufferAttribute as BufferAttribute9,
  Uniform,
  Color as Color11
} from "three";

// node_modules/@threlte/extras/dist/components/Wireframe/material.js
import { DoubleSide as DoubleSide9 } from "three";
var WireframeMaterialShaders = {
  vertex: `
attribute vec3 barycentric;

varying vec3 v_edges_Barycentric;
varying vec3 v_edges_Position;

void initWireframe() {
  v_edges_Barycentric = barycentric;
  v_edges_Position = position.xyz;
}`,
  fragment: `
#ifndef PI
  #define PI 3.1415926535897932384626433832795
#endif

varying vec3 v_edges_Barycentric;
varying vec3 v_edges_Position;

uniform float strokeOpacity;
uniform float fillOpacity;
uniform float fillMix;
uniform float thickness;
uniform bool colorBackfaces;

// Dash
uniform bool dashInvert;
uniform bool dash;
uniform bool dashOnly;
uniform float dashRepeats;
uniform float dashLength;

// Squeeze
uniform bool squeeze;
uniform float squeezeMin;
uniform float squeezeMax;

// Colors
uniform vec3 stroke;
uniform vec3 backfaceStroke;
uniform vec3 fill;

// This is like
float wireframe_aastep(float threshold, float dist) {
  float afwidth = fwidth(dist) * 0.5;
  return smoothstep(threshold - afwidth, threshold + afwidth, dist);
}

float wireframe_map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float getWireframe() {
  vec3 barycentric = v_edges_Barycentric;

  // Distance from center of each triangle to its edges.
  float d = min(min(barycentric.x, barycentric.y), barycentric.z);

  // for dashed rendering, we can use this to get the 0 .. 1 value of the line length
  float positionAlong = max(barycentric.x, barycentric.y);
  if (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {
    positionAlong = 1.0 - positionAlong;
  }

  // the thickness of the stroke
  float computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);

  // if we want to shrink the thickness toward the center of the line segment
  if (squeeze) {
    computedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));
  }

  // Create dash pattern
  if (dash) {
    // here we offset the stroke position depending on whether it
    // should overlap or not
    float offset = 1.0 / dashRepeats * dashLength / 2.0;
    if (!dashInvert) {
      offset += 1.0 / dashRepeats / 2.0;
    }

    // if we should animate the dash or not
    // if (dashAnimate) {
    // 	offset += time * 0.22;
    // }

    // create the repeating dash pattern
    float pattern = fract((positionAlong + offset) * dashRepeats);
    computedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);
  }

  // compute the anti-aliased stroke edge  
  float edge = 1.0 - wireframe_aastep(computedThickness, d);

  return edge;
}`
};
var setWireframeOverride = (material2, uniforms) => {
  material2.onBeforeCompile = (shader) => {
    Object.assign(shader.uniforms, uniforms);
    shader.vertexShader = shader.vertexShader.replace("void main() {", `
${WireframeMaterialShaders.vertex}
void main() {
  initWireframe();`);
    shader.fragmentShader = shader.fragmentShader.replace("void main() {", `
${WireframeMaterialShaders.fragment}
void main() {`);
    shader.fragmentShader = shader.fragmentShader.replace("#include <color_fragment>", `
#include <color_fragment>
float edge = getWireframe();
vec4 colorStroke = vec4(stroke, edge);
#ifdef FLIP_SIDED
colorStroke.rgb = backfaceStroke;
#endif
vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));
vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);

diffuseColor.rgb = outColor.rgb;
diffuseColor.a *= outColor.a;`);
  };
  material2.side = DoubleSide9;
  material2.transparent = true;
};

// node_modules/@threlte/extras/dist/components/Wireframe/Wireframe.svelte
Wireframe[FILENAME] = "node_modules/@threlte/extras/dist/components/Wireframe/Wireframe.svelte";
var getBarycentricCoordinates = (geometry, removeEdge) => {
  const position2 = geometry.getAttribute("position");
  const array = new Float32Array(position2.count * 9);
  for (let i = 0, l = array.length; i < l; i += 9) {
    const even = strict_equals(i % 2, 0);
    const Q3 = removeEdge ? 1 : 0;
    if (even) {
      array[i + 2] = 1;
      array[i + 4] = 1;
      array[i + 6] = 1;
      array[i + 8] = Q3;
    } else {
      array[i + 1] = 1;
      array[i + 5] = 1;
      array[i + 6] = 1;
      array[i + 8] = Q3;
    }
  }
  return new BufferAttribute9(array, 3);
};
var setBarycentricCoordinates = (geometry, simplify) => {
  if (geometry.index) {
    const nonIndexedGeo = geometry.toNonIndexed();
    geometry.copy(nonIndexedGeo);
    geometry.setIndex(null);
  }
  const newBarycentric = getBarycentricCoordinates(geometry, simplify);
  geometry.setAttribute("barycentric", newBarycentric);
};
function Wireframe($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Wireframe);
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let simplify = prop($$props, "simplify", 3, false), rest = rest_props($$props, ["$$slots", "$$events", "$$legacy", "simplify"], "rest");
  const parent = useParent();
  const fillOpacity = new Uniform(0);
  const strokeOpacity = new Uniform(0);
  const fillMix = new Uniform(0);
  const thickness = new Uniform(0);
  const colorBackfaces = new Uniform(false);
  const dashInvert = new Uniform(true);
  const dash = new Uniform(false);
  const dashRepeats = new Uniform(0);
  const dashLength = new Uniform(0);
  const squeeze = new Uniform(false);
  const squeezeMin = new Uniform(0);
  const squeezeMax = new Uniform(0);
  const stroke = new Uniform(new Color11());
  const backfaceStroke = new Uniform(new Color11());
  const fill = new Uniform(new Color11());
  user_pre_effect(() => {
    fillOpacity.value = $$props.fillOpacity ?? 0;
  });
  user_pre_effect(() => {
    fillMix.value = $$props.fillMix ?? 0;
  });
  user_pre_effect(() => {
    strokeOpacity.value = $$props.strokeOpacity ?? 1;
  });
  user_pre_effect(() => {
    thickness.value = $$props.thickness ?? 0.05;
  });
  user_pre_effect(() => {
    colorBackfaces.value = $$props.colorBackfaces ?? false;
  });
  user_pre_effect(() => {
    dash.value = $$props.dash ?? false;
  });
  user_pre_effect(() => {
    dashInvert.value = $$props.dashInvert ?? true;
  });
  user_pre_effect(() => {
    dashRepeats.value = $$props.dashRepeats ?? 4;
  });
  user_pre_effect(() => {
    dashLength.value = $$props.dashLength ?? 0.5;
  });
  user_pre_effect(() => {
    squeeze.value = $$props.squeeze ?? false;
  });
  user_pre_effect(() => {
    squeezeMin.value = $$props.squeezeMin ?? 0.2;
  });
  user_pre_effect(() => {
    squeezeMax.value = $$props.squeezeMax ?? 1;
  });
  user_pre_effect(() => {
    stroke.value.set($$props.stroke ?? "#ff0000");
  });
  user_pre_effect(() => {
    fill.value.set($$props.fill ?? "#00ff00");
  });
  user_pre_effect(() => {
    backfaceStroke.value.set($$props.backfaceStroke ?? "#0000ff");
  });
  user_pre_effect(() => {
    const parentMesh = $parent();
    if (!isInstanceOf(parentMesh, "Mesh")) {
      return;
    }
    if (strict_equals(parentMesh.geometry.type, "WireframeGeometry")) {
      console.error("Wireframe: WireframeGeometry is not supported.");
      return;
    }
    if (!parentMesh.geometry) {
      console.error("Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop.");
      return;
    }
    const material2 = parentMesh.material;
    const originalMaterial = material2.clone();
    const originalGeometry = parentMesh.geometry.clone();
    setWireframeOverride(material2, {
      fillOpacity,
      strokeOpacity,
      fillMix,
      thickness,
      colorBackfaces,
      dashInvert,
      dash,
      dashRepeats,
      dashLength,
      squeeze,
      squeezeMin,
      squeezeMax,
      stroke,
      backfaceStroke,
      fill
    });
    setBarycentricCoordinates(parentMesh.geometry, simplify());
    return () => {
      parentMesh.geometry.copy(originalGeometry);
      originalGeometry.dispose();
      material2.dispose();
      parentMesh.material = originalMaterial;
    };
  });
  var $$exports = { ...legacy_api() };
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Wireframe = hmr(Wireframe);
  import.meta.hot.accept((module) => {
    Wireframe[HMR].update(module.default);
  });
}
var Wireframe_default = Wireframe;

// node_modules/@threlte/extras/dist/transitions/transltions.svelte.js
var el = strict_equals(typeof window, "undefined", false) ? document.createElement("div") : void 0;
var transitions = () => {
  injectPlugin("transitions", (args) => {
    if (!el) return;
    if (!args.props.in && !args.props.out && !args.props.transition) return;
    const { invalidate } = useThrelte();
    el.dispatchEvent = (e) => {
      if (strict_equals(e.type, "introstart")) {
        args.props.onintrostart?.();
      } else if (strict_equals(e.type, "outrostart")) {
        args.props.onoutrostart?.();
      } else if (strict_equals(e.type, "introend")) {
        args.props.onintroend?.();
      } else if (strict_equals(e.type, "outroend")) {
        args.props.onoutroend?.();
      }
      return true;
    };
    const convertTransition = (transitionC) => {
      return (_node, _params, options) => {
        const t = transitionC(args.ref, { direction: options.direction });
        return {
          ...t,
          tick(...args2) {
            invalidate();
            t?.tick?.(...args2);
          }
        };
      };
    };
    const props = ["in", "out", "transition"];
    const globalFlags = { in: 5, out: 6, transition: 7 };
    const localFlags = { in: 1, out: 2, transition: 3 };
    for (const prop2 of props) {
      const t = args.props[prop2];
      if (t) {
        const global2 = "global" in t;
        const flag = global2 ? globalFlags[prop2] : localFlags[prop2];
        transition(flag, el, () => convertTransition(t));
      }
    }
    return {
      pluginProps: [
        "in",
        "out",
        "transition",
        "onintrostart",
        "onoutrostart",
        "onintroend",
        "onoutroend"
      ]
    };
  });
};

// node_modules/@threlte/extras/dist/transitions/createTransition.js
var createTransition = (transition2) => transition2;

// node_modules/@threlte/extras/dist/transitions/global.js
var global = (transition2) => {
  return Object.assign(transition2, {
    global: true
  });
};

// node_modules/@threlte/extras/dist/suspense/Suspense.svelte
import { Group as Group12 } from "three";
Suspense[FILENAME] = "node_modules/@threlte/extras/dist/suspense/Suspense.svelte";
var root5 = add_locations(from_html(`<!> <!>`, 1), Suspense[FILENAME], []);
function Suspense($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Suspense);
  const $suspended = () => (validate_store(suspended, "suspended"), store_get(suspended, "$suspended", $$stores));
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let final = prop($$props, "final", 3, false);
  const { suspended, errors, setFinal } = createSuspenseContext({ final: final() });
  user_effect(() => setFinal(final()));
  user_effect(() => {
    if (!$suspended()) $$props.onload?.();
  });
  user_effect(() => {
    if ($suspended()) $$props.onsuspend?.();
  });
  user_effect(() => {
    if ($errors().length > 0) $$props.onerror?.($errors());
  });
  const { invalidate } = useThrelte();
  const group = new Group12();
  const parentObject3D = useParentObject3D();
  watch([parentObject3D, suspended, errors], ([parent, suspended2, errors2]) => {
    if (!parent) return;
    if (suspended2 || errors2.length) {
      parent.remove(group);
      invalidate();
      return;
    }
    parent.add(group);
    invalidate();
    return () => {
      parent.remove(group);
      invalidate();
    };
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = root5();
  var node = first_child(fragment2);
  add_svelte_meta(
    () => T(node, {
      get is() {
        return group;
      },
      attach: false,
      children: wrap_snippet(Suspense, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ suspended: $suspended(), errors: $errors() })), "render", Suspense, 64, 2);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Suspense,
    60,
    0,
    { componentTag: "T" }
  );
  var node_2 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_3, () => $$props.error ?? noop, () => ({ errors: $errors() })), "render", Suspense, 68, 2);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_4 = first_child(fragment_3);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          add_svelte_meta(() => snippet(node_5, () => $$props.fallback ?? noop), "render", Suspense, 70, 2);
          append($$anchor3, fragment_4);
        };
        add_svelte_meta(
          () => if_block(
            node_4,
            ($$render) => {
              if ($suspended()) $$render(consequent_1);
            },
            true
          ),
          "if",
          Suspense,
          69,
          0
        );
      }
      append($$anchor2, fragment_3);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if ($errors().length) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Suspense,
      67,
      0
    );
  }
  append($$anchor, fragment2);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Suspense = hmr(Suspense);
  import.meta.hot.accept((module) => {
    Suspense[HMR].update(module.default);
  });
}
var Suspense_default = Suspense;

// node_modules/@threlte/extras/dist/suspense/onReveal.js
var onReveal = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  let cleanup;
  const mounted = writable(false);
  onMount(() => {
    if (!ctx)
      cleanup = callback();
    mounted.set(true);
  });
  if (!ctx) {
    onDestroy(() => cleanup?.());
    return;
  }
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && !suspended)
      cleanup = callback();
    return () => cleanup?.();
  });
};

// node_modules/@threlte/extras/dist/suspense/onSuspend.js
var onSuspend = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  if (!ctx)
    return;
  const mounted = writable(false);
  onMount(() => {
    mounted.set(true);
  });
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && suspended)
      callback();
  });
};

// node_modules/@threlte/extras/dist/components/portals/usePortalContext.svelte.js
var createPortalContext = () => {
  return new SvelteMap();
};
var usePortalContext = () => {
  return useThrelteUserContext("threlte-portals", createPortalContext());
};

// node_modules/@threlte/extras/dist/components/portals/Portal.svelte
Portal[FILENAME] = "node_modules/@threlte/extras/dist/components/portals/Portal.svelte";
function Portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal);
  let id = prop($$props, "id", 3, "default");
  user_pre_effect(() => {
    if ($$props.object) {
      console.error('<Portal>: "object" prop has been removed. Use "attach" instead.');
    }
  });
  const portals = usePortalContext();
  user_pre_effect(() => {
    if (!$$props.children) return;
    if (!portals.has(id())) {
      portals.set(id(), new SvelteSet());
    }
    portals.get(id())?.add($$props.children);
    return () => portals.get(id())?.delete($$props.children);
  });
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  Portal = hmr(Portal);
  import.meta.hot.accept((module) => {
    Portal[HMR].update(module.default);
  });
}
var Portal_default = Portal;

// node_modules/@threlte/extras/dist/components/portals/PortalTarget.svelte
PortalTarget[FILENAME] = "node_modules/@threlte/extras/dist/components/portals/PortalTarget.svelte";
function PortalTarget($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PortalTarget);
  let id = prop($$props, "id", 3, "default");
  const portals = usePortalContext();
  const childrenArray = tag(user_derived(() => portals.get(id())), "childrenArray");
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      validate_each_keys(() => get(childrenArray), (children) => children);
      add_svelte_meta(
        () => each(node_1, 16, () => get(childrenArray), (children) => children, ($$anchor3, children) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => children), "render", PortalTarget, 16, 4);
          append($$anchor3, fragment_2);
        }),
        "each",
        PortalTarget,
        15,
        2
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(get(childrenArray), void 0, false)) $$render(consequent);
      }),
      "if",
      PortalTarget,
      14,
      0
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  PortalTarget = hmr(PortalTarget);
  import.meta.hot.accept((module) => {
    PortalTarget[HMR].update(module.default);
  });
}
var PortalTarget_default = PortalTarget;

// node_modules/@threlte/extras/dist/components/Text/Text.svelte
Text2[FILENAME] = "node_modules/@threlte/extras/dist/components/Text/Text.svelte";
function Text2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text2);
  var $$ownership_validator = create_ownership_validator($$props);
  let font = prop($$props, "font", 3, null), characters = prop($$props, "characters", 3, null), sdfGlyphSize = prop($$props, "sdfGlyphSize", 3, null), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "font",
      "characters",
      "sdfGlyphSize",
      "ref",
      "onsync",
      "children"
    ],
    "props"
  );
  const text = new Text();
  const { invalidate } = useThrelte();
  const onUpdate = async () => {
    (await track_reactivity_loss(tick()))();
    text.sync(() => {
      invalidate();
      $$props.onsync?.();
    });
  };
  const propsToListenTo = [
    "text",
    "anchorX",
    "anchorY",
    "curveRadius",
    "direction",
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "glyphGeometryDetail",
    "sdfGlyphSize",
    "outlineWidth",
    "outlineColor",
    "outlineOpacity",
    "outlineBlur",
    "outlineOffsetX",
    "outlineOffsetY",
    "strokeWidth",
    "strokeColor",
    "strokeOpacity",
    "fillOpacity",
    "characters",
    "colorRanges"
  ];
  observe(() => propsToListenTo.map((key2) => props[key2]), () => {
    onUpdate();
  });
  const suspend = useSuspense();
  user_pre_effect(() => {
    suspend(new Promise((res) => preloadFont(
      {
        font: font(),
        characters: characters(),
        sdfGlyphSize: sdfGlyphSize()
      },
      res
    )));
  });
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return text;
          }
        },
        () => props,
        {
          get font() {
            return font();
          },
          get characters() {
            return characters();
          },
          get sdfGlyphSize() {
            return sdfGlyphSize();
          },
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Text2, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: text })), "render", Text2, 87, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Text2,
      79,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Text2 = hmr(Text2);
  import.meta.hot.accept((module) => {
    Text2[HMR].update(module.default);
  });
}
var Text_default = Text2;

// node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte
import { AudioListener as ThreeAudioListener } from "three";

// node_modules/@threlte/extras/dist/audio/useThrelteAudio.js
var audioListeners = /* @__PURE__ */ new Map();
var audioCtx = {
  audioListeners,
  addAudioListener: (listener, id = "default") => {
    if (audioListeners.has(id)) {
      console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
      return;
    }
    audioListeners.set(id, listener);
  },
  removeAudioListener: (id = "default") => {
    if (!audioListeners.has(id)) {
      console.warn(`No AudioListener with the id "${id}" found, aborting.`);
      return;
    }
    audioListeners.delete(id);
  },
  getAudioListener: (id = "default") => {
    if (!audioListeners.has(id)) {
      console.warn(`No AudioListener with the id "${id}" found, aborting.`);
      return;
    }
    return audioListeners.get(id);
  }
};
function useThrelteAudio() {
  return useThrelteUserContext("threlte-audio", audioCtx);
}

// node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte
AudioListener[FILENAME] = "node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte";
function AudioListener($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AudioListener);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "masterVolume",
      "ref",
      "children"
    ],
    "props"
  );
  const listener = new ThreeAudioListener();
  const audioContext = listener.context;
  const resumeContext = () => listener.context.resume();
  user_pre_effect(() => {
    if (strict_equals($$props.masterVolume, void 0, false)) {
      listener.setMasterVolume($$props.masterVolume);
    }
  });
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(listener, $$props.id);
  onDestroy(() => {
    removeAudioListener($$props.id);
  });
  var $$exports = {
    get audioContext() {
      return audioContext;
    },
    get resumeContext() {
      return resumeContext;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return listener;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(AudioListener, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: listener })), "render", AudioListener, 35, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      AudioListener,
      30,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  AudioListener = hmr(AudioListener);
  import.meta.hot.accept((module) => {
    AudioListener[HMR].update(module.default);
  });
}
var AudioListener_default = AudioListener;

// node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte
import { Audio as ThreeAudio } from "three";

// node_modules/@threlte/extras/dist/audio/utils/useAudio.js
import { AudioLoader } from "three";
var useAudio = (audio, props = {}) => {
  const loaded = currentWritable(false);
  const autoplay = currentWritable(false);
  const shouldPlay = currentWritable(false);
  let audioDestroyed = false;
  const loader = useLoader(AudioLoader);
  const setSrc = async (source) => {
    loaded.set(false);
    try {
      if (typeof source === "string") {
        const audioBuffer = await loader.load(source, {
          onProgress(event) {
            props.onprogress?.(event);
          }
        });
        audio.setBuffer(audioBuffer);
      } else if (source instanceof AudioBuffer) {
        audio.setBuffer(source);
      } else if (source instanceof HTMLMediaElement) {
        audio.setMediaElementSource(source);
      } else if (source instanceof AudioBufferSourceNode) {
        audio.setNodeSource(source);
      } else if (source instanceof MediaStream) {
        audio.setMediaStreamSource(source);
      }
      loaded.set(true);
      props.onload?.(audio.buffer);
    } catch (error) {
      props.onerror?.(error);
    }
  };
  const setVolume = (volume) => {
    audio.setVolume(volume ?? 1);
  };
  const setPlaybackRate = (playbackRate) => {
    audio.setPlaybackRate(playbackRate ?? 1);
  };
  const play = async (delay) => {
    if (!loaded.current) {
      shouldPlay.set(true);
      return;
    }
    if (audio.context.state !== "running") {
      await audio.context.resume();
      if (audioDestroyed) {
        return;
      }
    }
    return audio.play(delay);
  };
  const pause = () => {
    return audio.pause();
  };
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setAutoPlay = (value) => {
    autoplay.set(value ?? false);
  };
  const setDetune = (value) => {
    if (audio.source && audio.detune) {
      audio.setDetune(value ?? 0);
    }
  };
  const setLoop = (value) => {
    audio.setLoop(value ?? false);
  };
  watch([loaded, autoplay, shouldPlay], ([loaded2, autoplay2, shouldPlay2]) => {
    if (!loaded2) {
      if (audio.isPlaying)
        stop();
      return;
    }
    if (autoplay2 || shouldPlay2) {
      play();
    }
  });
  onDestroy(() => {
    try {
      audioDestroyed = true;
      stop();
    } catch (error) {
      console.warn("Error while destroying audio", error);
    }
  });
  return {
    setVolume,
    setSrc,
    setPlaybackRate,
    setAutoPlay,
    setDetune,
    setLoop,
    play,
    pause,
    stop
  };
};

// node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte
Audio[FILENAME] = "node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte";
function Audio($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Audio);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "id",
      "volume",
      "playbackRate",
      "autoplay",
      "detune",
      "loop",
      "ref",
      "children"
    ],
    "props"
  );
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener($$props.id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${$$props.id} found.`);
  }
  const audio = new ThreeAudio(listener);
  const {
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc,
    setVolume,
    ...useAudioProps
  } = useAudio(audio, props);
  const pause = useAudioProps.pause;
  const play = useAudioProps.play;
  const stop = useAudioProps.stop;
  user_effect(() => setAutoPlay($$props.autoplay));
  user_effect(() => void setSrc($$props.src));
  user_effect(() => setVolume($$props.volume));
  user_effect(() => setPlaybackRate($$props.playbackRate));
  user_effect(() => setLoop($$props.loop));
  user_effect(() => setDetune($$props.detune));
  var $$exports = {
    get pause() {
      return pause;
    },
    get play() {
      return play;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return audio;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Audio, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: audio })), "render", Audio, 51, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Audio,
      46,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  Audio = hmr(Audio);
  import.meta.hot.accept((module) => {
    Audio[HMR].update(module.default);
  });
}
var Audio_default = Audio;

// node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte
import { PositionalAudio as ThreePositionalAudio } from "three";
PositionalAudio[FILENAME] = "node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte";
function PositionalAudio($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PositionalAudio);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "id",
      "volume",
      "playbackRate",
      "autoplay",
      "detune",
      "loop",
      "directionalCone",
      "refDistance",
      "rolloffFactor",
      "distanceModel",
      "maxDistance",
      "ref",
      "children"
    ],
    "props"
  );
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener($$props.id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${$$props.id} found.`);
  }
  const audio = new ThreePositionalAudio(listener);
  user_effect(() => {
    if (strict_equals($$props.refDistance, void 0, false)) audio.setRefDistance($$props.refDistance);
    if (strict_equals($$props.rolloffFactor, void 0, false)) audio.setRolloffFactor($$props.rolloffFactor);
    if (strict_equals($$props.distanceModel, void 0, false)) audio.setDistanceModel($$props.distanceModel);
    if (strict_equals($$props.maxDistance, void 0, false)) audio.setMaxDistance($$props.maxDistance);
    if (strict_equals($$props.directionalCone, void 0, false)) {
      audio.setDirectionalCone($$props.directionalCone.coneInnerAngle, $$props.directionalCone.coneOuterAngle, $$props.directionalCone.coneOuterGain);
    }
  });
  const {
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc: setSource,
    setVolume,
    ...useAudioProps
  } = useAudio(audio, props);
  const pause = useAudioProps.pause;
  const play = useAudioProps.play;
  const stop = useAudioProps.stop;
  user_effect(() => setAutoPlay($$props.autoplay));
  user_effect(() => void setSource($$props.src));
  user_effect(() => setVolume($$props.volume));
  user_effect(() => setPlaybackRate($$props.playbackRate));
  user_effect(() => setLoop($$props.loop));
  user_effect(() => setDetune($$props.detune));
  var $$exports = {
    get pause() {
      return pause;
    },
    get play() {
      return play;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return audio;
          }
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(PositionalAudio, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ ref: audio })), "render", PositionalAudio, 77, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      PositionalAudio,
      72,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  PositionalAudio = hmr(PositionalAudio);
  import.meta.hot.accept((module) => {
    PositionalAudio[HMR].update(module.default);
  });
}
var PositionalAudio_default = PositionalAudio;

// node_modules/@threlte/extras/dist/audio/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const { getAudioListener } = useThrelteAudio();
  if (typeof callbackOrId === "function") {
    const listener2 = getAudioListener(id);
    if (!listener2)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener: listener2,
      context: listener2.context
    });
  }
  const listener = getAudioListener(callbackOrId);
  if (!listener)
    throw new Error("No AudioListener found.");
  return {
    listener,
    context: listener.context
  };
}

// node_modules/@threlte/extras/dist/interactivity/context.js
import { Vector2 as Vector213, Raycaster as Raycaster5 } from "three";

// node_modules/@threlte/extras/dist/interactivity/defaults.js
var getDefaultComputeFunction = (target) => {
  const { camera } = useThrelte();
  let width2 = target.current.clientWidth;
  let height2 = target.current.clientHeight;
  const resizeObserver = new ResizeObserver(([entry]) => {
    width2 = entry.contentRect.width;
    height2 = entry.contentRect.height;
  });
  watch(target, (target2) => {
    if (target2)
      resizeObserver.observe(target2);
    return () => {
      if (target2)
        resizeObserver.unobserve(target2);
    };
  });
  return (event, state2) => {
    state2.pointer.update((pointer) => {
      pointer.set(event.offsetX / width2 * 2 - 1, -(event.offsetY / height2) * 2 + 1);
      return pointer;
    });
    state2.raycaster.setFromCamera(state2.pointer.current, camera.current);
  };
};

// node_modules/@threlte/extras/dist/interactivity/context.js
var contextKey = /* @__PURE__ */ Symbol("interactivity-context");
var getInteractivityContext = () => {
  return getContext(contextKey);
};
var setInteractivityContext = (options) => {
  const target = currentWritable(options?.target ?? useDOM().dom);
  const context = {
    enabled: currentWritable(options?.enabled ?? true),
    pointer: currentWritable(new Vector213()),
    pointerOverTarget: currentWritable(false),
    lastEvent: void 0,
    raycaster: new Raycaster5(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target,
    handlers: /* @__PURE__ */ new WeakMap(),
    compute: options?.compute ?? getDefaultComputeFunction(target),
    filter: options?.filter,
    addInteractiveObject: (object, events) => {
      if (context.interactiveObjects.indexOf(object) > -1) {
        return;
      }
      context.handlers.set(object, events);
      context.interactiveObjects.push(object);
    },
    removeInteractiveObject: (object) => {
      const index = context.interactiveObjects.indexOf(object);
      context.interactiveObjects.splice(index, 1);
      context.handlers.delete(object);
    }
  };
  setContext(contextKey, context);
  return context;
};
var useInteractivity = () => {
  const context = getInteractivityContext();
  if (!context) {
    throw new Error("No interactivity context found. Did you forget to implement interactivity()?");
  }
  return context;
};

// node_modules/@threlte/extras/dist/interactivity/plugin.svelte.js
var interactivityEventNames = [
  "onclick",
  "oncontextmenu",
  "ondblclick",
  "onwheel",
  "onpointerup",
  "onpointerdown",
  "onpointerover",
  "onpointerout",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointermissed"
];
var injectInteractivityPlugin = () => {
  injectPlugin("interactivity", (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    const hasEventHandlers = Object.entries(args.props).some(([key2, value]) => {
      return strict_equals(value, void 0, false) && interactivityEventNames.includes(key2);
    });
    if (!hasEventHandlers) return;
    const { addInteractiveObject, removeInteractiveObject } = useInteractivity();
    observe.pre(() => [args.ref], ([ref]) => {
      addInteractiveObject(ref, args.props);
      return () => {
        removeInteractiveObject(ref);
      };
    });
    return { pluginProps: interactivityEventNames };
  });
};

// node_modules/@threlte/extras/dist/interactivity/setupInteractivity.js
function createIntersectionId(intersection) {
  return `${(intersection.eventObject || intersection.object).uuid}|${intersection.index}|${intersection.instanceId}`;
}
var DOM_EVENTS = [
  ["click", false],
  ["contextmenu", false],
  ["dblclick", false],
  ["wheel", false],
  ["pointerdown", true],
  ["pointerup", true],
  ["pointerleave", true],
  ["pointerenter", true],
  ["pointermove", true],
  ["pointercancel", true]
];
var setupInteractivity = (context) => {
  const { handlers } = useInteractivity();
  const calculateDistance = (event) => {
    const dx = event.offsetX - context.initialClick[0];
    const dy = event.offsetY - context.initialClick[1];
    return Math.round(Math.hypot(dx, dy));
  };
  const cancelPointer = (intersections) => {
    if (context.hovered.size === 0) {
      return;
    }
    const hitIds = /* @__PURE__ */ new Set();
    for (const intersection of intersections) {
      hitIds.add(createIntersectionId(intersection));
    }
    for (const [id, hoveredObj] of context.hovered) {
      if (!hitIds.has(id)) {
        const { eventObject } = hoveredObj;
        context.hovered.delete(id);
        const events = handlers.get(eventObject);
        if (events) {
          const data = { ...hoveredObj, intersections };
          events.onpointerout?.(data);
          events.onpointerleave?.(data);
        }
      }
    }
  };
  const getHits = () => {
    if (!context.enabled.current)
      return [];
    const intersections = [];
    const hits = context.raycaster.intersectObjects(context.interactiveObjects, true);
    const filtered = context.filter === void 0 ? hits : context.filter(hits, context);
    for (const hit of filtered) {
      let eventObject = hit.object;
      while (eventObject) {
        if (handlers.has(eventObject))
          intersections.push({ ...hit, eventObject });
        eventObject = eventObject.parent;
      }
    }
    return intersections;
  };
  const pointerMissed = (event, objects) => {
    for (const object of objects) {
      handlers.get(object)?.onpointermissed?.(event);
    }
  };
  const handlePointerLeaveOrCancel = () => {
    context.pointerOverTarget.set(false);
    cancelPointer([]);
  };
  const handlePointerEnter = () => {
    context.pointerOverTarget.set(true);
  };
  const handleEvent = (event) => {
    const name = event.type;
    const isPointerMove = name === "pointermove";
    const isClickEvent = name === "click" || name === "contextmenu" || name === "dblclick";
    context.compute(event, context);
    const hits = getHits();
    const delta = isClickEvent ? calculateDistance(event) : 0;
    if (name === "pointerdown") {
      context.initialClick = [event.offsetX, event.offsetY];
      context.initialHits = hits.map((hit) => hit.eventObject);
    }
    if (isClickEvent && hits.length === 0) {
      if (delta <= 2) {
        pointerMissed(event, context.interactiveObjects);
      }
    }
    if (isPointerMove)
      cancelPointer(hits);
    let stopped = false;
    dispatchEvents: for (const hit of hits) {
      const events = handlers.get(hit.eventObject);
      if (!events)
        continue;
      const intersectionEvent = {
        stopped,
        ...hit,
        intersections: hits,
        stopPropagation() {
          stopped = true;
          intersectionEvent.stopped = true;
          if (context.hovered.size > 0 && Array.from(context.hovered.values()).some((i) => i.eventObject === hit.eventObject)) {
            const higher = hits.slice(0, hits.indexOf(hit));
            cancelPointer([...higher, hit]);
          }
        },
        camera: context.raycaster.camera,
        delta,
        nativeEvent: event,
        pointer: context.pointer.current,
        ray: context.raycaster.ray
      };
      if (isPointerMove) {
        if (events.onpointerover || events.onpointerenter || events.onpointerout || events.onpointerleave) {
          const id = createIntersectionId(intersectionEvent);
          const hoveredItem = context.hovered.get(id);
          if (!hoveredItem) {
            context.hovered.set(id, intersectionEvent);
            events.onpointerover?.(intersectionEvent);
            events.onpointerenter?.(intersectionEvent);
          } else if (hoveredItem.stopped) {
            intersectionEvent.stopPropagation();
          }
        }
        events.onpointermove?.(intersectionEvent);
      } else {
        if (events[`on${name}`]) {
          if (!isClickEvent || context.initialHits.includes(hit.eventObject)) {
            pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
            events[`on${name}`]?.(intersectionEvent);
          }
        } else {
          if (isClickEvent && context.initialHits.includes(hit.eventObject)) {
            pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
          }
        }
      }
      if (stopped)
        break dispatchEvents;
    }
  };
  let moveRAF = 0;
  let queuedMoveEvent = null;
  let lastMoveX = -Infinity;
  let lastMoveY = -Infinity;
  const MIN_MOVE_DELTA = 0.25;
  const handlePointerMove = (event) => {
    if (Math.abs(event.offsetX - lastMoveX) < MIN_MOVE_DELTA && Math.abs(event.offsetY - lastMoveY) < MIN_MOVE_DELTA) {
      return;
    }
    lastMoveX = event.offsetX;
    lastMoveY = event.offsetY;
    queuedMoveEvent = event;
    if (!moveRAF) {
      moveRAF = requestAnimationFrame(() => {
        moveRAF = 0;
        if (queuedMoveEvent) {
          handleEvent(queuedMoveEvent);
          queuedMoveEvent = null;
        }
      });
    }
  };
  const disconnect = (target) => {
    for (const [eventName] of DOM_EVENTS) {
      if (eventName === "pointerleave" || eventName === "pointercancel") {
        target.removeEventListener(eventName, handlePointerLeaveOrCancel);
      } else if (eventName === "pointermove") {
        target.removeEventListener(eventName, handlePointerMove);
      } else if (eventName === "pointerenter") {
        target.removeEventListener(eventName, handlePointerEnter);
      } else {
        target.removeEventListener(eventName, handleEvent);
      }
    }
  };
  const connect = (target) => {
    for (const [eventName, passive] of DOM_EVENTS) {
      if (eventName === "pointerleave" || eventName === "pointercancel") {
        target.addEventListener(eventName, handlePointerLeaveOrCancel, { passive });
      } else if (eventName === "pointermove") {
        target.addEventListener(eventName, handlePointerMove, { passive });
      } else if (eventName === "pointerenter") {
        target.addEventListener(eventName, handlePointerEnter, { passive });
      } else {
        target.addEventListener(eventName, handleEvent, { passive });
      }
    }
  };
  watch(context.target, (target) => {
    if (target)
      connect(target);
    return () => {
      if (target)
        disconnect(target);
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/index.js
var interactivity = (options) => {
  const context = setInteractivityContext(options);
  injectInteractivityPlugin();
  setupInteractivity(context);
  return context;
};

// node_modules/@threlte/extras/dist/layers/plugin.svelte.js
var injectLayersPlugin = () => {
  injectPlugin("layers", (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    const ctx = getContext("threlte-layers-context");
    const mergedLayers = tag(user_derived(() => args.props.layers ?? ctx?.layers), "mergedLayers");
    const mergedCtx = tag(user_derived(() => get(mergedLayers) ? { layers: get(mergedLayers) } : void 0), "mergedCtx");
    setContext("threlte-layers-context", get(mergedCtx));
    const applyLayers = (ref, layers2) => {
      if (strict_equals(layers2, "all")) {
        ref.layers.enableAll();
      } else if (strict_equals(layers2, "none")) {
        ref.layers.disableAll();
      } else if (Array.isArray(layers2)) {
        for (let index = 0; index < 32; index += 1) {
          const layerIndex = index;
          const enabled = layers2.includes(layerIndex);
          if (enabled) {
            ref.layers.enable(index);
          } else {
            ref.layers.disable(index);
          }
        }
      } else if (strict_equals(layers2, void 0, false)) {
        ref.layers.set(layers2);
      }
    };
    observe.pre(() => [args.ref, get(mergedLayers)], ([ref, layers2]) => {
      if (!isInstanceOf(ref, "Object3D")) return;
      applyLayers(ref, layers2);
    });
    return { pluginProps: ["layers"] };
  });
};

// node_modules/@threlte/extras/dist/layers/index.js
var layers = (options) => {
  setContext("threlte-layers-context", {
    layers: options?.defaultLayers ?? 0
  });
  injectLayersPlugin();
};

// node_modules/@threlte/extras/node_modules/@threejs-kit/instanced-sprite-mesh/dist/index.js
import { ShaderLib as _e2, UniformsUtils as Me2, MeshDepthMaterial as Te2, RGBADepthPacking as De2, MeshDistanceMaterial as Ae2, ShaderChunk as be2, InstancedMesh as Ue2, MeshBasicMaterial as Fe2, InstancedBufferAttribute as Se2, DataTexture as Q2, RGBAFormat as L, FloatType as C, NearestFilter as b, ClampToEdgeWrapping as k2, RepeatWrapping as q2, Vector2 as $2, Vector4 as he2, BufferGeometry as ee2, BufferAttribute as R, OrthographicCamera as Pe2, Mesh as Re2, Float32BufferAttribute as ie, ShaderMaterial as Ve, WebGLRenderTarget as Ce2, PlaneGeometry as Ie2, REVISION as ne, ImageLoader as Oe2, Texture as Ee2, CanvasTexture as re2, SRGBColorSpace as se } from "three";
var ye2 = Object.defineProperty;
var we2 = (t, i, e) => i in t ? ye2(t, i, { enumerable: true, configurable: true, writable: true, value: e }) : t[i] = e;
var y = (t, i, e) => (we2(t, typeof i != "symbol" ? i + "" : i, e), e);
var pe2 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function j2(t) {
  const i = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function e(n, r) {
    let s = be2[r];
    return s ? j2(s) : n;
  }
  return t.replace(i, e);
}
var T3 = [];
for (let t = 0; t < 256; t++)
  T3[t] = (t < 16 ? "0" : "") + t.toString(16);
function $e() {
  const t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (T3[t & 255] + T3[t >> 8 & 255] + T3[t >> 16 & 255] + T3[t >> 24 & 255] + "-" + T3[i & 255] + T3[i >> 8 & 255] + "-" + T3[i >> 16 & 15 | 64] + T3[i >> 24 & 255] + "-" + T3[e & 63 | 128] + T3[e >> 8 & 255] + "-" + T3[e >> 16 & 255] + T3[e >> 24 & 255] + T3[n & 255] + T3[n >> 8 & 255] + T3[n >> 16 & 255] + T3[n >> 24 & 255]).toUpperCase();
}
var U2 = Object.assign || function() {
  let t = arguments[0];
  for (let i = 1, e = arguments.length; i < e; i++) {
    let n = arguments[i];
    if (n)
      for (let r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
};
var ze2 = Date.now();
var ae2 = /* @__PURE__ */ new WeakMap();
var oe2 = /* @__PURE__ */ new Map();
var He2 = 1e10;
function N2(t, i) {
  const e = Ge2(i);
  let n = ae2.get(t);
  if (n || ae2.set(t, n = /* @__PURE__ */ Object.create(null)), n[e])
    return new n[e]();
  const r = `_onBeforeCompile${e}`, s = function(o, h) {
    t.onBeforeCompile.call(this, o, h);
    const g = this.customProgramCacheKey() + "|" + o.vertexShader + "|" + o.fragmentShader;
    let c = oe2[g];
    if (!c) {
      const f = Le2(this, o, i, e);
      c = oe2[g] = f;
    }
    o.vertexShader = c.vertexShader, o.fragmentShader = c.fragmentShader, U2(o.uniforms, this.uniforms), i.timeUniform && (o.uniforms[i.timeUniform] = {
      get value() {
        return Date.now() - ze2;
      }
    }), this[r] && this[r](o);
  }, a = function() {
    return l(i.chained ? t : t.clone());
  }, l = function(o) {
    const h = Object.create(o, u);
    return Object.defineProperty(h, "baseMaterial", { value: t }), Object.defineProperty(h, "id", { value: He2++ }), h.uuid = $e(), h.uniforms = U2({}, o.uniforms, i.uniforms), h.defines = U2({}, o.defines, i.defines), h.defines[`TROIKA_DERIVED_MATERIAL_${e}`] = "", h.extensions = U2({}, o.extensions, i.extensions), h._listeners = void 0, h;
  }, u = {
    constructor: { value: a },
    isDerivedMaterial: { value: true },
    type: {
      get: () => t.type,
      set: (o) => {
        t.type = o;
      }
    },
    isDerivedFrom: {
      writable: true,
      configurable: true,
      value: function(o) {
        const h = this.baseMaterial;
        return o === h || h.isDerivedMaterial && h.isDerivedFrom(o) || false;
      }
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return t.customProgramCacheKey() + "|" + e;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(o) {
        this[r] = o;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(o) {
        return t.copy.call(this, o), !t.isShaderMaterial && !t.isDerivedMaterial && (U2(this.extensions, o.extensions), U2(this.defines, o.defines), U2(this.uniforms, Me2.clone(o.uniforms))), this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const o = new t.constructor();
        return l(o).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let o = this._depthMaterial;
        return o || (o = this._depthMaterial = N2(
          t.isDerivedMaterial ? t.getDepthMaterial() : new Te2({ depthPacking: De2 }),
          i
        ), o.defines.IS_DEPTH_MATERIAL = "", o.uniforms = this.uniforms), o;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let o = this._distanceMaterial;
        return o || (o = this._distanceMaterial = N2(
          t.isDerivedMaterial ? t.getDistanceMaterial() : new Ae2(),
          i
        ), o.defines.IS_DISTANCE_MATERIAL = "", o.uniforms = this.uniforms), o;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial: o, _distanceMaterial: h } = this;
        o && o.dispose(), h && h.dispose(), t.dispose.call(this);
      }
    }
  };
  return n[e] = a, new a();
}
function Le2(t, { vertexShader: i, fragmentShader: e }, n, r) {
  let {
    vertexDefs: s,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: u,
    fragmentDefs: o,
    fragmentMainIntro: h,
    fragmentMainOutro: g,
    fragmentColorTransform: c,
    customRewriter: f,
    timeUniform: m2
  } = n;
  if (s = s || "", a = a || "", l = l || "", o = o || "", h = h || "", g = g || "", (u || f) && (i = j2(i)), (c || f) && (e = e.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), e = j2(e)), f) {
    let p = f({ vertexShader: i, fragmentShader: e });
    i = p.vertexShader, e = p.fragmentShader;
  }
  if (c) {
    let p = [];
    e = e.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (d) => (p.push(d), "")
    ), g = `${c}
${p.join(`
`)}
${g}`;
  }
  if (m2) {
    const p = `
uniform float ${m2};
`;
    s = p + s, o = p + o;
  }
  return u && (i = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${i}
`, s = `${s}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, i = i.replace(/\b(position|normal|uv)\b/g, (p, d, w, _) => /\battribute\s+vec[23]\s+$/.test(_.substr(0, w)) ? d : `troika_${d}_${r}`), t.map && t.map.channel > 0 || (i = i.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))), i = le2(i, r, s, a, l), e = le2(e, r, o, h, g), {
    vertexShader: i,
    fragmentShader: e
  };
}
function le2(t, i, e, n, r) {
  return (n || r || e) && (t = t.replace(
    pe2,
    `
${e}
void troikaOrigMain${i}() {`
  ), t += `
void main() {
  ${n}
  troikaOrigMain${i}();
  ${r}
}`), t;
}
function ke2(t, i) {
  return t === "uniforms" ? void 0 : typeof i == "function" ? i.toString() : i;
}
var Ne = 0;
var ue2 = /* @__PURE__ */ new Map();
function Ge2(t) {
  const i = JSON.stringify(t, ke2);
  let e = ue2.get(i);
  return e == null && ue2.set(i, e = ++Ne), e;
}
var Ze = {
  MeshDepthMaterial: "depth",
  MeshDistanceMaterial: "distanceRGBA",
  MeshNormalMaterial: "normal",
  MeshBasicMaterial: "basic",
  MeshLambertMaterial: "lambert",
  MeshPhongMaterial: "phong",
  MeshToonMaterial: "toon",
  MeshStandardMaterial: "physical",
  MeshPhysicalMaterial: "physical",
  MeshMatcapMaterial: "matcap",
  LineBasicMaterial: "basic",
  LineDashedMaterial: "dashed",
  PointsMaterial: "points",
  ShadowMaterial: "shadow",
  SpriteMaterial: "sprite"
};
function Be2(t) {
  let i = Ze[t.type];
  return i ? _e2[i] : t;
}
function ce2(t) {
  let i = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g, e = /* @__PURE__ */ Object.create(null), n;
  for (; (n = i.exec(t)) !== null; )
    e[n[2]] = n[1];
  return e;
}
function Ke(t) {
  let i = [], e = "";
  const n = N2(t, {
    chained: true,
    customRewriter({ vertexShader: s, fragmentShader: a }) {
      let l = [], u = [], o = [], h = ce2(s), g = ce2(a);
      return i.forEach((c) => {
        let f = h[c], m2 = g[c];
        const p = f || m2;
        if (p) {
          const d = new RegExp(`\\buniform\\s+${p}\\s+${c}\\s*;`, "g"), w = new RegExp(`\\b${c}\\b`, "g"), _ = `troika_attr_${c}`, x = `troika_vary_${c}`;
          if (l.push(`attribute ${p} ${_};`), f && (s = s.replace(d, ""), s = s.replace(w, _)), m2) {
            a = a.replace(d, ""), a = a.replace(w, x);
            let v4 = `varying ${m2} ${x};`;
            l.push(v4), o.push(v4), u.push(`${x} = ${_};`);
          }
        }
      }), s = `${l.join(`
`)}
${s.replace(pe2, `
$&
${u.join(`
`)}`)}`, o.length && (a = `${o.join(`
`)}
${a}`), { vertexShader: s, fragmentShader: a };
    }
  });
  n.setUniformNames = function(s) {
    i = s || [];
    const a = i.sort().join("|");
    a !== e && (e = a, this.needsUpdate = true);
  };
  const r = n.customProgramCacheKey();
  return n.customProgramCacheKey = function() {
    return r + "|" + e;
  }, n.isInstancedUniformsMaterial = true, n;
}
var je2 = class extends Ue2 {
  constructor(i, e, n) {
    super(i, e, n), this._maxCount = n, this._instancedUniformNames = [];
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied geometry with one that will
   * carry our extra InstancedBufferAttribute(s). We do the wrapping lazily on _read_ rather
   * than write to avoid unnecessary wrapping on transient values.
   */
  get geometry() {
    let i = this._derivedGeometry;
    const e = this._baseGeometry;
    return (!i || i.baseGeometry !== e) && (i = this._derivedGeometry = Object.create(e), i.baseGeometry = e, i.attributes = Object.create(e.attributes), e.addEventListener("dispose", function n() {
      e.removeEventListener("dispose", n), i.dispose();
    })), i;
  }
  set geometry(i) {
    this._baseGeometry = i;
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied material with our upgrades. We do the
   * wrapping lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
   */
  get material() {
    let i = this._derivedMaterial;
    const e = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = new Fe2());
    return (!i || i.baseMaterial !== e) && (i = this._derivedMaterial = Ke(e), e.addEventListener("dispose", function n() {
      e.removeEventListener("dispose", n), i.dispose();
    })), i.setUniformNames(this._instancedUniformNames), i;
  }
  set material(i) {
    if (Array.isArray(i))
      throw new Error("InstancedUniformsMesh does not support multiple materials");
    for (; i && i.isInstancedUniformsMaterial; )
      i = i.baseMaterial;
    this._baseMaterial = i;
  }
  get customDepthMaterial() {
    return this.material.getDepthMaterial();
  }
  set customDepthMaterial(i) {
  }
  get customDistanceMaterial() {
    return this.material.getDistanceMaterial();
  }
  set customDistanceMaterial(i) {
  }
  /**
   * Set the value of a shader uniform for a single instance.
   * @param {string} name - the name of the shader uniform
   * @param {number} index - the index of the instance to set the value for
   * @param {number|Vector2|Vector3|Vector4|Color|Array|Matrix3|Matrix4|Quaternion} value - the uniform value for this instance
   */
  setUniformAt(i, e, n) {
    const r = this.geometry.attributes, s = `troika_attr_${i}`;
    let a = r[s];
    if (!a) {
      const l = We2(this._baseMaterial, i), u = Ye(l);
      if (a = r[s] = new Se2(new Float32Array(u * this._maxCount), u), l !== null)
        for (let o = 0; o < this._maxCount; o++)
          fe2(a, o, l);
      this._instancedUniformNames = [...this._instancedUniformNames, i];
    }
    fe2(a, e, n), a.needsUpdate = true;
  }
  /**
   * Unset all instance-specific values for a given uniform, reverting back to the original
   * uniform value for all.
   * @param {string} name
   */
  unsetUniform(i) {
    this.geometry.deleteAttribute(`troika_attr_${i}`), this._instancedUniformNames = this._instancedUniformNames.filter((e) => e !== i);
  }
};
function fe2(t, i, e) {
  let n = t.itemSize;
  n === 1 ? t.setX(i, e) : n === 2 ? t.setXY(i, e.x, e.y) : n === 3 ? e.isColor ? t.setXYZ(i, e.r, e.g, e.b) : t.setXYZ(i, e.x, e.y, e.z) : n === 4 ? t.setXYZW(i, e.x, e.y, e.z, e.w) : e.toArray ? e.toArray(t.array, i * n) : t.set(e, i * n);
}
function We2(t, i) {
  let e = t.uniforms;
  return e && e[i] || (e = Be2(t).uniforms, e && e[i]) ? e[i].value : null;
}
function Ye(t) {
  return t == null ? 0 : typeof t == "number" ? 1 : t.isVector2 ? 2 : t.isVector3 || t.isColor ? 3 : t.isVector4 || t.isQuaternion ? 4 : t.elements ? t.elements.length : Array.isArray(t) ? t.length : 0;
}
var Xe2 = (t, i) => {
  const e = t.split(`
`), n = /vMapUv|vAlphaMapUv|vNormalMapUv/g;
  return e.map((s) => !s.includes("varying") && !s.includes("uniform") ? s.replace(n, i) : s).join(`
`);
};
var Je = (t, i) => {
  const e = {
    USE_UV: ""
  };
  return i && (e.TRI_GEOMETRY = ""), N2(t, {
    defines: e,
    uniforms: {
      /** GPGPU animation driven data */
      animationData: { value: null },
      animationDataSize: { value: 0 },
      /* Repeat animation in a loop */
      billboarding: { value: 0 },
      /** flip uvs on x */
      flipX: { value: 0 },
      /** flip uvs on y */
      flipY: { value: 0 },
      /**
       * DataArrayTexture - data stored in columns. Rows are:
       * 0 - Frames declaration - RGBA[x,y,w,h]
       * 1 - Animation lengths RGBA[length,0,0,0]
       * 2 - Animation0 - RGBA [id,duration, 0,0]
       * 3 - Animation1 - RGBA [id,duration, 0,0]
       * ....etc
       */
      spritesheetData: { value: null },
      /**util for reading data texture in spritesheetData */
      dataSize: { value: new $2(0, 0) },
      /**
       * Tinting - Vector4 (enabled 0/1, H (0-3), S (0-1), V(0-1))
       */
      tint: { value: new he2(0, 0, 0, 0) }
    },
    /**
     *
     * VERTEX
     * - billboarding
     *
     * */
    vertexDefs: (
      /*glsl*/
      `
    uniform float billboarding;
    flat varying int vId;
    `
    ),
    vertexMainOutro: (
      /*glsl*/
      `
    vId = gl_InstanceID;
    if(billboarding == 1.){
      vec3 instancePosition = vec3(instanceMatrix[3]);
      vec3 instanceScale = vec3(length(instanceMatrix[0]), length(instanceMatrix[1]), length(instanceMatrix[2]));

      vec3 cameraRight_worldspace = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
      vec3 cameraUp_worldspace = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

      vec3 vertexPosition_worldspace = instancePosition
        + cameraRight_worldspace * position.x * instanceScale.x
        + cameraUp_worldspace * position.y * instanceScale.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition_worldspace, 1.0);
    }
    `
    ),
    /**
     *
     * FRAGMENT REWRITER
     *
     * */
    customRewriter: ({ vertexShader: r, fragmentShader: s }) => {
      const a = (
        /*glsl*/
        `
			uniform sampler2D animationData;
      uniform int animationDataSize;
			uniform sampler2D spritesheetData;
      uniform float startTime;
			uniform float time;
			uniform float flipX;
			uniform float flipY;
			uniform vec2 dataSize;
      uniform vec4 tint;

      flat varying int vId;
			`
      ), l = (
        /*glsl*/
        `
			vec4 readData(float col, float row) {
				float wStep = 1.f / dataSize.x;
				float wHalfStep = wStep * 0.5f;
				float hStep = 1.f / dataSize.y;
				float hHalfStep = 1.f / dataSize.y * 0.5f;
				return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
			}

      vec2 zoomUV(vec2 uv, vec2 zoomCenter, float zoomFactor) {
        // Shift UVs so that the zoom center is the origin
        vec2 shiftedUV = uv - zoomCenter;

        // Scale (zoom) the UV coordinates
        shiftedUV *= zoomFactor;

        // Shift back
        shiftedUV += zoomCenter;

        return shiftedUV;
    }
			`
      ), u = (
        /*glsl*/
        `
      float y = float(vId / animationDataSize) / float(animationDataSize);
      float x = mod(float(vId),float(animationDataSize)) / float(animationDataSize);

      float spritesheetFrameId = texture2D(animationData, vec2(x,y)).r;

			// x,y,w,h
			vec4 frameMeta = readData(spritesheetFrameId, 0.f);

			vec2 fSize = frameMeta.zw;
			vec2 fOffset = vec2(frameMeta.xy);

      vec2 transformedPlaneUv = vUv + vec2(0.,0.);

      // todo  == 1. caused a flickering bug. look into Precision/interpolation?
      if(flipX > 0.){
        transformedPlaneUv.x = 1. - transformedPlaneUv.x;
      }
      if(flipY > 0.){
        transformedPlaneUv.y = 1. - transformedPlaneUv.y;
      }

			vec2 spriteUv = fSize * transformedPlaneUv + fOffset ;

      #ifdef TRI_GEOMETRY
        // Shift UVs if mesh uses triangle geometry
        // TODO optimize ugly math
        if(vUv.y>0.5 || vUv.x<0.25 || vUv.x>0.75){
          discard;
        }

        vec2 zoomCenter = vec2(fSize.x * 0.5,0.) + fOffset;
        float zoomFactor = 2.;
        vec2 shiftedUV = spriteUv - zoomCenter;
        shiftedUV *= zoomFactor;
        shiftedUV += zoomCenter;
        spriteUv = shiftedUV;
      #endif



			`
      );
      return s = s.replace(
        "void main() {",
        `void main() {${u}`
      ), s = `
			${a}
			${l}
			${s}
			`, s = s.replace(
        "vec4 sampledDiffuseColor = texture2D( map, vMapUv );",
        /*glsl*/
        `
        vec4 sampledDiffuseColor = texture2D( map, vMapUv );
        if(tint.w == 1.){
          vec3 hue_term = 1.0 - min(abs(vec3(tint.x) - vec3(0,2.0,1.0)), 1.0);
          hue_term.x = 1.0 - dot(hue_term.yz, vec2(1));
          vec3 res = vec3(dot(sampledDiffuseColor.xyz, hue_term.xyz), dot(sampledDiffuseColor.xyz, hue_term.zxy), dot(sampledDiffuseColor.xyz, hue_term.yzx));
          res = mix(vec3(dot(res, vec3(0.2, 0.5, 0.3))), res, tint.y);
          res = res * tint.z;

          sampledDiffuseColor = vec4(res, sampledDiffuseColor.a);
        }

        // sampledDiffuseColor = vec4(texture2D(animationData, vUv).rgb, 1.);
      `
      ), s = Xe2(s, "spriteUv"), { vertexShader: r, fragmentShader: s };
    }
  });
};
var Yt2 = (t) => {
  const i = [], e = [], n = {}, r = [], s = t.meta.size.w, a = t.meta.size.h, l = [
    t.meta.size.w,
    t.meta.size.h
  ];
  for (const u in t.frames) {
    const o = t.frames[u];
    i.push([o.frame.x / s, o.frame.y / a, o.frame.w / s, o.frame.h / a]), e.push(o.duration);
  }
  for (const u of t.meta.frameTags) {
    n[u.name] = [];
    for (let o = u.from; o <= u.to; o++)
      n[u.name].push([o, e[o]]);
    r.push(n[u.name].length);
  }
  return { frames: i, animations: n, sheetSize: l, animationLengths: r };
};
var Qe = (t) => {
  const { frames: i, animationLengths: e, animations: n } = t, r = Math.max(
    i.length,
    e.length,
    ...Object.values(n).map((f) => f.length)
  ), s = 2 + Object.values(n).length, a = i.flat().concat(new Array((r - i.length) * 4).fill(0)), l = e.map((f) => [f, 0, 0, 0]).flat().concat(new Array((r - e.length) * 4).fill(0)), u = [], o = /* @__PURE__ */ new Map();
  for (let f = 0; f < Object.keys(n).length; f++) {
    const m2 = Object.keys(n)[f];
    o.set(m2, f);
    const p = n[m2].map((d) => [...d, 0, 0]).flat().concat(new Array((r - n[m2].length) * 4).fill(0));
    u.push(...p);
  }
  const h = [
    ...a,
    ...l,
    ...u
  ], g = new Float32Array(h);
  g.set(h);
  const c = new Q2(
    g,
    r,
    s,
    L,
    C
  );
  return c.type = C, c.minFilter = b, c.magFilter = b, c.wrapS = k2, c.wrapT = q2, c.needsUpdate = true, { dataTexture: c, dataWidth: r, dataHeight: s, animMap: o };
};
var qe2 = () => {
  const t = new ee2(), i = new Float32Array([
    // top
    0,
    1,
    0,
    // bot-left
    -1,
    -1,
    0,
    // bot-right
    1,
    -1,
    0
  ]);
  t.setAttribute("position", new R(i, 3));
  const e = new Float32Array([
    // top
    0.5,
    1,
    // bot-left
    0,
    0,
    // bot-right
    1,
    0
  ]);
  return t.setAttribute("uv", new R(e, 2)), t.computeVertexNormals(), t;
};
var et2 = new Pe2(-1, 1, 1, -1, 0, 1);
var tt2 = class extends ee2 {
  constructor() {
    super(), this.setAttribute("position", new ie([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ie([0, 2, 0, 0, 2, 0], 2));
  }
};
var it2 = new tt2();
var nt2 = class {
  constructor(i) {
    this._mesh = new Re2(it2, i);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(i) {
    i.render(this._mesh, et2);
  }
  get material() {
    return this._mesh.material;
  }
  set material(i) {
    this._mesh.material = i;
  }
};
var rt2 = class {
  constructor(i, e, n) {
    this.variables = [], this.currentTextureIndex = 0;
    let r = C;
    const s = {
      passThruTexture: { value: null }
    }, a = o(g(), s), l = new nt2(a);
    this.setDataType = function(c) {
      return r = c, this;
    }, this.addVariable = function(c, f, m2) {
      const p = this.createShaderMaterial(f), d = {
        name: c,
        initialValueTexture: m2,
        material: p,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: b,
        magFilter: b
      };
      return this.variables.push(d), d;
    }, this.setVariableDependencies = function(c, f) {
      c.dependencies = f;
    }, this.init = function() {
      if (n.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let c = 0; c < this.variables.length; c++) {
        const f = this.variables[c];
        f.renderTargets[0] = this.createRenderTarget(i, e, f.wrapS, f.wrapT, f.minFilter, f.magFilter), f.renderTargets[1] = this.createRenderTarget(i, e, f.wrapS, f.wrapT, f.minFilter, f.magFilter), this.renderTexture(f.initialValueTexture, f.renderTargets[0]), this.renderTexture(f.initialValueTexture, f.renderTargets[1]);
        const m2 = f.material, p = m2.uniforms;
        if (f.dependencies !== null)
          for (let d = 0; d < f.dependencies.length; d++) {
            const w = f.dependencies[d];
            if (w.name !== f.name) {
              let _ = false;
              for (let x = 0; x < this.variables.length; x++)
                if (w.name === this.variables[x].name) {
                  _ = true;
                  break;
                }
              if (!_)
                return "Variable dependency not found. Variable=" + f.name + ", dependency=" + w.name;
            }
            p[w.name] = { value: null }, m2.fragmentShader = `
uniform sampler2D ` + w.name + `;
` + m2.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const c = this.currentTextureIndex, f = this.currentTextureIndex === 0 ? 1 : 0;
      for (let m2 = 0, p = this.variables.length; m2 < p; m2++) {
        const d = this.variables[m2];
        if (d.dependencies !== null) {
          const w = d.material.uniforms;
          for (let _ = 0, x = d.dependencies.length; _ < x; _++) {
            const v4 = d.dependencies[_];
            w[v4.name].value = v4.renderTargets[c].texture;
          }
        }
        this.doRenderTarget(d.material, d.renderTargets[f]);
      }
      this.currentTextureIndex = f;
    }, this.getCurrentRenderTarget = function(c) {
      return c.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(c) {
      return c.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      l.dispose();
      const c = this.variables;
      for (let f = 0; f < c.length; f++) {
        const m2 = c[f];
        m2.initialValueTexture && m2.initialValueTexture.dispose();
        const p = m2.renderTargets;
        for (let d = 0; d < p.length; d++)
          p[d].dispose();
      }
    };
    function u(c) {
      c.defines.resolution = "vec2( " + i.toFixed(1) + ", " + e.toFixed(1) + " )";
    }
    this.addResolutionDefine = u;
    function o(c, f) {
      f = f || {};
      const m2 = new Ve({
        name: "GPUComputationShader",
        uniforms: f,
        vertexShader: h(),
        fragmentShader: c
      });
      return u(m2), m2;
    }
    this.createShaderMaterial = o, this.createRenderTarget = function(c, f, m2, p, d, w) {
      return c = c || i, f = f || e, m2 = m2 || k2, p = p || k2, d = d || b, w = w || b, new Ce2(c, f, {
        wrapS: m2,
        wrapT: p,
        minFilter: d,
        magFilter: w,
        format: L,
        type: r,
        depthBuffer: false
      });
    }, this.createTexture = function() {
      const c = new Float32Array(i * e * 4), f = new Q2(c, i, e, L, C);
      return f.needsUpdate = true, f;
    }, this.renderTexture = function(c, f) {
      s.passThruTexture.value = c, this.doRenderTarget(a, f), s.passThruTexture.value = null;
    }, this.doRenderTarget = function(c, f) {
      const m2 = n.getRenderTarget(), p = n.xr.enabled, d = n.shadowMap.autoUpdate;
      n.xr.enabled = false, n.shadowMap.autoUpdate = false, l.material = c, n.setRenderTarget(f), l.render(n), l.material = a, n.xr.enabled = p, n.shadowMap.autoUpdate = d, n.setRenderTarget(m2);
    };
    function h() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function g() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
};
var st2 = (
  /*glsl*/
  `
  #include <common>
  uniform sampler2D instructionsTexture;

  uniform sampler2D spritesheetData;
  uniform vec2 dataSize;
  uniform float fps;
  uniform float deltaTime;

  // read spritesheet metadata
  vec4 readData(float col, float row, sampler2D tex) {
    float wStep = 1.f / dataSize.x;
    float wHalfStep = wStep * 0.5f;
    float hStep = 1.f / dataSize.y;
    float hHalfStep = 1.f / dataSize.y * 0.5f;
    return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
  }



  void main()	{

    // OUTPUT FROM THIS SHADER
    // progressValue.r - picked animation frame
    // progressValue.g - previous progress state (for pause, reverse & pingpong consistency)
    // progressValue.b - not used yet
    // progressValue.a - previous animationID

    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;


    vec4 progressValue = texture2D( progress, uv );

    vec4 instructions = texture2D( instructionsTexture, uv);

    // FREEZE FRAME - return to save calculations?
    if(instructions.a >=10.){
      progressValue.r = instructions.a - 10.;
      progressValue.a = instructions.x;
      progressValue.g = progressValue.g;
      gl_FragColor = progressValue;
      return;
    }


    progressValue.b = 0.;

    // todo shouldn't be rounding here, pick
    float animationId = round(instructions.x);

    float offset = instructions.g;

    float animLength = readData(animationId, 1.f, spritesheetData).r;
    float totalTime = animLength / fps;

    // new delta is % of animation
    float newProgress = deltaTime / totalTime;
    // add new delta to saved progress
    float frameTimedId = mod(progressValue.g + newProgress, 1.);
    // frameTimedId = 0.;
    // float frameTimedId = progressValue.g;
    // save for use in next frame



    float playMode = mod(instructions.b, 10.);

    // forward
    if(playMode == 0.){
      frameTimedId = progressValue.g + newProgress;
    }
    // reverse
    if(playMode == 1.){
      frameTimedId = progressValue.g - newProgress;
    }
    // 2 - pause - do nothing
    if(playMode == 2.){
      frameTimedId = progressValue.g;
    }

    // //todo pingpong
    // if(playMode == 3.){
    // }

    // loop (play once over 10.)
    if(instructions.b < 10.){
      frameTimedId = mod(frameTimedId, 1.);
    }

    // todo This could be optional and user would reset manually,
    // todo allowing for consistent movement across multiple animations
    // todo for example - running steps being syncec
    // start anim from beginning if animationID changes
    if(progressValue.a != instructions.x){
      frameTimedId = 0.;
    }

    float frameId = floor(animLength * frameTimedId);
    float spritesheetFrameId = readData(frameId, 2.f + animationId, spritesheetData).r;



    // Picked sprite frame that goes to material
    progressValue.r = spritesheetFrameId;

    progressValue.a = instructions.x;
    progressValue.g = frameTimedId;

    gl_FragColor = progressValue;
  }
`
);
var at2 = (t = 512) => {
  const i = new Float32Array(t ** 2 * 4);
  for (let n = 0; n < t ** 2 * 4; n++)
    i[n] = 0;
  const e = new Q2(
    i,
    t,
    t,
    L,
    C
  );
  return e.minFilter = b, e.magFilter = b, e.wrapS = k2, e.wrapT = q2, e.needsUpdate = true, e;
};
var ot2 = (t) => {
  if (t <= 0)
    return 1;
  let i = 1;
  for (; i < t; )
    i <<= 1;
  return i;
};
var lt2 = (t, i) => {
  const e = ot2(Math.sqrt(i)), n = new rt2(
    e,
    e,
    t
  ), r = n.createTexture(), s = n.addVariable(
    "progress",
    st2,
    r
  ), a = at2(e);
  s.material.uniforms.instructionsTexture = {
    value: a
  }, s.material.uniforms.spritesheetData = { value: null }, s.material.uniforms.fps = { value: 0 }, s.material.uniforms.deltaTime = { value: 0 }, s.material.uniforms.dataSize = { value: new $2() }, n.setVariableDependencies(s, [s]);
  const l = n.init();
  l !== null && console.error(l);
  let u = false;
  return {
    gpuCompute: n,
    animationRunner: s,
    progressDataTexture: a,
    utils: {
      updateAnimationAt: (m2, p) => {
        const d = m2 * 4;
        a.image.data[d] = p, u = true;
      },
      updateOffsetAt: (m2, p) => {
        const d = m2 * 4;
        a.image.data[d + 1] = p, u = true;
      },
      updatePlaymodeAt: (m2, p) => {
        const d = m2 * 4;
        a.image.data[d + 2] = p, u = true;
      },
      updateFrameAt: (m2, p) => {
        const d = m2 * 4;
        a.image.data[d + 3] = p + 10, u = true;
      }
    },
    update: () => {
      u && (a.needsUpdate = true, u = false), n.compute();
    }
  };
};
var ut2 = class {
  constructor() {
    y(this, "_previousTime");
    y(this, "_currentTime");
    y(this, "_startTime");
    y(this, "_delta");
    y(this, "_elapsed");
    y(this, "_timescale");
    y(this, "_useFixedDelta");
    y(this, "_fixedDelta");
    y(this, "_usePageVisibilityAPI");
    y(this, "_pageVisibilityHandler");
    this._previousTime = 0, this._currentTime = 0, this._startTime = B(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = false, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === true && (this._pageVisibilityHandler = ct2.bind(this), document.addEventListener(
      "visibilitychange",
      this._pageVisibilityHandler,
      false
    ));
  }
  disableFixedDelta() {
    return this._useFixedDelta = false, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === true && document.removeEventListener(
      "visibilitychange",
      this._pageVisibilityHandler
    ), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = true, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = B() - this._startTime, this;
  }
  setFixedDelta(i) {
    return this._fixedDelta = i * 1e3, this;
  }
  setTimescale(i) {
    return this._timescale = i, this;
  }
  update() {
    return this._useFixedDelta === true ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = B() - this._startTime, this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
};
function B() {
  return (typeof performance > "u" ? Date : performance).now();
}
function ct2() {
  document.hidden === false && this.reset();
}
var K2 = {
  FORWARD: 0,
  REVERSE: 1,
  PAUSE: 2,
  PINGPONG: 3
};
var Xt2 = class extends je2 {
  constructor(e, n, r, s = {
    geometry: "quad"
  }) {
    let a;
    s.geometry || (s.geometry = "quad"), s.geometry === "tri" && (a = qe2()), s.geometry === "quad" && (a = new Ie2(1, 1)), s.geometry && typeof s.geometry != "string" && (a = s.geometry);
    const l = Je(
      e,
      (s == null ? void 0 : s.geometry) === "tri"
    );
    super(a, l, n);
    y(this, "_spriteMaterial");
    y(this, "_spritesheet");
    y(this, "_animationMap");
    y(this, "_fps", 15);
    y(this, "_timer");
    y(this, "compute");
    ne >= 159 ? (this.instanceMatrix.clearUpdateRanges(), this.instanceMatrix.addUpdateRange(0, n * 16)) : this.instanceMatrix.updateRange.count = n * 16, this.instanceColor && (ne >= 159 ? (this.instanceColor.clearUpdateRanges(), this.instanceColor.addUpdateRange(0, n * 3)) : this.instanceColor.updateRange.count = n * 3), this.compute = lt2(r, n), this._spriteMaterial = l, s.spritesheet && this.updateSpritesheet(s.spritesheet), this._timer = new ut2(), this._animationMap = /* @__PURE__ */ new Map(), this._spriteMaterial.uniforms.animationData.value = this.compute.gpuCompute.getCurrentRenderTarget(
      this.compute.animationRunner
    ).texture, this._spriteMaterial.uniforms.animationDataSize.value = this.compute.progressDataTexture.image.width;
  }
  updateSpritesheet(e) {
    const { dataTexture: n, dataWidth: r, dataHeight: s, animMap: a } = Qe(e);
    this._spriteMaterial.uniforms.spritesheetData.value = n, this._spriteMaterial.uniforms.dataSize.value.x = r, this._spriteMaterial.uniforms.dataSize.value.y = s, this.compute.animationRunner.material.uniforms.dataSize.value = new $2(r, s), this.compute.animationRunner.material.uniforms.spritesheetData.value = n, this._animationMap = a;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(e) {
    this.updateSpritesheet(e), this._spritesheet = e;
  }
  get animationMap() {
    return this._animationMap;
  }
  get animation() {
    return {
      setAt: (e, n) => {
        this.compute.utils.updateAnimationAt(
          e,
          this._animationMap.get(n) || 0
        );
      }
    };
  }
  get frame() {
    return {
      setAt: (e, n, r) => {
        var a;
        let s = n;
        r && (s = (a = this.spritesheet) == null ? void 0 : a.animations[r][n][0]), this.compute.utils.updateFrameAt(e, s);
      },
      unsetAt: (e) => {
        this.compute.utils.updateFrameAt(e, -10);
      },
      unsetAll: () => {
        for (let e = 0; e < this.count; e++)
          this.compute.utils.updateFrameAt(e, -10);
      }
    };
  }
  get playmode() {
    return {
      setAt: (e, n) => {
        this.compute.utils.updatePlaymodeAt(e, K2[n]);
      },
      setAll: (e) => {
        for (let n = 0; n < this.count; n++) {
          const r = this.compute.progressDataTexture.image.data[n * 4 + 2] >= 10 ? 10 : 0;
          this.compute.utils.updatePlaymodeAt(n, r + K2[e]);
        }
      }
    };
  }
  get billboarding() {
    return {
      setAt: (e, n) => {
        this.setUniformAt("billboarding", e, n ? 1 : 0);
      },
      setAll: (e) => {
        this._spriteMaterial.uniforms.billboarding.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("billboarding");
      }
    };
  }
  get offset() {
    return {
      setAt: (e, n) => {
        this.compute.utils.updateOffsetAt(e, n);
      },
      randomizeAll: (e = 1) => {
        for (let n = 0; n < this.count; n++)
          this.compute.utils.updateOffsetAt(n, Math.random() * e);
      }
    };
  }
  get loop() {
    return {
      setAt: (e, n) => {
        const r = this.compute.progressDataTexture.image.data[e * 4 + 2] % 10;
        this.compute.utils.updatePlaymodeAt(
          e,
          r + (n ? 0 : 10)
        );
      },
      setAll: (e) => {
        for (let n = 0; n < this.count; n++) {
          const r = this.compute.progressDataTexture.image.data[n * 4 + 2] % 10;
          this.compute.utils.updatePlaymodeAt(n, r + (e ? 0 : 10));
        }
      }
    };
  }
  get flipX() {
    return {
      setAt: (e, n) => {
        this.setUniformAt("flipX", e, n ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipX.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipX");
      }
    };
  }
  get flipY() {
    return {
      setAt: (e, n) => {
        this.setUniformAt("flipY", e, n ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipY.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipY");
      }
    };
  }
  play(e, n = true, r = "FORWARD") {
    return {
      at: (s) => {
        this.compute.utils.updateAnimationAt(
          s,
          this._animationMap.get(e) || 0
        ), this.compute.utils.updatePlaymodeAt(
          s,
          K2[r] + (n ? 0 : 10)
        );
      }
    };
  }
  /** HSV shift tinting */
  get hueShift() {
    const e = new he2();
    return {
      // TODO - per instance tinting doesnt work - artifacts
      // setAt: (
      //   instanceId: number,
      //   tint?: { h: number; s: number; v: number }
      // ) => {
      //   if (tint) {
      //     tVector.set(tint.h, tint.s, tint.v, 1);
      //   } else {
      //     tVector.setW(0);
      //   }
      //   this.setUniformAt("tint", instanceId, tVector);
      // },
      setGlobal: (n) => {
        n ? e.set(n.h, n.s, n.v, 1) : e.setW(0), this._spriteMaterial.uniforms.tint.value = e;
      }
      // unsetAll: () => {
      //   this.unsetUniform("tint");
      // },
    };
  }
  get fps() {
    return this._fps;
  }
  set fps(e) {
    this._fps = e, this.compute.animationRunner.material.uniforms.fps.value = e;
  }
  update() {
    this._timer.update();
    const e = this._timer.getDelta();
    this.compute.animationRunner.material.uniforms.deltaTime.value = e, this.compute.update();
  }
};
function ft2(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var te2 = { exports: {} };
te2.exports = G;
te2.exports.default = G;
function G(t, i, e) {
  e = e || 2;
  var n = i && i.length, r = n ? i[0] * e : t.length, s = de2(t, 0, r, e, true), a = [];
  if (!s || s.next === s.prev)
    return a;
  var l, u, o, h, g, c, f;
  if (n && (s = gt2(t, i, s, e)), t.length > 80 * e) {
    l = o = t[0], u = h = t[1];
    for (var m2 = e; m2 < r; m2 += e)
      g = t[m2], c = t[m2 + 1], g < l && (l = g), c < u && (u = c), g > o && (o = g), c > h && (h = c);
    f = Math.max(o - l, h - u), f = f !== 0 ? 32767 / f : 0;
  }
  return I(s, a, e, l, u, f, 0), a;
}
function de2(t, i, e, n, r) {
  var s, a;
  if (r === X2(t, i, e, n) > 0)
    for (s = i; s < e; s += n)
      a = me2(s, t[s], t[s + 1], a);
  else
    for (s = e - n; s >= i; s -= n)
      a = me2(s, t[s], t[s + 1], a);
  return a && Z(a, a.next) && (E(a), a = a.next), a;
}
function F(t, i) {
  if (!t)
    return t;
  i || (i = t);
  var e = t, n;
  do
    if (n = false, !e.steiner && (Z(e, e.next) || M2(e.prev, e, e.next) === 0)) {
      if (E(e), e = i = e.prev, e === e.next)
        break;
      n = true;
    } else
      e = e.next;
  while (n || e !== i);
  return i;
}
function I(t, i, e, n, r, s, a) {
  if (t) {
    !a && s && _t2(t, n, r, s);
    for (var l = t, u, o; t.prev !== t.next; ) {
      if (u = t.prev, o = t.next, s ? ht2(t, n, r, s) : mt2(t)) {
        i.push(u.i / e | 0), i.push(t.i / e | 0), i.push(o.i / e | 0), E(t), t = o.next, l = o.next;
        continue;
      }
      if (t = o, t === l) {
        a ? a === 1 ? (t = pt2(F(t), i, e), I(t, i, e, n, r, s, 2)) : a === 2 && dt2(t, i, e, n, r, s) : I(F(t), i, e, n, r, s, 1);
        break;
      }
    }
  }
}
function mt2(t) {
  var i = t.prev, e = t, n = t.next;
  if (M2(i, e, n) >= 0)
    return false;
  for (var r = i.x, s = e.x, a = n.x, l = i.y, u = e.y, o = n.y, h = r < s ? r < a ? r : a : s < a ? s : a, g = l < u ? l < o ? l : o : u < o ? u : o, c = r > s ? r > a ? r : a : s > a ? s : a, f = l > u ? l > o ? l : o : u > o ? u : o, m2 = n.next; m2 !== i; ) {
    if (m2.x >= h && m2.x <= c && m2.y >= g && m2.y <= f && V2(r, l, s, u, a, o, m2.x, m2.y) && M2(m2.prev, m2, m2.next) >= 0)
      return false;
    m2 = m2.next;
  }
  return true;
}
function ht2(t, i, e, n) {
  var r = t.prev, s = t, a = t.next;
  if (M2(r, s, a) >= 0)
    return false;
  for (var l = r.x, u = s.x, o = a.x, h = r.y, g = s.y, c = a.y, f = l < u ? l < o ? l : o : u < o ? u : o, m2 = h < g ? h < c ? h : c : g < c ? g : c, p = l > u ? l > o ? l : o : u > o ? u : o, d = h > g ? h > c ? h : c : g > c ? g : c, w = W(f, m2, i, e, n), _ = W(p, d, i, e, n), x = t.prevZ, v4 = t.nextZ; x && x.z >= w && v4 && v4.z <= _; ) {
    if (x.x >= f && x.x <= p && x.y >= m2 && x.y <= d && x !== r && x !== a && V2(l, h, u, g, o, c, x.x, x.y) && M2(x.prev, x, x.next) >= 0 || (x = x.prevZ, v4.x >= f && v4.x <= p && v4.y >= m2 && v4.y <= d && v4 !== r && v4 !== a && V2(l, h, u, g, o, c, v4.x, v4.y) && M2(v4.prev, v4, v4.next) >= 0))
      return false;
    v4 = v4.nextZ;
  }
  for (; x && x.z >= w; ) {
    if (x.x >= f && x.x <= p && x.y >= m2 && x.y <= d && x !== r && x !== a && V2(l, h, u, g, o, c, x.x, x.y) && M2(x.prev, x, x.next) >= 0)
      return false;
    x = x.prevZ;
  }
  for (; v4 && v4.z <= _; ) {
    if (v4.x >= f && v4.x <= p && v4.y >= m2 && v4.y <= d && v4 !== r && v4 !== a && V2(l, h, u, g, o, c, v4.x, v4.y) && M2(v4.prev, v4, v4.next) >= 0)
      return false;
    v4 = v4.nextZ;
  }
  return true;
}
function pt2(t, i, e) {
  var n = t;
  do {
    var r = n.prev, s = n.next.next;
    !Z(r, s) && ge2(r, n, n.next, s) && O2(r, s) && O2(s, r) && (i.push(r.i / e | 0), i.push(n.i / e | 0), i.push(s.i / e | 0), E(n), E(n.next), n = t = s), n = n.next;
  } while (n !== t);
  return F(n);
}
function dt2(t, i, e, n, r, s) {
  var a = t;
  do {
    for (var l = a.next.next; l !== a.prev; ) {
      if (a.i !== l.i && Dt2(a, l)) {
        var u = xe2(a, l);
        a = F(a, a.next), u = F(u, u.next), I(a, i, e, n, r, s, 0), I(u, i, e, n, r, s, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== t);
}
function gt2(t, i, e, n) {
  var r = [], s, a, l, u, o;
  for (s = 0, a = i.length; s < a; s++)
    l = i[s] * n, u = s < a - 1 ? i[s + 1] * n : t.length, o = de2(t, l, u, n, false), o === o.next && (o.steiner = true), r.push(Tt(o));
  for (r.sort(xt2), s = 0; s < r.length; s++)
    e = vt2(r[s], e);
  return e;
}
function xt2(t, i) {
  return t.x - i.x;
}
function vt2(t, i) {
  var e = yt2(t, i);
  if (!e)
    return i;
  var n = xe2(e, t);
  return F(n, n.next), F(e, e.next);
}
function yt2(t, i) {
  var e = i, n = t.x, r = t.y, s = -1 / 0, a;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      var l = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (l <= n && l > s && (s = l, a = e.x < e.next.x ? e : e.next, l === n))
        return a;
    }
    e = e.next;
  } while (e !== i);
  if (!a)
    return null;
  var u = a, o = a.x, h = a.y, g = 1 / 0, c;
  e = a;
  do
    n >= e.x && e.x >= o && n !== e.x && V2(r < h ? n : s, r, o, h, r < h ? s : n, r, e.x, e.y) && (c = Math.abs(r - e.y) / (n - e.x), O2(e, t) && (c < g || c === g && (e.x > a.x || e.x === a.x && wt2(a, e))) && (a = e, g = c)), e = e.next;
  while (e !== u);
  return a;
}
function wt2(t, i) {
  return M2(t.prev, t, i.prev) < 0 && M2(i.next, t, t.next) < 0;
}
function _t2(t, i, e, n) {
  var r = t;
  do
    r.z === 0 && (r.z = W(r.x, r.y, i, e, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== t);
  r.prevZ.nextZ = null, r.prevZ = null, Mt2(r);
}
function Mt2(t) {
  var i, e, n, r, s, a, l, u, o = 1;
  do {
    for (e = t, t = null, s = null, a = 0; e; ) {
      for (a++, n = e, l = 0, i = 0; i < o && (l++, n = n.nextZ, !!n); i++)
        ;
      for (u = o; l > 0 || u > 0 && n; )
        l !== 0 && (u === 0 || !n || e.z <= n.z) ? (r = e, e = e.nextZ, l--) : (r = n, n = n.nextZ, u--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
      e = n;
    }
    s.nextZ = null, o *= 2;
  } while (a > 1);
  return t;
}
function W(t, i, e, n, r) {
  return t = (t - e) * r | 0, i = (i - n) * r | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t | i << 1;
}
function Tt(t) {
  var i = t, e = t;
  do
    (i.x < e.x || i.x === e.x && i.y < e.y) && (e = i), i = i.next;
  while (i !== t);
  return e;
}
function V2(t, i, e, n, r, s, a, l) {
  return (r - a) * (i - l) >= (t - a) * (s - l) && (t - a) * (n - l) >= (e - a) * (i - l) && (e - a) * (s - l) >= (r - a) * (n - l);
}
function Dt2(t, i) {
  return t.next.i !== i.i && t.prev.i !== i.i && !At2(t, i) && // dones't intersect other edges
  (O2(t, i) && O2(i, t) && bt2(t, i) && // locally visible
  (M2(t.prev, t, i.prev) || M2(t, i.prev, i)) || // does not create opposite-facing sectors
  Z(t, i) && M2(t.prev, t, t.next) > 0 && M2(i.prev, i, i.next) > 0);
}
function M2(t, i, e) {
  return (i.y - t.y) * (e.x - i.x) - (i.x - t.x) * (e.y - i.y);
}
function Z(t, i) {
  return t.x === i.x && t.y === i.y;
}
function ge2(t, i, e, n) {
  var r = H2(M2(t, i, e)), s = H2(M2(t, i, n)), a = H2(M2(e, n, t)), l = H2(M2(e, n, i));
  return !!(r !== s && a !== l || r === 0 && z(t, e, i) || s === 0 && z(t, n, i) || a === 0 && z(e, t, n) || l === 0 && z(e, i, n));
}
function z(t, i, e) {
  return i.x <= Math.max(t.x, e.x) && i.x >= Math.min(t.x, e.x) && i.y <= Math.max(t.y, e.y) && i.y >= Math.min(t.y, e.y);
}
function H2(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function At2(t, i) {
  var e = t;
  do {
    if (e.i !== t.i && e.next.i !== t.i && e.i !== i.i && e.next.i !== i.i && ge2(e, e.next, t, i))
      return true;
    e = e.next;
  } while (e !== t);
  return false;
}
function O2(t, i) {
  return M2(t.prev, t, t.next) < 0 ? M2(t, i, t.next) >= 0 && M2(t, t.prev, i) >= 0 : M2(t, i, t.prev) < 0 || M2(t, t.next, i) < 0;
}
function bt2(t, i) {
  var e = t, n = false, r = (t.x + i.x) / 2, s = (t.y + i.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;
  while (e !== t);
  return n;
}
function xe2(t, i) {
  var e = new Y2(t.i, t.x, t.y), n = new Y2(i.i, i.x, i.y), r = t.next, s = i.prev;
  return t.next = i, i.prev = t, e.next = r, r.prev = e, n.next = e, e.prev = n, s.next = n, n.prev = s, n;
}
function me2(t, i, e, n) {
  var r = new Y2(t, i, e);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function E(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Y2(t, i, e) {
  this.i = t, this.x = i, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
G.deviation = function(t, i, e, n) {
  var r = i && i.length, s = r ? i[0] * e : t.length, a = Math.abs(X2(t, 0, s, e));
  if (r)
    for (var l = 0, u = i.length; l < u; l++) {
      var o = i[l] * e, h = l < u - 1 ? i[l + 1] * e : t.length;
      a -= Math.abs(X2(t, o, h, e));
    }
  var g = 0;
  for (l = 0; l < n.length; l += 3) {
    var c = n[l] * e, f = n[l + 1] * e, m2 = n[l + 2] * e;
    g += Math.abs(
      (t[c] - t[m2]) * (t[f + 1] - t[c + 1]) - (t[c] - t[f]) * (t[m2 + 1] - t[c + 1])
    );
  }
  return a === 0 && g === 0 ? 0 : Math.abs((g - a) / a);
};
function X2(t, i, e, n) {
  for (var r = 0, s = i, a = e - n; s < e; s += n)
    r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
  return r;
}
G.flatten = function(t) {
  for (var i = t[0][0].length, e = { vertices: [], holes: [], dimensions: i }, n = 0, r = 0; r < t.length; r++) {
    for (var s = 0; s < t[r].length; s++)
      for (var a = 0; a < i; a++)
        e.vertices.push(t[r][s][a]);
    r > 0 && (n += t[r - 1].length, e.holes.push(n));
  }
  return e;
};
var Ut = te2.exports;
var Ft2 = ft2(Ut);
new $2();
new $2();
function St2(t, i) {
  var e = t % i, n = Math.floor(t / i);
  return [e, n];
}
function Pt2(t, i, e) {
  for (var n = 0, r = 0; n < t.length; n += i, r++)
    if (i === 3) {
      var s = e([t[n], t[n + 1], t[n + 2]], r);
      t.set(s, n);
    } else
      t.set(e([t[n], t[n + 1]], r), n);
  return t;
}
function Rt2(t, i, e, n) {
  var r = e.x - n.x, s = t.x - i.x, a = e.y - n.y, l = t.y - i.y, u = s * a - l * r;
  if (u == 0)
    throw new Error("Number of intersection points is zero or infinity.");
  var o = t.x * i.y - t.y * i.x, h = e.x * n.y - e.y * n.x, g = (o * r - s * h) / u, c = (o * a - l * h) / u, f = { x: g, y: c };
  return f;
}
function Vt2(t) {
  for (var i = 0, e = 0, n = t.length; e < n; e++) {
    var r = t[e].x, s = t[e == t.length - 1 ? 0 : e + 1].y, a = t[e == t.length - 1 ? 0 : e + 1].x, l = t[e].y;
    i += r * s * 0.5, i -= a * l * 0.5;
  }
  return Math.abs(i);
}
function Ct2([t, i, e]) {
  return Math.abs(
    (t.x * (i.y - e.y) + i.x * (e.y - t.y) + e.x * (t.y - i.y)) / 2
  );
}
function It2(t, i = 8) {
  const e = t.slice();
  let n = 0;
  for (; e.length > i && n < 1e3; ) {
    n++;
    let r = 1 / 0, s = null;
    for (let a = 0; a <= e.length - 1; a++) {
      const l = e.length, u = [a, (a + 1) % l, (a + 2) % l, (a + 3) % l], o = e[u[0]], h = e[u[1]], g = e[u[2]], c = e[u[3]];
      try {
        const f = Rt2(o, h, g, c), m2 = Ct2([f, h, g]);
        m2 < r && (r = m2, s = {
          point: f,
          area: m2,
          indicesToRemove: [u[1], u[2]]
        });
      } catch (f) {
        console.log(f);
      }
    }
    if (s) {
      const a = s.indicesToRemove[0], l = s.indicesToRemove[1];
      l > a ? (e.splice(l, 1), e.splice(a, 1)) : (e.splice(a, 1), e.splice(l, 1)), e.splice(Math.min(a, l), 0, s.point);
    }
  }
  return e;
}
var J;
((t) => {
  function i(r) {
    let s = r.slice();
    return s.sort(t.POINT_COMPARATOR), t.makeHullPresorted(s);
  }
  t.makeHull = i;
  function e(r) {
    if (r.length <= 1)
      return r.slice();
    let s = [];
    for (let l = 0; l < r.length; l++) {
      const u = r[l];
      for (; s.length >= 2; ) {
        const o = s[s.length - 1], h = s[s.length - 2];
        if ((o.x - h.x) * (u.y - h.y) >= (o.y - h.y) * (u.x - h.x))
          s.pop();
        else
          break;
      }
      s.push(u);
    }
    s.pop();
    let a = [];
    for (let l = r.length - 1; l >= 0; l--) {
      const u = r[l];
      for (; a.length >= 2; ) {
        const o = a[a.length - 1], h = a[a.length - 2];
        if ((o.x - h.x) * (u.y - h.y) >= (o.y - h.y) * (u.x - h.x))
          a.pop();
        else
          break;
      }
      a.push(u);
    }
    return a.pop(), s.length == 1 && a.length == 1 && s[0].x == a[0].x && s[0].y == a[0].y ? s : s.concat(a);
  }
  t.makeHullPresorted = e;
  function n(r, s) {
    return r.x < s.x ? -1 : r.x > s.x ? 1 : r.y < s.y ? -1 : r.y > s.y ? 1 : 0;
  }
  t.POINT_COMPARATOR = n;
})(J || (J = {}));
function Ot2(t, i) {
  const e = new Float32Array(t);
  for (let n = 0; n < t; n++)
    e[n * 3] = i[0], e[n * 3 + 1] = i[1], e[n * 3 + 2] = i[2];
  return e;
}
function Et2(t, i, e = () => Math.random()) {
  const n = i + 1, r = new Float32Array(t.length / i * n);
  for (let s = 0; s < t.length; s += i) {
    let a = s / i * n;
    r[a] = t[s], r[a + 1] = t[s + 1], i === 2 && (r[a + 2] = e(a)), i === 3 && (r[a + 2] = t[s + 2], r[a + 3] = e(a));
  }
  return r;
}
function $t2(t) {
  const i = new Float32Array(t.length * 2);
  for (let e = 0; e < t.length; e++)
    i[e * 2] = t[e].x, i[e * 2 + 1] = t[e].y;
  return i;
}
function zt2(t, i, e) {
  const n = [], r = t % (i * 4) / 4, s = Math.floor(t / (i * 4)), a = s - 1, l = s + 1, u = r - 1, o = r + 1;
  return a >= 0 ? n.push(a * i + r) : n.push(null), l < e ? n.push(l * i + r) : n.push(null), u >= 0 ? n.push(s * i + u) : n.push(null), o < i ? n.push(s * i + o) : n.push(null), n;
}
var Ht2 = (t) => (...i) => i[3] / 255 > 0;
var Lt = {
  threshold: 0.01,
  slices: [1, 1],
  indices: [0, 0],
  scale: 1,
  filter: Ht2
};
var kt2 = class {
  constructor(i, e, n) {
    y(this, "points", []);
    y(this, "data", {
      areaReduction: 0
    });
    y(this, "debug", true);
    y(this, "index");
    y(this, "positions");
    y(this, "uv");
    y(this, "defaultSettings", Lt);
    y(this, "settings");
    this.vertices = n, this.settings = { ...this.defaultSettings, ...e };
    const { slices: r } = this.settings, s = Nt2("bvc-image", i.width, i.height);
    this.points = this.getPoints(i, s);
    let a = J.makeHull(this.points);
    const l = It2(a, n), u = l.map((c) => {
      let f = Gt2(c, [i.width, i.height], r);
      return f.y = -1 * f.y, f;
    }), { scale: o } = this.settings;
    this.data.areaReduction = 1 - Vt2(l) / (i.width / r[0] * (i.height / r[1])) * o;
    const h = $t2(u), g = Ft2(h, null, 2);
    this.positions = Et2(h, 2, () => 0), this.index = Uint32Array.from(g), this.uv = Pt2(h.slice(0), 2, (c) => {
      let f = c[0] + 0.5;
      f = f / this.settings.slices[0] + 1 / this.settings.slices[0] * this.settings.indices[0];
      let m2 = c[1] + 0.5;
      return m2 = m2 / this.settings.slices[1] + 1 - 1 / this.settings.slices[1] * (this.settings.indices[1] + 1), [f, m2];
    });
  }
  getImageData(i, e) {
    const n = e.getContext("2d");
    n.drawImage(i, 0, 0);
    const [r, s] = this.settings.indices, [a, l] = this.settings.slices, u = e.width / a, o = e.height / l;
    return n.getImageData(u * r, o * s, u, o);
  }
  /**
   * Iterates over the image and returns an array of points that are over the alpha threshold.
   * It reduces the number of returned points by excluding points that are surrounded by solid pixels.
   *
   * @param img An image element with the image already loaded
   * @param canvas A canvas element to draw the image on in order to get the color values
   * @returns
   */
  getPoints(i, e) {
    const n = this.getImageData(i, e), r = n.data, s = [], a = this.settings.filter(this.settings.threshold), l = (u) => u !== null && a(
      r[u * 4],
      r[u * 4 + 1],
      r[u * 4 + 2],
      r[u * 4 + 3]
    );
    for (let u = 0; u < r.length; u += 4)
      if (a(
        r[u + 0],
        r[u + 1],
        r[u + 2],
        r[u + 3]
      )) {
        if (zt2(u, e.width, e.height).every(l))
          continue;
        const [g, c] = St2(u / 4, n.width);
        s.push({ x: g, y: c });
      }
    return s;
  }
};
var Nt2 = (t = "debug-canvas", i, e) => {
  const n = document.querySelector(`#${t}`) || document.createElement("canvas");
  return n.id = t, n.width = i, n.height = e, n.id = t, n;
};
var Gt2 = (t, i, e) => ({
  x: (t.x - i[0] / (2 * e[0])) / (i[0] / e[0]),
  y: (t.y - i[1] / (2 * e[1])) / (i[1] / e[1])
});
var Zt2 = {
  threshold: 0.01,
  slices: [1, 1],
  indices: [1, 1]
};
var Bt2 = class extends ee2 {
  constructor(e, n = 8, r = 0.01, s = [1, 1], a = [0, 0]) {
    super();
    y(this, "image");
    y(this, "vertices", 8);
    y(this, "settings", Zt2);
    this.vertices = n, this.settings = {
      ...this.settings,
      threshold: r,
      slices: s,
      indices: a
    }, this.image = "image" in e ? e.image : e, this.build();
  }
  build() {
    const e = new kt2(
      this.image,
      this.settings,
      this.vertices
    ), n = e.positions.length, r = new R(e.index, 1), s = new R(e.positions, 3), a = new R(Ot2(n, [0, 0, 1]), 3), l = new R(e.uv, 2);
    this.userData.reduction = e.data.areaReduction, this.setIndex(r), this.setAttribute("position", s), this.setAttribute("normal", a), this.setAttribute("uv", l);
  }
};
var Jt2 = () => new Kt2();
var Kt2 = class {
  constructor() {
    y(this, "animations");
    this.animations = [];
  }
  add(i, e, n) {
    const r = {
      name: "",
      imageUrl: i
    };
    return Array.isArray(n) ? r.multiAnimations = n : r.name = n, e.type == "rowColumn" && (r.auto = {
      type: "rowColumn",
      width: e.width,
      height: e.height
    }), e.type == "frameSize" && (r.auto = {
      type: "frameSize",
      width: e.width,
      height: e.height
    }), this.animations.push(r), this;
  }
  async build(i = {}) {
    const e = new Oe2(), n = {
      frames: [],
      animations: {},
      sheetSize: [0, 0],
      animationLengths: []
    };
    let r = new Ee2();
    const s = [];
    let a = 0, l = 0;
    for (const p of this.animations) {
      const d = await e.loadAsync(p.imageUrl), w = d.width, _ = d.height;
      a = Math.max(a, w), l += _, s.push({
        img: d,
        w,
        h: _
      });
    }
    const u = document.createElement("canvas");
    u.width = a, u.height = l;
    const o = u.getContext("2d");
    let h = 0;
    for (const { img: p, h: d } of s)
      o == null || o.drawImage(p, 0, h, p.width, p.height), h += d;
    r = new re2(u), r.needsUpdate = true;
    let g = 0, c = 0, f = 0, m2 = 64;
    for (const p of this.animations) {
      const d = s[g];
      let w = 0;
      if (p.auto) {
        let _ = 0, x = 0;
        p.auto.type == "frameSize" && (x = d.w / p.auto.width, _ = d.h / p.auto.height), p.auto.type == "rowColumn" && (x = p.auto.width, _ = p.auto.height);
        const v4 = d.w / x, S = d.h / _;
        w = _ * x, p.multiAnimations || (n.animations[p.name] = []);
        const P2 = /* @__PURE__ */ new Map();
        for (let D2 = 0; D2 < _; D2++) {
          f += S;
          for (let A2 = 0; A2 < x; A2++) {
            if (n.frames.push([
              d.w / x * A2 / a,
              1 - f / l,
              v4 / a,
              S / l
            ]), p.multiAnimations) {
              const ve2 = D2 * x + A2;
              P2.set(ve2, c);
            } else
              n.animations[p.name].push([c, 1]);
            c++;
          }
        }
        if (p.multiAnimations)
          for (const D2 of p.multiAnimations) {
            n.animations[D2.name] = [], n.animationLengths.push(
              D2.frameRange[1] - D2.frameRange[0] + 1
            );
            for (let A2 = D2.frameRange[0]; A2 <= D2.frameRange[1]; A2++)
              n.animations[D2.name].push([P2.get(A2), 1]);
          }
        else
          n.animationLengths.push(w);
      }
      g++;
    }
    if (r.matrixAutoUpdate = false, r.generateMipmaps = false, r.premultiplyAlpha = false, r.wrapS = r.wrapT = q2, r.magFilter = r.minFilter = b, r.colorSpace = se, n.sheetSize = [a, l], i.makeSlimGeometry) {
      const p = document.createElement("canvas");
      p.width = m2, p.height = m2;
      const d = p.getContext("2d"), w = a / m2, _ = l / m2;
      for (let S = 0; S < w; S++)
        for (let P2 = 0; P2 < _; P2++) {
          const D2 = S * m2, A2 = P2 * m2;
          d == null || d.drawImage(u, D2, A2, m2, m2, 0, 0, m2, m2);
        }
      const x = new re2(p);
      x.magFilter = r.minFilter = b, x.colorSpace = se;
      const v4 = new Bt2(
        x,
        // an already loaded HTMLImageElement or a ThreeJS texture
        i.slimOptions ? i.slimOptions.vertices : 8,
        i.slimOptions ? i.slimOptions.alphaThreshold : 0
        // alphaThreshold, 0 means only fully transparent pixels will be discarded
      );
      return { spritesheet: n, texture: r, geometry: v4 };
    }
    return { spritesheet: n, texture: r };
  }
};

// node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte
import { DoubleSide as DoubleSide10, Matrix4 as Matrix420, MeshBasicMaterial as MeshBasicMaterial7 } from "three";

// node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte
SpriteInstance[FILENAME] = "node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte";
function SpriteInstance($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SpriteInstance);
  let id = prop($$props, "id", 3, 0), position2 = prop($$props, "position", 19, () => [0, 0, 0]), scale = prop($$props, "scale", 19, () => [1, 1]);
  const { updatePosition, sprite } = getContext("instanced-sprite-ctx");
  user_pre_effect(() => {
    if (strict_equals(position2(), void 0, false)) updatePosition(id(), position2(), scale());
  });
  user_pre_effect(() => {
    if (strict_equals($$props.animationName, void 0, false)) sprite.animation.setAt(id(), $$props.animationName);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.playmode, void 0, false)) sprite.playmode.setAt(id(), $$props.playmode);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.billboarding, void 0, false)) sprite.billboarding.setAt(id(), $$props.billboarding);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.offset, void 0, false)) sprite.offset.setAt(id(), $$props.offset);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.loop, void 0, false)) sprite.loop.setAt(id(), $$props.loop);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.flipX, void 0, false)) sprite.flipX.setAt(id(), $$props.flipX);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.flipY, void 0, false)) sprite.flipY.setAt(id(), $$props.flipY);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.frameId, void 0, false)) sprite.frame.setAt(id(), $$props.frameId, $$props.animationName);
  });
  var $$exports = { ...legacy_api() };
  return pop($$exports);
}
if (import.meta.hot) {
  SpriteInstance = hmr(SpriteInstance);
  import.meta.hot.accept((module) => {
    SpriteInstance[HMR].update(module.default);
  });
}
var SpriteInstance_default = SpriteInstance;

// node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte
InstancedSprite[FILENAME] = "node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte";
function InstancedSprite($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedSprite);
  var $$ownership_validator = create_ownership_validator($$props);
  let autoUpdate = prop($$props, "autoUpdate", 3, true), baseMaterial = prop($$props, "baseMaterial", 3, MeshBasicMaterial7), fps = prop($$props, "fps", 3, 15), playmode = prop($$props, "playmode", 3, "FORWARD"), count = prop($$props, "count", 3, 1e3), alphaTest = prop($$props, "alphaTest", 3, 0.1), transparent = prop($$props, "transparent", 3, true), randomPlaybackOffset = prop($$props, "randomPlaybackOffset", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoUpdate",
      "baseMaterial",
      "fps",
      "billboarding",
      "playmode",
      "count",
      "alphaTest",
      "transparent",
      "hueShift",
      "randomPlaybackOffset",
      "spritesheet",
      "ref",
      "children"
    ],
    "props"
  );
  const spriteBaseMaterial = new (baseMaterial())({
    transparent: transparent(),
    alphaTest: alphaTest(),
    // needs to be double side for shading
    side: DoubleSide10
  });
  const { renderer } = useThrelte();
  const mesh = new Xt2(spriteBaseMaterial, count(), renderer);
  const animationMap = writable(/* @__PURE__ */ new Map());
  user_pre_effect(() => {
    if ($$props.spritesheet) {
      mesh.spritesheet = $$props.spritesheet.spritesheet;
      animationMap.set(mesh.animationMap);
      mesh.material.map = $$props.spritesheet.texture;
      mesh.material.needsUpdate = true;
    }
  });
  user_pre_effect(() => {
    mesh.material.alphaTest = alphaTest();
  });
  user_pre_effect(() => {
    mesh.material.transparent = transparent();
  });
  user_pre_effect(() => {
    mesh.fps = fps();
  });
  user_pre_effect(() => mesh.hueShift.setGlobal($$props.hueShift));
  user_pre_effect(() => {
    if (strict_equals($$props.billboarding, void 0)) {
      mesh.billboarding.unsetAll();
      return;
    } else {
      mesh.billboarding.setAll($$props.billboarding);
    }
  });
  user_pre_effect(() => {
    if (strict_equals(playmode(), void 0)) {
      mesh.playmode.setAll("PAUSE");
      return;
    } else {
      mesh.playmode.setAll(playmode());
    }
  });
  let previousRndOffset = tag(state(false), "previousRndOffset");
  user_pre_effect(() => {
    if (strict_equals(get(previousRndOffset), false) && randomPlaybackOffset()) {
      mesh.offset.randomizeAll(strict_equals(randomPlaybackOffset(), true) ? 100 : randomPlaybackOffset());
    }
    if (strict_equals(get(previousRndOffset), true) && !randomPlaybackOffset()) {
      for (let i = 0; i < count(); i++) {
        mesh.offset.setAt(i, 0);
      }
    }
    set(previousRndOffset, randomPlaybackOffset() ? true : false, true);
  });
  let instanceMatrixNeedsUpdate = false;
  const tempMatrix3 = new Matrix420();
  const updatePosition = (id, position2, scale = [1, 1]) => {
    tempMatrix3.makeScale(scale[0], scale[1], 1);
    tempMatrix3.setPosition(...position2);
    mesh.setMatrixAt(id, tempMatrix3);
    instanceMatrixNeedsUpdate = true;
  };
  setContext("instanced-sprite-ctx", { sprite: mesh, count: count(), animationMap, updatePosition });
  useTask(() => {
    if (autoUpdate()) {
      mesh.update();
    }
    if (instanceMatrixNeedsUpdate) {
      mesh.instanceMatrix.needsUpdate = true;
      instanceMatrixNeedsUpdate = false;
    }
  });
  mesh.update();
  var $$exports = { ...legacy_api() };
  var fragment2 = comment();
  var node = first_child(fragment2);
  {
    $$ownership_validator.binding("ref", T, ref);
    add_svelte_meta(
      () => T(node, spread_props(
        {
          get is() {
            return mesh;
          },
          frustumCulled: false
        },
        () => props,
        {
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(InstancedSprite, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ Instance: SpriteInstance_default })), "render", InstancedSprite, 142, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      InstancedSprite,
      136,
      0,
      { componentTag: "T" }
    );
  }
  append($$anchor, fragment2);
  return pop($$exports);
}
if (import.meta.hot) {
  InstancedSprite = hmr(InstancedSprite);
  import.meta.hot.accept((module) => {
    InstancedSprite[HMR].update(module.default);
  });
}
var InstancedSprite_default = InstancedSprite;

// node_modules/@threlte/extras/dist/components/InstancedSprite/instancedSpriteUtils.js
import { NearestFilter as NearestFilter4, RepeatWrapping as RepeatWrapping2, SRGBColorSpace, TextureLoader as TextureLoader3 } from "three";
var useInstancedSprite = () => {
  return getContext("instanced-sprite-ctx");
};
var from = (meta) => {
  const builder = Jt2();
  const animationsList = [];
  for (const { url, type, width: width2, height: height2, animations } of meta) {
    for (const animation of animations) {
      animationsList.push(animation.name);
    }
    builder.add(url, {
      type,
      width: width2,
      height: height2
    }, animations);
  }
  const spritesheet = builder.build();
  const typedHook = useInstancedSprite;
  return { spritesheet, useInstancedSprite: typedHook };
};
var fromAseprite = (asepriteDataUrl, spriteImageUrl) => {
  const texture = new TextureLoader3().load(spriteImageUrl, (t) => {
    t.matrixAutoUpdate = false;
    t.generateMipmaps = false;
    t.premultiplyAlpha = false;
    t.wrapS = texture.wrapT = RepeatWrapping2;
    t.magFilter = texture.minFilter = NearestFilter4;
    t.colorSpace = SRGBColorSpace;
    t.needsUpdate = true;
  });
  const parse = async () => {
    const res = await fetch(asepriteDataUrl);
    const json = await res.json();
    return { spritesheet: Yt2(json), texture };
  };
  return parse();
};
var buildSpritesheet = { from, fromAseprite };

// node_modules/@threlte/extras/dist/bvh/raycast.js
import { Points as Points2, Mesh as Mesh14, Vector3 as Vector327, Matrix4 as Matrix421, Ray as Ray3, Sphere as Sphere6, Box3 as Box312, BufferGeometry as BufferGeometry8, BufferAttribute as BufferAttribute10, MeshBasicMaterial as MeshBasicMaterial8, BatchedMesh as BatchedMesh2 } from "three";
var material = new MeshBasicMaterial8();
var trianglePoint = new Vector327();
var inverseMatrix2 = new Matrix421();
var localRay = new Ray3();
var sphere2 = new Sphere6();
var expandedBox = new Box312();
var worldVertex = new Vector327();
var closestOnRay = new Vector327();
var pointsToMesh = /* @__PURE__ */ new WeakMap();
var objectToHelper = /* @__PURE__ */ new WeakMap();
var createGeometryBVH = (geometry, opts) => {
  geometry.computeBoundsTree = computeBoundsTree;
  geometry.disposeBoundsTree = disposeBoundsTree;
  geometry.computeBoundsTree(opts);
  return () => {
    geometry.disposeBoundsTree();
  };
};
var createMeshBVH = (mesh, opts) => {
  const cleanup = createGeometryBVH(mesh.geometry, opts);
  mesh.raycast = acceleratedRaycast;
  if (opts.helper) {
    const helper = new MeshBVHHelper(mesh);
    mesh.add(helper);
    objectToHelper.set(mesh, helper);
  }
  return () => {
    cleanup();
    mesh.geometry.disposeBoundsTree();
    mesh.raycast = Mesh14.prototype.raycast;
    if (opts.helper) {
      const helper = objectToHelper.get(mesh);
      helper?.removeFromParent();
      objectToHelper.delete(mesh);
    }
  };
};
var createBatchedMeshBVH = (mesh, opts) => {
  mesh.computeBoundsTree = computeBatchedBoundsTree;
  mesh.disposeBoundsTree = disposeBatchedBoundsTree;
  mesh.addGeometry = (...args) => {
    const result = BatchedMesh2.prototype.addGeometry.call(mesh, ...args);
    mesh.computeBoundsTree(result, opts);
    return result;
  };
  if (opts.helper) {
    const helper = new MeshBVHHelper(mesh);
    mesh.add(helper);
    objectToHelper.set(mesh, helper);
  }
  return () => {
    if (mesh.boundsTrees) {
      mesh.disposeBoundsTree();
    }
    mesh.addGeometry = BatchedMesh2.prototype.addGeometry;
    mesh.raycast = BatchedMesh2.prototype.raycast;
    if (opts.helper) {
      const helper = objectToHelper.get(mesh);
      helper?.removeFromParent();
      objectToHelper.delete(mesh);
    }
  };
};
var createPointsBVH = (points, opts) => {
  const geometry = new BufferGeometry8();
  const positions = points.geometry.getAttribute("position");
  const indices = new Uint32Array(positions.count * 3);
  for (let i = 0, k3 = 0, l = positions.count; i < l; i += 1, k3 += 3) {
    indices[k3 + 0] = indices[k3 + 1] = indices[k3 + 2] = i;
  }
  geometry.setAttribute("position", positions);
  geometry.setIndex(new BufferAttribute10(indices, 1));
  const cleanup = createGeometryBVH(geometry, opts);
  const mesh = new Mesh14(geometry, material);
  mesh.visible = false;
  mesh.raycast = acceleratedRaycast;
  pointsToMesh.set(points, mesh);
  points.raycast = raycastPoints;
  if (opts.helper) {
    const helper = new MeshBVHHelper(mesh);
    objectToHelper.set(points, helper);
    points.add(helper, mesh);
  }
  return () => {
    cleanup();
    points.raycast = Points2.prototype.raycast;
    pointsToMesh.delete(points);
    if (opts.helper) {
      const helper = objectToHelper.get(points);
      helper?.removeFromParent();
      mesh.removeFromParent();
      objectToHelper.delete(points);
    }
  };
};
function raycastPoints(raycaster, intersects) {
  const mesh = pointsToMesh.get(this);
  if (!mesh) {
    return;
  }
  const { threshold } = raycaster.params.Points;
  if (this.geometry.boundingSphere === null) {
    this.geometry.computeBoundingSphere();
  }
  sphere2.copy(this.geometry.boundingSphere).applyMatrix4(this.matrixWorld);
  sphere2.radius += threshold;
  if (!raycaster.ray.intersectsSphere(sphere2)) {
    return;
  }
  const { geometry } = mesh;
  const indexArray = geometry.getIndex().array;
  const positionArray = geometry.getAttribute("position").array;
  const worldScale = this.matrixWorld.getMaxScaleOnAxis();
  const localThreshold = threshold / worldScale;
  const localThresholdSq = localThreshold * localThreshold;
  const firstHitOnly = raycaster.firstHitOnly === true;
  let closestDistance = Number.POSITIVE_INFINITY;
  inverseMatrix2.copy(this.matrixWorld).invert();
  localRay.copy(raycaster.ray).applyMatrix4(inverseMatrix2);
  geometry.boundsTree?.shapecast({
    // Disable sorting when we don't prune, it just adds overhead
    boundsTraverseOrder: firstHitOnly ? (box) => box.distanceToPoint(localRay.origin) : void 0,
    intersectsBounds: (box, _isLeaf, score) => {
      if (score !== void 0 && score > closestDistance) {
        return NOT_INTERSECTED;
      }
      const expanded = expandedBox.copy(box).expandByScalar(localThreshold);
      return localRay.intersectsBox(expanded) ? INTERSECTED : NOT_INTERSECTED;
    },
    intersectsRange: (offset, count) => {
      const end2 = offset + count;
      for (let tri = offset; tri < end2; tri++) {
        const resolvedTri = geometry.boundsTree?.resolveTriangleIndex?.(tri) ?? tri;
        const index = indexArray[3 * resolvedTri];
        const px = positionArray[3 * index];
        const py = positionArray[3 * index + 1];
        const pz = positionArray[3 * index + 2];
        trianglePoint.set(px, py, pz);
        const d2 = localRay.distanceSqToPoint(trianglePoint);
        if (d2 > localThresholdSq) {
          continue;
        }
        if (firstHitOnly) {
          const localDist = localRay.origin.distanceTo(trianglePoint);
          if (localDist >= closestDistance) {
            continue;
          }
          closestDistance = localDist;
        }
        worldVertex.copy(trianglePoint).applyMatrix4(this.matrixWorld);
        const pointOnRay = raycaster.ray.closestPointToPoint(worldVertex, closestOnRay);
        const distance = raycaster.ray.origin.distanceTo(pointOnRay);
        if (distance < raycaster.near || distance > raycaster.far) {
          if (!firstHitOnly) {
            continue;
          }
          return false;
        }
        const distanceToRay = Math.sqrt(raycaster.ray.distanceSqToPoint(worldVertex));
        intersects.push({
          distance,
          distanceToRay,
          point: pointOnRay.clone(),
          index,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: this
        });
        if (firstHitOnly) {
          return true;
        }
      }
      return false;
    }
  });
}

// node_modules/@threlte/extras/dist/bvh/bvh.svelte.js
var bvh = (options) => {
  const bvhOptions = tag(
    user_derived(() => ({
      helper: false,
      enabled: true,
      strategy: SAH,
      verbose: false,
      setBoundingBox: true,
      maxDepth: 20,
      maxLeafTris: 10,
      indirect: false,
      ...options?.()
    })),
    "bvhOptions"
  );
  injectPlugin("bvh-raycast", (pluginProps) => {
    const ref = tag(user_derived(() => pluginProps.ref), "ref");
    const opts = tag(
      user_derived(() => pluginProps.props.bvh ? { ...get(bvhOptions), ...pluginProps.props.bvh } : get(bvhOptions)),
      "opts"
    );
    user_effect(() => {
      if (!get(opts).enabled) {
        return;
      }
      if (isInstanceOf(get(ref), "Mesh")) {
        return createMeshBVH(get(ref), get(opts));
      } else if (isInstanceOf(get(ref), "BatchedMesh")) {
        return createBatchedMeshBVH(get(ref), get(opts));
      } else if (isInstanceOf(get(ref), "Points")) {
        return createPointsBVH(get(ref), get(opts));
      }
      return;
    });
  });
};

// node_modules/@threlte/extras/dist/index.js
var BVHSplitStrategy = { SAH, CENTER, AVERAGE };
export {
  Align_default as Align,
  AnimatedSpriteMaterial_default as AnimatedSpriteMaterial,
  AsciiRenderer_default as AsciiRenderer,
  Audio_default as Audio,
  AudioListener_default as AudioListener,
  BVHSplitStrategy,
  BakeShadows_default as BakeShadows,
  Billboard_default as Billboard,
  CSM_default as CSM,
  CameraControls_default as CameraControls,
  ContactShadows_default as ContactShadows,
  CubeCamera_default as CubeCamera,
  CubeEnvironment_default as CubeEnvironment,
  Decal_default as Decal,
  Detailed_default as Detailed,
  Edges_default as Edges,
  Environment_default as Environment,
  FakeGlowMaterial_default as FakeGlowMaterial,
  Float_default as Float,
  GLTF_default as GLTF,
  Gizmo_default as Gizmo,
  Grid_default as Grid,
  HTML_default as HTML,
  HUD_default as HUD,
  ImageMaterial_default as ImageMaterial,
  Instance_default as Instance,
  InstancedMesh_default as InstancedMesh,
  InstancedMeshes_default as InstancedMeshes,
  InstancedSprite_default as InstancedSprite,
  LinearGradientTexture_default as LinearGradientTexture,
  Mask_default as Mask,
  MeshDiscardMaterial_default as MeshDiscardMaterial,
  MeshLineGeometry_default as MeshLineGeometry,
  MeshLineMaterial_default as MeshLineMaterial,
  MeshRefractionMaterial_default as MeshRefractionMaterial,
  OrbitControls_default as OrbitControls,
  Outlines_default as Outlines,
  PerfMonitor_default as PerfMonitor,
  PointsMaterial_default as PointsMaterial,
  Portal_default as Portal,
  PortalTarget_default as PortalTarget,
  PositionalAudio_default as PositionalAudio,
  RadialGradientTexture_default as RadialGradientTexture,
  Resize_default as Resize,
  RoundedBoxGeometry_default as RoundedBoxGeometry,
  Svg_default as SVG,
  ShadowMaterial_default as ShadowMaterial,
  Sky_default as Sky,
  SoftShadows_default as SoftShadows,
  Stars_default as Stars,
  Suspense_default as Suspense,
  Text_default as Text,
  Text3DGeometry_default as Text3DGeometry,
  TrackballControls_default as TrackballControls,
  TransformControls_default as TransformControls,
  UvMaterial_default as UvMaterial,
  View_default as View,
  VirtualEnvironment_default as VirtualEnvironment,
  Wireframe_default as Wireframe,
  buildSpritesheet,
  bvh,
  createTransition,
  global,
  interactivity,
  layers,
  meshBounds,
  onReveal,
  onSuspend,
  transitions,
  useAudioListener,
  useCursor,
  useDraco,
  useFBO,
  useGamepad,
  useGltf,
  useGltfAnimations,
  useInstancedSprite,
  useInteractivity,
  useKtx2,
  useMask,
  useMeshopt,
  useProgress,
  useSuspense,
  useTexture,
  useThrelteAudio,
  useViewport
};
//# sourceMappingURL=@threlte_extras.js.map
