import {
  fromStore
} from "./chunk-3BOHHH7U.js";
import {
  add_locations,
  append_styles,
  bind_this,
  check_target,
  cleanup_styles,
  derived,
  hmr,
  if_block,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  readable,
  rest_props,
  snippet,
  spread_props,
  wrap_snippet,
  writable
} from "./chunk-4FYCS6M2.js";
import {
  append,
  comment,
  from_html
} from "./chunk-LAD4FKZX.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  first_child,
  get,
  getContext,
  noop,
  pop,
  push,
  reset,
  set,
  setContext,
  state,
  strict_equals,
  tag,
  tick,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-3MKV6OMX.js";

// node_modules/@threlte/core/dist/context/fragments/cache.js
var shallowEqualArrays = (arrA, arrB) => {
  if (arrA === arrB)
    return true;
  if (!arrA || !arrB)
    return false;
  const len = arrA.length;
  if (arrB.length !== len)
    return false;
  for (let i = 0; i < len; i++)
    if (arrA[i] !== arrB[i])
      return false;
  return true;
};
var createCacheContext = () => {
  const items = [];
  const remember = (callback, keys) => {
    for (let i = 0; i < items.length; i++) {
      const entry2 = items[i];
      if (shallowEqualArrays(keys, entry2.keys)) {
        if (entry2.promise)
          return entry2.promise;
      }
    }
    const entry = {
      promise: callback(),
      keys
    };
    items.push(entry);
    return entry.promise;
  };
  const clear = (keys) => {
    for (let i = 0; i < items.length; i++) {
      const entry = items[i];
      if (shallowEqualArrays(keys, entry.keys)) {
        items.splice(i, 1);
        return;
      }
    }
  };
  const context = { items, remember, clear };
  setContext("threlte-cache", context);
  return context;
};
var useCache = () => {
  const cache = getContext("threlte-cache");
  if (!cache) {
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  }
  return cache;
};

// node_modules/@threlte/core/dist/context/fragments/camera.js
import { PerspectiveCamera } from "three";

// node_modules/@threlte/core/dist/utilities/observe.svelte.js
var signal = /* @__PURE__ */ Symbol();
var isStore = (dep) => {
  return strict_equals(typeof dep?.subscribe, "function");
};
var runObserve = (dependencies, callback, pre) => {
  const stores = dependencies().map((d) => {
    if (isStore(d)) {
      return fromStore(d);
    }
    return signal;
  });
  const deps = tag(
    user_derived(() => dependencies().map((d, i) => {
      if (strict_equals(stores[i], signal)) return d;
      return stores[i].current;
    })),
    "deps"
  );
  const effect = () => {
    get(deps);
    let cleanup = void 0;
    untrack(() => {
      cleanup = callback(get(deps));
    });
    return cleanup;
  };
  if (pre) {
    user_pre_effect(effect);
  } else {
    user_effect(effect);
  }
};
var observePost = (dependencies, callback) => {
  return runObserve(dependencies, callback, false);
};
var observePre = (dependencies, callback) => {
  return runObserve(dependencies, callback, true);
};
var observe = Object.assign(observePost, { pre: observePre });

// node_modules/@threlte/core/dist/utilities/isInstanceOf.js
var isInstanceOf = (obj, type) => {
  return obj?.[`is${type}`] === true;
};

// node_modules/@threlte/core/dist/utilities/asyncWritable.js
var asyncWritable = (promise) => {
  const store = writable(void 0);
  const error = writable(void 0);
  promise.then((result) => {
    store.set(result);
  }).catch((e) => {
    console.error("Error in asyncWritable:", e.message);
    error.set(e);
  });
  return Object.assign(Object.assign(promise, store), { error, promise });
};

// node_modules/@threlte/core/dist/utilities/browser.js
var browser = typeof window !== "undefined";

// node_modules/@threlte/core/dist/utilities/revision.js
import { REVISION } from "three";
var normalizedRevision = REVISION.replace("dev", "");
var revision = Number.parseInt(normalizedRevision);

// node_modules/@threlte/core/dist/utilities/watch.js
var watch = (stores, callback) => {
  const d = derived(stores, (values) => {
    return values;
  });
  let cleanupFn;
  const unsubscribe = d.subscribe(async (values) => {
    if (cleanupFn)
      cleanupFn();
    const fn = await callback(values);
    if (fn)
      cleanupFn = fn;
  });
  onDestroy(() => {
    unsubscribe();
    if (cleanupFn)
      cleanupFn();
  });
};

// node_modules/@threlte/core/dist/utilities/currentWritable.js
var currentWritable = (value) => {
  const store = writable(value);
  const extendedWritable = {
    set: (value2) => {
      extendedWritable.current = value2;
      store.set(value2);
    },
    subscribe: store.subscribe,
    update: (fn) => {
      const newValue = fn(extendedWritable.current);
      extendedWritable.current = newValue;
      store.set(newValue);
    },
    current: value
  };
  return extendedWritable;
};
var toCurrentReadable = (store) => {
  return {
    subscribe: store.subscribe,
    get current() {
      return store.current;
    }
  };
};

// node_modules/@threlte/core/dist/utilities/resolvePropertyPath.js
var resolvePropertyPath = (target, propertyPath) => {
  if (propertyPath.includes(".")) {
    const path = propertyPath.split(".");
    const key = path.pop();
    for (let i = 0; i < path.length; i += 1) {
      target = target[path[i]];
    }
    return {
      target,
      key
    };
  } else {
    return {
      target,
      key: propertyPath
    };
  }
};

// node_modules/@threlte/core/dist/context/fragments/dom.js
var createDOMContext = (options) => {
  const { dom, canvas } = options;
  const size = currentWritable({ width: dom.offsetWidth, height: dom.offsetHeight });
  onMount(() => {
    const resizeObserver = new ResizeObserver(() => {
      const { offsetWidth, offsetHeight } = dom;
      if (size.current.width !== offsetWidth || size.current.height !== offsetHeight) {
        size.set({ width: offsetWidth, height: offsetHeight });
      }
    });
    resizeObserver.observe(dom);
    return () => {
      resizeObserver.disconnect();
    };
  });
  const context = {
    dom,
    canvas,
    size: toCurrentReadable(size)
  };
  setContext("threlte-dom-context", context);
  return context;
};
var useDOM = () => {
  const context = getContext("threlte-dom-context");
  if (!context) {
    throw new Error("useDOM can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// node_modules/@threlte/core/dist/frame-scheduling/DAG.js
var DAG = class {
  allVertices = {};
  /** Nodes that are fully unlinked */
  isolatedVertices = {};
  connectedVertices = {};
  sortedConnectedValues = [];
  needsSort = false;
  emitter = mitt_default();
  emit = this.emitter.emit.bind(this.emitter);
  on = this.emitter.on.bind(this.emitter);
  off = this.emitter.off.bind(this.emitter);
  get sortedVertices() {
    return this.mapNodes((value) => value);
  }
  moveToIsolated(key) {
    const vertex = this.connectedVertices[key];
    if (!vertex)
      return;
    this.isolatedVertices[key] = vertex;
    delete this.connectedVertices[key];
  }
  moveToConnected(key) {
    const vertex = this.isolatedVertices[key];
    if (!vertex)
      return;
    this.connectedVertices[key] = vertex;
    delete this.isolatedVertices[key];
  }
  getKey = (v) => {
    if (typeof v === "object") {
      return v.key;
    }
    return v;
  };
  add(key, value, options) {
    if (this.allVertices[key] && this.allVertices[key].value !== void 0) {
      throw new Error(`A node with the key ${key.toString()} already exists`);
    }
    let vertex = this.allVertices[key];
    if (!vertex) {
      vertex = {
        value,
        previous: /* @__PURE__ */ new Set(),
        next: /* @__PURE__ */ new Set()
      };
      this.allVertices[key] = vertex;
    } else if (vertex.value === void 0) {
      vertex.value = value;
    }
    const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;
    if (!options?.after && !options?.before && !hasEdges) {
      this.isolatedVertices[key] = vertex;
      this.emit("node:added", {
        key,
        type: "isolated",
        value
      });
      return;
    } else {
      this.connectedVertices[key] = vertex;
    }
    if (options?.after) {
      const afterArr = Array.isArray(options.after) ? options.after : [options.after];
      afterArr.forEach((after) => {
        vertex.previous.add(this.getKey(after));
      });
      afterArr.forEach((after) => {
        const afterKey = this.getKey(after);
        const linkedAfter = this.allVertices[afterKey];
        if (!linkedAfter) {
          this.allVertices[afterKey] = {
            value: void 0,
            // uninitialized
            previous: /* @__PURE__ */ new Set(),
            next: /* @__PURE__ */ new Set([key])
          };
          this.connectedVertices[afterKey] = this.allVertices[afterKey];
        } else {
          linkedAfter.next.add(key);
          this.moveToConnected(afterKey);
        }
      });
    }
    if (options?.before) {
      const beforeArr = Array.isArray(options.before) ? options.before : [options.before];
      beforeArr.forEach((before) => {
        vertex.next.add(this.getKey(before));
      });
      beforeArr.forEach((before) => {
        const beforeKey = this.getKey(before);
        const linkedBefore = this.allVertices[beforeKey];
        if (!linkedBefore) {
          this.allVertices[beforeKey] = {
            value: void 0,
            // uninitialized
            previous: /* @__PURE__ */ new Set([key]),
            next: /* @__PURE__ */ new Set()
          };
          this.connectedVertices[beforeKey] = this.allVertices[beforeKey];
        } else {
          linkedBefore.previous.add(key);
          this.moveToConnected(beforeKey);
        }
      });
    }
    this.emit("node:added", {
      key,
      type: "connected",
      value
    });
    this.needsSort = true;
  }
  remove(key) {
    const removeKey = this.getKey(key);
    const unlinkedVertex = this.isolatedVertices[removeKey];
    if (unlinkedVertex) {
      delete this.isolatedVertices[removeKey];
      delete this.allVertices[removeKey];
      this.emit("node:removed", {
        key: removeKey,
        type: "isolated"
      });
      return;
    }
    const linkedVertex = this.connectedVertices[removeKey];
    if (!linkedVertex) {
      return;
    }
    linkedVertex.next.forEach((nextKey) => {
      const nextVertex = this.connectedVertices[nextKey];
      if (nextVertex) {
        nextVertex.previous.delete(removeKey);
        if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {
          this.moveToIsolated(nextKey);
        }
      }
    });
    linkedVertex.previous.forEach((prevKey) => {
      const prevVertex = this.connectedVertices[prevKey];
      if (prevVertex) {
        prevVertex.next.delete(removeKey);
        if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {
          this.moveToIsolated(prevKey);
        }
      }
    });
    delete this.connectedVertices[removeKey];
    delete this.allVertices[removeKey];
    this.emit("node:removed", {
      key: removeKey,
      type: "connected"
    });
    this.needsSort = true;
  }
  mapNodes(callback) {
    if (this.needsSort) {
      this.sort();
    }
    const result = [];
    this.forEachNode((value, index) => {
      result.push(callback(value, index));
    });
    return result;
  }
  forEachNode(callback) {
    if (this.needsSort) {
      this.sort();
    }
    let index = 0;
    for (; index < this.sortedConnectedValues.length; index++) {
      callback(this.sortedConnectedValues[index], index);
    }
    Reflect.ownKeys(this.isolatedVertices).forEach((key) => {
      const vertex = this.isolatedVertices[key];
      if (vertex.value !== void 0)
        callback(vertex.value, index++);
    });
  }
  getValueByKey(key) {
    return this.allVertices[key]?.value;
  }
  getKeyByValue(value) {
    return Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ?? Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value);
  }
  sort() {
    const inDegree = /* @__PURE__ */ new Map();
    const zeroInDegreeQueue = [];
    const result = [];
    const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {
      const vertex = this.connectedVertices[key];
      return vertex.value !== void 0;
    });
    connectedVertexKeysWithValues.forEach((vertex) => {
      inDegree.set(vertex, 0);
    });
    connectedVertexKeysWithValues.forEach((vertexKey) => {
      const vertex = this.connectedVertices[vertexKey];
      vertex.next.forEach((next) => {
        const nextVertex = this.connectedVertices[next];
        if (!nextVertex)
          return;
        inDegree.set(next, (inDegree.get(next) || 0) + 1);
      });
    });
    inDegree.forEach((degree, value) => {
      if (degree === 0) {
        zeroInDegreeQueue.push(value);
      }
    });
    while (zeroInDegreeQueue.length > 0) {
      const vertexKey = zeroInDegreeQueue.shift();
      result.push(vertexKey);
      const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);
      if (v) {
        this.connectedVertices[v]?.next.forEach((adjVertex) => {
          const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;
          inDegree.set(adjVertex, adjVertexInDegree);
          if (adjVertexInDegree === 0) {
            zeroInDegreeQueue.push(adjVertex);
          }
        });
      }
    }
    if (result.length !== connectedVertexKeysWithValues.length) {
      throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");
    }
    const filterUndefined = (value) => value !== void 0;
    this.sortedConnectedValues = result.map((key) => this.connectedVertices[key].value).filter(filterUndefined);
    this.needsSort = false;
  }
  clear() {
    this.allVertices = {};
    this.isolatedVertices = {};
    this.connectedVertices = {};
    this.sortedConnectedValues = [];
    this.needsSort = false;
  }
  static isKey(value) {
    return typeof value === "string" || typeof value === "symbol";
  }
  static isValue(value) {
    return typeof value === "object" && "key" in value;
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Task.js
var Task = class {
  key;
  stage;
  callback;
  runTask = true;
  stop() {
    this.runTask = false;
  }
  start() {
    this.runTask = true;
  }
  constructor(stage, key, callback) {
    this.stage = stage;
    this.key = key;
    this.callback = callback;
  }
  run(delta) {
    if (!this.runTask)
      return;
    this.callback(delta);
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Stage.js
var Stage = class extends DAG {
  key;
  scheduler;
  runTask = true;
  stop() {
    this.runTask = false;
  }
  start() {
    this.runTask = true;
  }
  get tasks() {
    return this.sortedVertices;
  }
  callback = (_, r) => r();
  constructor(scheduler, key, callback) {
    super();
    this.scheduler = scheduler;
    this.key = key;
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    if (callback)
      this.callback = callback.bind(this);
  }
  createTask(key, callback, options) {
    const task = new Task(this, key, callback);
    this.add(key, task, options);
    return task;
  }
  getTask(key) {
    return this.getValueByKey(key);
  }
  removeTask = this.remove.bind(this);
  run(delta) {
    if (!this.runTask)
      return;
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        task.run(deltaOverride ?? delta);
      });
    });
  }
  runWithTiming(delta) {
    if (!this.runTask)
      return {};
    const taskTimings = {};
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        const start = performance.now();
        task.run(deltaOverride ?? delta);
        const duration = performance.now() - start;
        taskTimings[task.key] = duration;
      });
    });
    return taskTimings;
  }
  getSchedule() {
    return this.mapNodes((l) => l.key.toString());
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Scheduler.js
var Scheduler = class extends DAG {
  lastTime = performance.now();
  clampDeltaTo = 0.1;
  get stages() {
    return this.sortedVertices;
  }
  constructor(options) {
    super();
    if (options?.clampDeltaTo)
      this.clampDeltaTo = options.clampDeltaTo;
    this.run = this.run.bind(this);
  }
  createStage(key, options) {
    const stage = new Stage(this, key, options?.callback);
    this.add(key, stage, {
      after: options?.after,
      before: options?.before
    });
    return stage;
  }
  getStage(key) {
    return this.getValueByKey(key);
  }
  removeStage = this.remove.bind(this);
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(time) {
    const delta = time - this.lastTime;
    this.forEachNode((stage) => {
      stage.run(Math.min(delta / 1e3, this.clampDeltaTo));
    });
    this.lastTime = time;
  }
  runWithTiming(time) {
    const delta = time - this.lastTime;
    const stageTimings = {};
    const start = performance.now();
    this.forEachNode((stage) => {
      const start2 = performance.now();
      const taskTimings = stage.runWithTiming(Math.min(delta / 1e3, this.clampDeltaTo));
      const duration = performance.now() - start2;
      stageTimings[stage.key.toString()] = {
        duration,
        tasks: taskTimings
      };
    });
    return {
      total: performance.now() - start,
      stages: stageTimings
    };
  }
  getSchedule(include = {
    tasks: true
  }) {
    return {
      stages: this.mapNodes((stage) => {
        if (stage === void 0)
          throw new Error("Stage not found");
        return {
          key: stage.key.toString(),
          ...{ tasks: include.tasks ? stage.getSchedule() : void 0 }
        };
      })
    };
  }
  dispose() {
    this.clear();
  }
};

// node_modules/@threlte/core/dist/context/fragments/scheduler.svelte.js
var createSchedulerContext = (options) => {
  const scheduler = new Scheduler();
  const mainStage = scheduler.createStage(/* @__PURE__ */ Symbol("threlte-main-stage"));
  const context = {
    scheduler,
    frameInvalidated: true,
    autoInvalidations: /* @__PURE__ */ new Set(),
    shouldAdvance: false,
    advance: () => {
      context.shouldAdvance = true;
    },
    autoRender: currentWritable(options.autoRender ?? true),
    renderMode: currentWritable(options.renderMode ?? "on-demand"),
    invalidate() {
      context.frameInvalidated = true;
    },
    mainStage,
    shouldRender: () => {
      return strict_equals(context.renderMode.current, "always") || strict_equals(context.renderMode.current, "on-demand") && (context.frameInvalidated || context.autoInvalidations.size > 0) || strict_equals(context.renderMode.current, "manual") && context.shouldAdvance;
    },
    renderStage: scheduler.createStage(/* @__PURE__ */ Symbol("threlte-render-stage"), {
      after: mainStage,
      callback(_, runTasks) {
        if (context.shouldRender()) runTasks();
      }
    }),
    resetFrameInvalidation() {
      context.frameInvalidated = false;
      context.shouldAdvance = false;
    }
  };
  user_effect(() => {
    context.autoRender.set(options.autoRender ?? true);
  });
  user_effect(() => {
    context.renderMode.set(options.renderMode ?? "on-demand");
  });
  onDestroy(() => {
    context.scheduler.dispose();
  });
  setContext("threlte-scheduler-context", context);
  return context;
};
var useScheduler = () => {
  const context = getContext("threlte-scheduler-context");
  if (!context) {
    throw new Error("useScheduler can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/camera.js
var createCameraContext = () => {
  const { size } = useDOM();
  const { invalidate } = useScheduler();
  const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
  defaultCamera.position.z = 5;
  defaultCamera.lookAt(0, 0, 0);
  const camera = currentWritable(defaultCamera);
  watch(size, (size2) => {
    if (camera.current === defaultCamera) {
      const cam = camera.current;
      cam.aspect = size2.width / size2.height;
      cam.updateProjectionMatrix();
      invalidate();
    }
  });
  watch(camera, ($camera) => {
    if ($camera === void 0) {
      camera.set(defaultCamera);
    }
  });
  const context = { camera };
  setContext("threlte-camera-context", context);
  return context;
};
var useCamera = () => {
  const context = getContext("threlte-camera-context");
  if (!context) {
    throw new Error("useCamera can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/disposal.js
var createDisposalContext = () => {
  const context = {
    removeObjectFromDisposal: (object) => {
      context.disposableObjects.delete(object);
    },
    disposableObjectMounted: (object) => {
      const currentValue = context.disposableObjects.get(object);
      if (currentValue) {
        context.disposableObjects.set(object, currentValue + 1);
      } else {
        context.disposableObjects.set(object, 1);
      }
    },
    disposableObjectUnmounted: (object) => {
      const currentValue = context.disposableObjects.get(object);
      if (currentValue && currentValue > 0) {
        context.disposableObjects.set(object, currentValue - 1);
        if (currentValue - 1 <= 0) {
          context.shouldDispose = true;
        }
      }
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: false,
    dispose: async (force = false) => {
      await tick();
      if (!context.shouldDispose && !force)
        return;
      context.disposableObjects.forEach((mounted, object) => {
        if (mounted === 0 || force) {
          object?.dispose?.();
          context.disposableObjects.delete(object);
        }
      });
      context.shouldDispose = false;
    }
  };
  onDestroy(() => {
    context.dispose(true);
  });
  setContext("threlte-disposal-context", context);
  return context;
};
var useDisposal = () => {
  const context = getContext("threlte-disposal-context");
  if (!context) {
    throw new Error("useDisposal can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/parent.js
var parentContextKey = /* @__PURE__ */ Symbol("threlte-parent-context");
var createParentContext = (parent) => {
  const ctx = currentWritable(parent);
  setContext(parentContextKey, ctx);
  return ctx;
};
var useParent = () => {
  const parent = getContext(parentContextKey);
  return parent;
};

// node_modules/@threlte/core/dist/context/fragments/parentObject3D.js
var parentObject3DContextKey = /* @__PURE__ */ Symbol("threlte-parent-object3d-context");
var createRootParentObject3DContext = (object) => {
  const ctx = readable(object);
  setContext(parentObject3DContextKey, ctx);
  return ctx;
};
var createParentObject3DContext = (object) => {
  const parentObject3D = getContext(parentObject3DContextKey);
  const object3D = writable(object);
  const ctx = derived([object3D, parentObject3D], ([object3D2, parentObject3D2]) => {
    return object3D2 ?? parentObject3D2;
  });
  setContext(parentObject3DContextKey, ctx);
  return object3D;
};
var useParentObject3D = () => {
  return getContext(parentObject3DContextKey);
};

// node_modules/@threlte/core/dist/context/fragments/renderer.svelte.js
import {
  AgXToneMapping,
  ColorManagement,
  PCFSoftShadowMap,
  WebGLRenderer
} from "three";

// node_modules/@threlte/core/dist/hooks/useTask.js
function useTask(keyOrFn, fnOrOptions, options) {
  if (!browser) {
    return {
      task: void 0,
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  let key;
  let fn;
  let opts;
  if (DAG.isKey(keyOrFn)) {
    key = keyOrFn;
    fn = fnOrOptions;
    opts = options;
  } else {
    key = /* @__PURE__ */ Symbol("useTask");
    fn = keyOrFn;
    opts = fnOrOptions;
  }
  const schedulerCtx = useScheduler();
  let stage = schedulerCtx.mainStage;
  if (opts) {
    if (opts.stage) {
      if (DAG.isValue(opts.stage)) {
        stage = opts.stage;
      } else {
        const maybeStage = schedulerCtx.scheduler.getStage(opts.stage);
        if (!maybeStage) {
          throw new Error(`No stage found with key ${opts.stage.toString()}`);
        }
        stage = maybeStage;
      }
    } else if (opts.after) {
      if (Array.isArray(opts.after)) {
        for (let index = 0; index < opts.after.length; index++) {
          const element = opts.after[index];
          if (DAG.isValue(element)) {
            stage = element.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.after)) {
        stage = opts.after.stage;
      }
    } else if (opts.before) {
      if (Array.isArray(opts.before)) {
        for (let index = 0; index < opts.before.length; index++) {
          const element = opts.before[index];
          if (DAG.isValue(element)) {
            stage = element.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.before)) {
        stage = opts.before.stage;
      }
    }
  }
  const started = writable(false);
  const task = stage.createTask(key, fn, opts);
  const start = () => {
    started.set(true);
    if (opts?.autoInvalidate ?? true) {
      schedulerCtx.autoInvalidations.add(fn);
    }
    task.start();
  };
  const stop = () => {
    started.set(false);
    if (opts?.autoInvalidate ?? true) {
      schedulerCtx.autoInvalidations.delete(fn);
    }
    task.stop();
  };
  if (opts?.autoStart ?? true) {
    start();
  } else {
    stop();
  }
  onDestroy(() => {
    stop();
    stage.removeTask(key);
  });
  return {
    task,
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
}

// node_modules/@threlte/core/dist/context/fragments/scene.js
import { Scene } from "three";
var createSceneContext = (scene) => {
  const context = { scene: scene || new Scene() };
  setContext("threlte-scene-context", context);
  return context;
};
var useScene = () => {
  const context = getContext("threlte-scene-context");
  if (!context) {
    throw new Error("useScene can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/renderer.svelte.js
var createRendererContext = (options) => {
  const { dispose } = useDisposal();
  const { camera } = useCamera();
  const { scene } = useScene();
  const {
    invalidate,
    renderStage,
    autoRender,
    scheduler,
    resetFrameInvalidation
  } = useScheduler();
  const { size, canvas } = useDOM();
  const renderer = options.createRenderer ? options.createRenderer(canvas) : new WebGLRenderer({
    canvas,
    powerPreference: "high-performance",
    antialias: true,
    alpha: true
  });
  const autoRenderTask = renderStage.createTask(/* @__PURE__ */ Symbol("threlte-auto-render-task"), () => {
    renderer.render(scene, camera.current);
  });
  const context = {
    renderer,
    colorManagementEnabled: currentWritable(options.colorManagementEnabled ?? true),
    colorSpace: currentWritable(options.colorSpace ?? "srgb"),
    dpr: currentWritable(options.dpr ?? window.devicePixelRatio),
    shadows: currentWritable(options.shadows ?? PCFSoftShadowMap),
    toneMapping: currentWritable(options.toneMapping ?? AgXToneMapping),
    autoRenderTask
  };
  setContext("threlte-renderer-context", context);
  watch([context.colorManagementEnabled], ([colorManagementEnabled]) => {
    ColorManagement.enabled = colorManagementEnabled;
  });
  watch([context.colorSpace], ([colorSpace]) => {
    if ("outputColorSpace" in renderer) {
      renderer.outputColorSpace = colorSpace;
    }
  });
  watch([context.dpr], ([dpr]) => {
    if ("setPixelRatio" in renderer) {
      renderer.setPixelRatio(dpr);
    }
  });
  const { start, stop } = useTask(
    () => {
      if (!("xr" in renderer) || renderer.xr?.isPresenting) return;
      renderer.setSize(size.current.width, size.current.height);
      invalidate();
      stop();
    },
    {
      before: autoRenderTask,
      autoStart: false,
      autoInvalidate: false
    }
  );
  watch([size], () => {
    start();
  });
  watch([context.shadows], ([shadows]) => {
    if (!("shadowMap" in renderer)) return;
    renderer.shadowMap.enabled = !!shadows;
    if (shadows && strict_equals(shadows, true, false)) {
      renderer.shadowMap.type = shadows;
    } else if (strict_equals(shadows, true)) {
      renderer.shadowMap.type = PCFSoftShadowMap;
    }
  });
  watch([context.toneMapping], ([toneMapping]) => {
    if (!("toneMapping" in renderer)) return;
    renderer.toneMapping = toneMapping;
  });
  watch([autoRender], ([autoRender2]) => {
    if (autoRender2) {
      context.autoRenderTask.start();
    } else {
      context.autoRenderTask.stop();
    }
    return () => {
      context.autoRenderTask.stop();
    };
  });
  if ("setAnimationLoop" in context.renderer) {
    const renderer2 = context.renderer;
    renderer2.setAnimationLoop((time) => {
      dispose();
      scheduler.run(time);
      resetFrameInvalidation();
    });
  }
  onDestroy(() => {
    if ("dispose" in context.renderer) {
      const dispose2 = context.renderer.dispose;
      dispose2();
    }
  });
  user_pre_effect(() => {
    context.colorManagementEnabled.set(options.colorManagementEnabled ?? true);
  });
  user_pre_effect(() => {
    context.colorSpace.set(options.colorSpace ?? "srgb");
  });
  user_pre_effect(() => {
    context.toneMapping.set(options.toneMapping ?? AgXToneMapping);
  });
  user_pre_effect(() => {
    context.shadows.set(options.shadows ?? PCFSoftShadowMap);
  });
  user_pre_effect(() => {
    context.dpr.set(options.dpr ?? window.devicePixelRatio);
  });
  return context;
};
var useRenderer = () => {
  const context = getContext("threlte-renderer-context");
  if (!context) {
    throw new Error("useRenderer can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/user.js
var createUserContext = () => {
  const userCtx = currentWritable({});
  setContext("threlte-user-context", userCtx);
  return userCtx;
};
var useUserContext = () => {
  const context = getContext("threlte-user-context");
  if (!context) {
    throw new Error("useUserContext can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/createThrelteContext.svelte.js
var createThrelteContext = (options) => {
  const { scene } = createSceneContext();
  return {
    scene,
    ...createDOMContext(options),
    ...createCacheContext(),
    ...createParentContext(scene),
    ...createRootParentObject3DContext(scene),
    ...createDisposalContext(),
    ...createSchedulerContext(options),
    ...createCameraContext(),
    ...createRendererContext(options),
    ...createUserContext()
  };
};

// node_modules/@threlte/core/dist/components/Context/Context.svelte
Context[FILENAME] = "node_modules/@threlte/core/dist/components/Context/Context.svelte";
function Context($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context);
  let rest = rest_props($$props, ["$$slots", "$$events", "$$legacy", "children"], "rest");
  createThrelteContext(rest);
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children), "render", Context, 15, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Context = hmr(Context);
  import.meta.hot.accept((module) => {
    Context[HMR].update(module.default);
  });
}
var Context_default = Context;

// node_modules/@threlte/core/dist/Canvas.svelte
Canvas[FILENAME] = "node_modules/@threlte/core/dist/Canvas.svelte";
var root = add_locations(from_html(`<div class="s-JZDOlXZiom9z"><canvas class="s-JZDOlXZiom9z"><!></canvas></div>`), Canvas[FILENAME], [[17, 0, [[18, 2]]]]);
var $$css = {
  hash: "s-JZDOlXZiom9z",
  code: "\n  div.s-JZDOlXZiom9z {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n  canvas.s-JZDOlXZiom9z {\n    display: block;\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQ2FudmFzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgdHlwZSB7IFNuaXBwZXQgfSBmcm9tICdzdmVsdGUnXG4gIGltcG9ydCBDb250ZXh0IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0L0NvbnRleHQuc3ZlbHRlJ1xuICBpbXBvcnQgdHlwZSB7IENyZWF0ZVRocmVsdGVDb250ZXh0T3B0aW9ucyB9IGZyb20gJy4vY29udGV4dC9jcmVhdGVUaHJlbHRlQ29udGV4dC5zdmVsdGUuanMnXG4gIGltcG9ydCB0eXBlIHsgUmVuZGVyZXIgfSBmcm9tICcuL2NvbnRleHQvZnJhZ21lbnRzL3JlbmRlcmVyLnN2ZWx0ZS5qcydcblxuICB0eXBlIFByb3BzID0gT21pdDxDcmVhdGVUaHJlbHRlQ29udGV4dE9wdGlvbnM8UmVuZGVyZXI+LCAnY2FudmFzJyB8ICdkb20nPiAmIHtcbiAgICBjaGlsZHJlbj86IFNuaXBwZXRcbiAgfVxuXG4gIGxldCB7IGNoaWxkcmVuLCAuLi5yZXN0IH06IFByb3BzID0gJHByb3BzKClcblxuICBsZXQgY2FudmFzID0gJHN0YXRlPEhUTUxDYW52YXNFbGVtZW50PigpXG4gIGxldCBkb20gPSAkc3RhdGU8SFRNTERpdkVsZW1lbnQ+KClcbjwvc2NyaXB0PlxuXG48ZGl2IGJpbmQ6dGhpcz17ZG9tfT5cbiAgPGNhbnZhcyBiaW5kOnRoaXM9e2NhbnZhc30+XG4gICAgeyNpZiBjYW52YXMgJiYgZG9tfVxuICAgICAgPENvbnRleHRcbiAgICAgICAge2RvbX1cbiAgICAgICAge2NhbnZhc31cbiAgICAgICAgey4uLnJlc3R9XG4gICAgICA+XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiAgICAgIDwvQ29udGV4dD5cbiAgICB7L2lmfVxuICA8L2NhbnZhcz5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIGRpdiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgfVxuXG4gIGNhbnZhcyB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function Canvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Canvas);
  append_styles($$anchor, $$css);
  let rest = rest_props($$props, ["$$slots", "$$events", "$$legacy", "children"], "rest");
  let canvas = tag(state(void 0), "canvas");
  let dom = tag(state(void 0), "dom");
  var $$exports = { ...legacy_api() };
  var div = root();
  var canvas_1 = child(div);
  var node = child(canvas_1);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      add_svelte_meta(
        () => Context_default(node_1, spread_props(
          {
            get dom() {
              return get(dom);
            },
            get canvas() {
              return get(canvas);
            }
          },
          () => rest,
          {
            children: wrap_snippet(Canvas, ($$anchor3, $$slotProps) => {
              var fragment_1 = comment();
              var node_2 = first_child(fragment_1);
              add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Canvas, 25, 8);
              append($$anchor3, fragment_1);
            }),
            $$slots: { default: true }
          }
        )),
        "component",
        Canvas,
        20,
        6,
        { componentTag: "Context" }
      );
      append($$anchor2, fragment);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(canvas) && get(dom)) $$render(consequent);
      }),
      "if",
      Canvas,
      19,
      4
    );
  }
  reset(canvas_1);
  bind_this(canvas_1, ($$value) => set(canvas, $$value), () => get(canvas));
  reset(div);
  bind_this(div, ($$value) => set(dom, $$value), () => get(dom));
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  Canvas = hmr(Canvas);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-JZDOlXZiom9z");
    Canvas[HMR].update(module.default);
  });
}
var Canvas_default = Canvas;

// node_modules/@threlte/core/dist/components/T/T.js
import * as THREE from "three";

// node_modules/@threlte/core/dist/context/compounds/useThrelte.js
import { Scene as Scene2 } from "three";
var useThrelte = () => {
  const schedulerCtx = useScheduler();
  const rendererCtx = useRenderer();
  const cameraCtx = useCamera();
  const sceneCtx = useScene();
  const domCtx = useDOM();
  const context = {
    advance: schedulerCtx.advance,
    autoRender: schedulerCtx.autoRender,
    autoRenderTask: rendererCtx.autoRenderTask,
    camera: cameraCtx.camera,
    colorManagementEnabled: rendererCtx.colorManagementEnabled,
    colorSpace: rendererCtx.colorSpace,
    dpr: rendererCtx.dpr,
    invalidate: schedulerCtx.invalidate,
    mainStage: schedulerCtx.mainStage,
    renderer: rendererCtx.renderer,
    renderMode: schedulerCtx.renderMode,
    renderStage: schedulerCtx.renderStage,
    scheduler: schedulerCtx.scheduler,
    shadows: rendererCtx.shadows,
    shouldRender: schedulerCtx.shouldRender,
    dom: domCtx.dom,
    canvas: domCtx.canvas,
    size: domCtx.size,
    toneMapping: rendererCtx.toneMapping,
    get scene() {
      return sceneCtx.scene;
    },
    set scene(scene) {
      sceneCtx.scene = scene;
    }
  };
  return context;
};

// node_modules/@threlte/core/dist/components/T/utils/useAttach.svelte.js
var isObject = (ref) => {
  return strict_equals(typeof ref, "object") && strict_equals(ref, null, false);
};
var useAttach = (getRef, getAttach) => {
  const { invalidate } = useThrelte();
  const ref = tag(user_derived(getRef), "ref");
  const attach = tag(user_derived(getAttach), "attach");
  const parent = fromStore(useParent());
  const parentObject3D = fromStore(useParentObject3D());
  const currentRef = createParentContext();
  const object3D = createParentObject3DContext();
  user_pre_effect(() => {
    currentRef.set(get(ref));
    if (isInstanceOf(get(ref), "Object3D")) {
      object3D.set(get(ref));
    }
    invalidate();
  });
  user_pre_effect(() => {
    invalidate();
    const current = get(ref);
    if (strict_equals(get(attach), void 0) && isInstanceOf(current, "Object3D")) {
      parentObject3D.current?.add(current);
      return () => {
        invalidate();
        parentObject3D.current?.remove(current);
      };
    }
    if (strict_equals(get(attach), void 0) && isObject(parent.current)) {
      const p = parent.current;
      if (isInstanceOf(current, "Material")) {
        const originalMaterial = p.material;
        p.material = current;
        return () => {
          invalidate();
          p.material = originalMaterial;
        };
      } else if (isInstanceOf(current, "BufferGeometry")) {
        const originalGeometry = p.geometry;
        p.geometry = current;
        return () => {
          invalidate();
          p.geometry = originalGeometry;
        };
      }
    }
    if (strict_equals(get(attach), false)) {
      return () => {
        invalidate();
      };
    }
    if (strict_equals(typeof get(attach), "function")) {
      const cleanup = get(attach)({
        ref: current,
        parent: parent.current,
        parentObject3D: parentObject3D.current
      });
      return () => {
        invalidate();
        cleanup?.();
      };
    }
    if (strict_equals(typeof get(attach), "string")) {
      const { target, key } = resolvePropertyPath(parent.current, get(attach));
      if (key in target) {
        const valueBeforeAttach = target[key];
        target[key] = current;
        return () => {
          invalidate();
          target[key] = valueBeforeAttach;
        };
      } else {
        target[key] = current;
        return () => {
          invalidate();
          delete target[key];
        };
      }
    }
    if (isInstanceOf(get(attach), "Object3D") && isInstanceOf(current, "Object3D")) {
      get(attach).add(current);
      return () => {
        invalidate();
        get(attach).remove(current);
      };
    }
    return;
  });
};

// node_modules/@threlte/core/dist/components/T/utils/useCamera.svelte.js
var defaultCameras = /* @__PURE__ */ new Set();
var useCamera2 = (getCamera, getManual, getMakeDefault) => {
  const { invalidate, size: sizeStore, camera: defaultCamera } = useThrelte();
  const camera = tag(user_derived(getCamera), "camera");
  const size = fromStore(sizeStore);
  user_pre_effect(() => {
    if (!getMakeDefault()) {
      return;
    }
    const current = get(camera);
    defaultCameras.add(current);
    defaultCamera.set(current);
    invalidate();
    return () => {
      defaultCameras.delete(current);
      if (strict_equals(defaultCameras.size, 0)) {
        defaultCamera.set(void 0);
        invalidate();
      }
    };
  });
  user_pre_effect(() => {
    if (getManual()) {
      return;
    }
    const { width, height } = size.current;
    if (isInstanceOf(get(camera), "PerspectiveCamera")) {
      get(camera).aspect = width / height;
    } else if (isInstanceOf(get(camera), "OrthographicCamera")) {
      get(camera).left = width / -2;
      get(camera).right = width / 2;
      get(camera).top = height / 2;
      get(camera).bottom = height / -2;
    }
    get(camera).updateProjectionMatrix();
    get(camera).updateMatrixWorld();
    invalidate();
  });
};

// node_modules/@threlte/core/dist/components/T/utils/useDispose.svelte.js
var contextName = /* @__PURE__ */ Symbol("threlte-disposable-object-context");
var isDisposableObject = (object) => {
  return strict_equals(typeof object?.dispose, "function");
};
var useSetDispose = (getDispose) => {
  const parentDispose = getContext(contextName);
  const mergedDispose = tag(user_derived(() => getDispose() ?? parentDispose?.() ?? true), "mergedDispose");
  setContext(contextName, () => get(mergedDispose));
};
var useDispose = (getDisposable) => {
  const disposable = tag(user_derived(getDisposable), "disposable");
  const {
    disposableObjectMounted,
    disposableObjectUnmounted,
    removeObjectFromDisposal
  } = useDisposal();
  const parentDispose = getContext(contextName);
  const dispose = tag(user_derived(() => parentDispose?.() ?? true), "dispose");
  user_effect(() => {
    if (get(dispose)) {
      disposableObjectMounted(get(disposable));
      return () => disposableObjectUnmounted(get(disposable));
    }
    removeObjectFromDisposal(get(disposable));
    return;
  });
};

// node_modules/@threlte/core/dist/components/T/utils/useEvents.svelte.js
var isEventDispatcher = (value) => {
  return strict_equals(value, null, false) && strict_equals(typeof value, "object") && "addEventListener" in value && "removeEventListener" in value;
};
var useEvents = (getRef, propKeys, props) => {
  const ref = tag(user_derived(getRef), "ref");
  for (const key of propKeys) {
    const prop2 = tag(user_derived(() => props[key]), "prop");
    if (key.startsWith("on")) {
      user_pre_effect(() => {
        if (strict_equals(typeof get(prop2), "function", false) || !isEventDispatcher(get(ref))) {
          return;
        }
        const name = key.slice(2);
        get(ref).addEventListener(name, get(prop2));
        return () => get(ref).removeEventListener(name, get(prop2));
      });
    }
  }
};

// node_modules/@threlte/core/dist/components/T/utils/useIs.js
var currentIs;
var setIs = (is) => {
  currentIs = is;
};
var useIs = () => {
  const is = currentIs;
  currentIs = void 0;
  return is;
};

// node_modules/@threlte/core/dist/plugins/types.js
var pluginContextKey = "threlte-plugin-context";

// node_modules/@threlte/core/dist/components/T/utils/usePlugins.js
var usePlugins = (args) => {
  const plugins = getContext(pluginContextKey);
  if (!plugins)
    return;
  const pluginsProps = [];
  const pluginsArray = Object.values(plugins);
  if (pluginsArray.length > 0) {
    const pluginArgs = args();
    for (let i = 0; i < pluginsArray.length; i++) {
      const plugin = pluginsArray[i];
      const p = plugin(pluginArgs);
      if (p && p.pluginProps) {
        pluginsProps.push(...p.pluginProps);
      }
    }
  }
  return {
    pluginsProps
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useProps.js
var ignoredProps = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]);
var updateProjectionMatrixKeys = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]);
var memoizeProp = (value) => {
  if (typeof value === "string")
    return true;
  if (typeof value === "number")
    return true;
  if (typeof value === "boolean")
    return true;
  if (typeof value === "undefined")
    return true;
  if (value === null)
    return true;
  return false;
};
var createSetter = (target, key, value) => {
  if (!Array.isArray(value) && typeof value === "number" && typeof target[key] === "object" && target[key] !== null && typeof target[key]?.setScalar === "function" && // colors do have a setScalar function, but we don't want to use it, because
  // the hex notation (i.e. 0xff0000) is very popular and matches the number
  // type. So we exclude colors here.
  !target[key]?.isColor) {
    return (target2, key2, value2) => {
      target2[key2].setScalar(value2);
    };
  } else {
    if (typeof target[key]?.set === "function" && typeof target[key] === "object" && target[key] !== null) {
      if (Array.isArray(value)) {
        return (target2, key2, value2) => {
          target2[key2].set(...value2);
        };
      } else {
        return (target2, key2, value2) => {
          target2[key2].set(value2);
        };
      }
    } else {
      return (target2, key2, value2) => {
        target2[key2] = value2;
      };
    }
  }
};
var useProps = () => {
  const { invalidate } = useThrelte();
  const memoizedProps = /* @__PURE__ */ new Map();
  const memoizedSetters = /* @__PURE__ */ new Map();
  const setProp = (instance, propertyPath, value, manualCamera) => {
    if (memoizeProp(value)) {
      const memoizedProp = memoizedProps.get(propertyPath);
      if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {
        return;
      }
      memoizedProps.set(propertyPath, {
        instance,
        value
      });
    }
    const { key, target } = resolvePropertyPath(instance, propertyPath);
    if (value !== void 0 && value !== null) {
      const memoizedSetter = memoizedSetters.get(propertyPath);
      if (memoizedSetter) {
        memoizedSetter(target, key, value);
      } else {
        const setter = createSetter(target, key, value);
        memoizedSetters.set(propertyPath, setter);
        setter(target, key, value);
      }
    } else {
      createSetter(target, key, value)(target, key, value);
    }
    if (manualCamera)
      return;
    if (updateProjectionMatrixKeys.has(key) && (target.isPerspectiveCamera || target.isOrthographicCamera)) {
      target.updateProjectionMatrix();
    }
  };
  const updateProp = (instance, key, value, pluginsProps, manualCamera) => {
    if (!ignoredProps.has(key) && !pluginsProps?.includes(key)) {
      setProp(instance, key, value, manualCamera);
    }
    invalidate();
  };
  return {
    updateProp
  };
};

// node_modules/@threlte/core/dist/components/T/utils/utils.js
var isClass = (input) => {
  return typeof input === "function" && Function.prototype.toString.call(input).startsWith("class ");
};
var determineRef = (is, args) => {
  if (isClass(is)) {
    if (Array.isArray(args)) {
      return new is(...args);
    } else {
      return new is();
    }
  }
  return is;
};

// node_modules/@threlte/core/dist/components/T/T.svelte
T[FILENAME] = "node_modules/@threlte/core/dist/components/T/T.svelte";
function T($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, T);
  let is = prop($$props, "is", 19, useIs), manual = prop($$props, "manual", 3, false), makeDefault = prop($$props, "makeDefault", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "is",
      "args",
      "attach",
      "manual",
      "makeDefault",
      "dispose",
      "ref",
      "oncreate",
      "children"
    ],
    "props"
  );
  const internalRef = tag(user_derived(() => determineRef(is(), $$props.args)), "internalRef");
  user_pre_effect(() => {
    if (strict_equals(ref(), get(internalRef))) return;
    ref(get(internalRef));
  });
  const plugins = usePlugins(() => ({
    get ref() {
      return get(internalRef);
    },
    get args() {
      return $$props.args;
    },
    get attach() {
      return $$props.attach;
    },
    get manual() {
      return manual();
    },
    get makeDefault() {
      return makeDefault();
    },
    get dispose() {
      return $$props.dispose;
    },
    get props() {
      return props;
    }
  }));
  const propKeys = Object.keys(props);
  const { updateProp } = useProps();
  propKeys.forEach((key) => {
    const prop2 = tag(user_derived(() => props[key]), "prop");
    user_pre_effect(() => {
      updateProp(get(internalRef), key, get(prop2), plugins?.pluginsProps, manual());
    });
  });
  useAttach(() => get(internalRef), () => $$props.attach);
  user_pre_effect(() => {
    if (isInstanceOf(get(internalRef), "PerspectiveCamera") || isInstanceOf(get(internalRef), "OrthographicCamera")) {
      useCamera2(() => get(internalRef), () => manual(), () => makeDefault());
    }
  });
  useSetDispose(() => $$props.dispose);
  user_pre_effect(() => {
    if (isDisposableObject(get(internalRef))) {
      useDispose(() => get(internalRef));
    }
  });
  useEvents(() => get(internalRef), propKeys, props);
  user_effect(() => {
    get(internalRef);
    let cleanup = void 0;
    untrack(() => {
      cleanup = $$props.oncreate?.(get(internalRef));
    });
    return cleanup;
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ ref: get(internalRef) })), "render", T, 123, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  T = hmr(T);
  import.meta.hot.accept((module) => {
    T[HMR].update(module.default);
  });
}
var T_default = T;

// node_modules/@threlte/core/dist/components/T/T.js
var catalogue = {};
var extend = (extensions) => {
  Object.assign(catalogue, extensions);
};
var T2 = new Proxy(T_default, {
  get(_target, is) {
    if (typeof is !== "string") {
      return T_default;
    }
    const module = catalogue[is] || THREE[is];
    if (module === void 0) {
      throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);
    }
    setIs(module);
    return T_default;
  }
});

// node_modules/@threlte/core/dist/plugins/injectPlugin.js
function injectPlugin(name, plugin) {
  if (!plugin)
    return;
  setContext(pluginContextKey, {
    ...getContext(pluginContextKey),
    [name]: plugin
  });
}

// node_modules/@threlte/core/dist/hooks/useStage.js
function useStage(key, options) {
  const { scheduler } = useThrelte();
  return scheduler.getStage(key) ?? scheduler.createStage(key, options);
}

// node_modules/@threlte/core/dist/hooks/useThrelteUserContext.js
function useThrelteUserContext(namespace, value, options) {
  const userCtxStore = useUserContext();
  if (!userCtxStore) {
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  }
  if (!namespace) {
    return {
      subscribe: userCtxStore.subscribe
    };
  }
  if (namespace && !value) {
    return derived(userCtxStore, (ctx) => ctx[namespace]);
  }
  userCtxStore.update((ctx) => {
    if (namespace in ctx) {
      if (!options || options.existing === "skip")
        return ctx;
      if (options.existing === "merge") {
        const v2 = typeof value === "function" ? value() : value;
        Object.assign(ctx[namespace], v2);
        return ctx;
      }
    }
    const v = typeof value === "function" ? value() : value;
    ctx[namespace] = v;
    return ctx;
  });
  return userCtxStore.current[namespace];
}

// node_modules/@threlte/core/dist/hooks/useLoader.js
function useLoader(Proto, options) {
  const { remember, clear: clearCacheItem } = useCache();
  let loader;
  const initializeLoader = () => {
    const lazyLoader = new Proto(...options?.args ?? []);
    options?.extend?.(lazyLoader);
    return lazyLoader;
  };
  const load = (input, options2) => {
    const loadResource = async (url) => {
      if (!loader) {
        loader = initializeLoader();
      }
      if ("loadAsync" in loader) {
        const result = await loader.loadAsync(url, options2?.onProgress);
        return options2?.transform?.(result) ?? result;
      } else {
        return new Promise((resolve, reject) => {
          ;
          loader.load(url, (data) => resolve(options2?.transform?.(data) ?? data), (event) => options2?.onProgress?.(event), reject);
        });
      }
    };
    if (Array.isArray(input)) {
      const promises = input.map((url) => {
        return remember(() => loadResource(url), [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises));
      return store;
    } else if (typeof input === "string") {
      const promise = remember(() => loadResource(input), [Proto, input]);
      const store = asyncWritable(promise);
      return store;
    } else {
      const promises = Object.values(input).map((url) => {
        return remember(() => loadResource(url), [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises).then((results) => {
        return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));
      }));
      return store;
    }
  };
  const clear = (input) => {
    if (Array.isArray(input)) {
      input.forEach((url) => {
        clearCacheItem([Proto, url]);
      });
    } else if (typeof input === "string") {
      clearCacheItem([Proto, input]);
    } else {
      Object.entries(input).forEach(([key, url]) => {
        clearCacheItem([Proto, key, url]);
      });
    }
  };
  return {
    load,
    clear,
    loader
  };
}

// node_modules/@threlte/core/dist/index.js
var VERSION = 8;

export {
  createCacheContext,
  useCache,
  observe,
  isInstanceOf,
  asyncWritable,
  browser,
  revision,
  watch,
  currentWritable,
  toCurrentReadable,
  resolvePropertyPath,
  createDOMContext,
  useDOM,
  createSchedulerContext,
  useScheduler,
  createCameraContext,
  useCamera,
  createDisposalContext,
  useDisposal,
  createParentContext,
  useParent,
  createParentObject3DContext,
  useParentObject3D,
  useTask,
  createSceneContext,
  useScene,
  createRendererContext,
  useRenderer,
  createUserContext,
  createThrelteContext,
  Canvas_default,
  useThrelte,
  extend,
  T2 as T,
  injectPlugin,
  useStage,
  useThrelteUserContext,
  useLoader,
  VERSION
};
//# sourceMappingURL=chunk-P6GNDLNW.js.map
