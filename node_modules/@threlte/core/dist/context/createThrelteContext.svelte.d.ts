import { type CreateDOMContextOptions } from './fragments/dom.js';
import { type CreateRendererContextOptions, type Renderer } from './fragments/renderer.svelte.js';
import { type CreateSchedulerContextOptions } from './fragments/scheduler.svelte.js';
export type CreateThrelteContextOptions<T extends Renderer> = CreateRendererContextOptions<T> & CreateDOMContextOptions & CreateSchedulerContextOptions;
export declare const createThrelteContext: <T extends Renderer>(options: CreateThrelteContextOptions<T>) => {
    set(this: void, value: Record<string | symbol, unknown>): void;
    update(this: void, updater: import("svelte/store").Updater<Record<string | symbol, unknown>>): void;
    subscribe(this: void, run: import("svelte/store").Subscriber<Record<string | symbol, unknown>>, invalidate?: () => void): import("svelte/store").Unsubscriber;
    current: Record<string | symbol, unknown>;
    renderer: T;
    colorManagementEnabled: import("../index.js").CurrentWritable<boolean>;
    colorSpace: import("../index.js").CurrentWritable<import("three").ColorSpace>;
    toneMapping: import("../index.js").CurrentWritable<import("three").ToneMapping>;
    shadows: import("../index.js").CurrentWritable<boolean | import("three").ShadowMapType>;
    dpr: import("../index.js").CurrentWritable<number>;
    autoRenderTask: import("../index.js").Task;
    camera: import("../index.js").CurrentWritable<import("three").Camera>;
    scheduler: import("../index.js").Scheduler;
    renderMode: import("../index.js").CurrentWritable<"always" | "on-demand" | "manual">;
    autoRender: import("../index.js").CurrentWritable<boolean>;
    frameInvalidated: boolean;
    advance: () => void;
    shouldAdvance: boolean;
    autoInvalidations: Set<unknown>;
    resetFrameInvalidation: () => void;
    shouldRender: () => boolean;
    invalidate: () => void;
    mainStage: import("../index.js").Stage;
    renderStage: import("../index.js").Stage;
    dispose: (force?: boolean) => void;
    disposableObjectMounted: (object: import("./fragments/disposal.js").DisposableObject) => void;
    disposableObjectUnmounted: (object: import("./fragments/disposal.js").DisposableObject) => void;
    removeObjectFromDisposal: (object: import("./fragments/disposal.js").DisposableObject) => void;
    disposableObjects: Map<import("./fragments/disposal.js").DisposableObject, number>;
    shouldDispose: boolean;
    items: {
        promise: Promise<unknown>;
        keys: [unknown] | unknown[];
    }[];
    remember: <T_1>(callback: () => Promise<T_1>, keys: [unknown] | unknown[]) => Promise<T_1>;
    clear: (keys: [unknown] | unknown[]) => void;
    dom: HTMLElement;
    canvas: HTMLCanvasElement;
    size: import("../index.js").CurrentReadable<{
        width: number;
        height: number;
    }>;
    scene: import("three").Scene;
};
